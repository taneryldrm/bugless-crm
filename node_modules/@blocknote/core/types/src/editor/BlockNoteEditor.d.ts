import { EditorOptions, FocusPosition, Editor as TiptapEditor } from "@tiptap/core";
import { type Command, type Plugin, type Transaction } from "@tiptap/pm/state";
import { Node, Schema } from "prosemirror-model";
import type { BlocksChanged } from "../api/getBlocksChangedByTransaction.js";
import { Block, BlockNoteSchema, DefaultBlockSchema, DefaultInlineContentSchema, DefaultStyleSchema, PartialBlock } from "../blocks/index.js";
import type { CollaborationOptions } from "../extensions/Collaboration/Collaboration.js";
import type { Dictionary } from "../i18n/dictionary.js";
import type { BlockIdentifier, BlockNoteDOMAttributes, BlockSchema, BlockSpecs, CustomBlockNoteSchema, InlineContentSchema, InlineContentSpecs, PartialInlineContent, Styles, StyleSchema, StyleSpecs } from "../schema/index.js";
import "../style.css";
import { EventEmitter } from "../util/EventEmitter.js";
import type { NoInfer } from "../util/typescript.js";
import { ExtensionFactoryInstance } from "./BlockNoteExtension.js";
import type { TextCursorPosition } from "./cursorPositionTypes.js";
import { ExtensionManager } from "./managers/index.js";
import type { Selection } from "./selectionTypes.js";
export type BlockCache<BSchema extends BlockSchema = any, ISchema extends InlineContentSchema = any, SSchema extends StyleSchema = any> = WeakMap<Node, Block<BSchema, ISchema, SSchema>>;
export interface BlockNoteEditorOptions<BSchema extends BlockSchema, ISchema extends InlineContentSchema, SSchema extends StyleSchema> {
    /**
     * Whether changes to blocks (like indentation, creating lists, changing headings) should be animated or not. Defaults to `true`.
     *
     * @default true
     */
    animations?: boolean;
    /**
     * Whether the editor should be focused automatically when it's created.
     *
     * @default false
     */
    autofocus?: FocusPosition;
    /**
     * When enabled, allows for collaboration between multiple users.
     * See [Real-time Collaboration](https://www.blocknotejs.org/docs/advanced/real-time-collaboration) for more info.
     */
    collaboration?: CollaborationOptions;
    /**
     * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.
     *
     * @default true
     */
    defaultStyles?: boolean;
    /**
     * A dictionary object containing translations for the editor.
     *
     * See [Localization / i18n](https://www.blocknotejs.org/docs/advanced/localization) for more info.
     *
     * @remarks `Dictionary` is a type that contains all the translations for the editor.
     */
    dictionary?: Dictionary & Record<string, any>;
    /**
     * Disable internal extensions (based on keys / extension name)
     *
     * @note Advanced
     */
    disableExtensions?: string[];
    /**
     * An object containing attributes that should be added to HTML elements of the editor.
     *
     * See [Adding DOM Attributes](https://www.blocknotejs.org/docs/theming#adding-dom-attributes) for more info.
     *
     * @example { editor: { class: "my-editor-class" } }
     * @remarks `Record<string, Record<string, string>>`
     */
    domAttributes?: Partial<BlockNoteDOMAttributes>;
    /**
     * A replacement indicator to use when dragging and dropping blocks. Uses the [ProseMirror drop cursor](https://github.com/ProseMirror/prosemirror-dropcursor), or a modified version when [Column Blocks](https://www.blocknotejs.org/docs/document-structure#column-blocks) are enabled.
     * @remarks `() => Plugin`
     */
    dropCursor?: (opts: {
        editor: BlockNoteEditor<NoInfer<BSchema>, NoInfer<ISchema>, NoInfer<SSchema>>;
        color?: string | false;
        width?: number;
        class?: string;
    }) => Plugin;
    /**
     * The content that should be in the editor when it's created, represented as an array of {@link PartialBlock} objects.
     *
     * See [Partial Blocks](https://www.blocknotejs.org/docs/editor-api/manipulating-blocks#partial-blocks) for more info.
     *
     * @remarks `PartialBlock[]`
     */
    initialContent?: PartialBlock<NoInfer<BSchema>, NoInfer<ISchema>, NoInfer<SSchema>>[];
    /**
     * @deprecated, provide placeholders via dictionary instead
     * @internal
     */
    placeholders?: Record<string | "default" | "emptyDocument", string | undefined>;
    /**
     * Custom paste handler that can be used to override the default paste behavior.
     *
     * See [Paste Handling](https://www.blocknotejs.org/docs/advanced/paste-handling) for more info.
     *
     * @remarks `PasteHandler`
     * @returns The function should return `true` if the paste event was handled, otherwise it should return `false` if it should be canceled or `undefined` if it should be handled by another handler.
     *
     * @example
     * ```ts
     * pasteHandler: ({ defaultPasteHandler }) => {
     *   return defaultPasteHandler({ pasteBehavior: "prefer-html" });
     * }
     * ```
     */
    pasteHandler?: (context: {
        event: ClipboardEvent;
        editor: BlockNoteEditor<NoInfer<BSchema>, NoInfer<ISchema>, NoInfer<SSchema>>;
        /**
         * The default paste handler
         * @param context The context object
         * @returns Whether the paste event was handled or not
         */
        defaultPasteHandler: (context?: {
            /**
             * Whether to prioritize Markdown content in `text/plain` over `text/html` when pasting from the clipboard.
             * @default true
             */
            prioritizeMarkdownOverHTML?: boolean;
            /**
             * Whether to parse `text/plain` content from the clipboard as Markdown content.
             * @default true
             */
            plainTextAsMarkdown?: boolean;
        }) => boolean | undefined;
    }) => boolean | undefined;
    /**
     * Resolve a URL of a file block to one that can be displayed or downloaded. This can be used for creating authenticated URL or
     * implementing custom protocols / schemes
     * @returns The URL that's
     */
    resolveFileUrl?: (url: string) => Promise<string>;
    /**
     * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.
     *
     * See [Custom Schemas](https://www.blocknotejs.org/docs/custom-schemas) for more info.
     * @remarks `BlockNoteSchema`
     */
    schema: CustomBlockNoteSchema<BSchema, ISchema, SSchema>;
    /**
     * A flag indicating whether to set an HTML ID for every block
     *
     * When set to `true`, on each block an id attribute will be set with the block id
     * Otherwise, the HTML ID attribute will not be set.
     *
     * (note that the id is always set on the `data-id` attribute)
     */
    setIdAttribute?: boolean;
    /**
     * Determines behavior when pressing Tab (or Shift-Tab) while multiple blocks are selected and a toolbar is open.
     * - `"prefer-navigate-ui"`: Changes focus to the toolbar. User must press Escape to close toolbar before indenting blocks. Better for keyboard accessibility.
     * - `"prefer-indent"`: Always indents selected blocks, regardless of toolbar state. Keyboard navigation of toolbars not possible.
     * @default "prefer-navigate-ui"
     */
    tabBehavior?: "prefer-navigate-ui" | "prefer-indent";
    /**
     * Allows enabling / disabling features of tables.
     *
     * See [Tables](https://www.blocknotejs.org/docs/editor-basics/document-structure#tables) for more info.
     *
     * @remarks `TableConfig`
     */
    tables?: {
        /**
         * Whether to allow splitting and merging cells within a table.
         *
         * @default false
         */
        splitCells?: boolean;
        /**
         * Whether to allow changing the background color of cells.
         *
         * @default false
         */
        cellBackgroundColor?: boolean;
        /**
         * Whether to allow changing the text color of cells.
         *
         * @default false
         */
        cellTextColor?: boolean;
        /**
         * Whether to allow changing cells into headers.
         *
         * @default false
         */
        headers?: boolean;
    };
    /**
     * An option which user can pass with `false` value to disable the automatic creation of a trailing new block on the next line when the user types or edits any block.
     *
     * @default true
     */
    trailingBlock?: boolean;
    /**
     * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).
     * This method should set when creating the editor as this is application-specific.
     *
     * `undefined` means the application doesn't support file uploads.
     *
     * @param file The file that should be uploaded.
     * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)
     * @remarks `(file: File) => Promise<UploadFileResult>`
     */
    uploadFile?: (file: File, blockId?: string) => Promise<string | Record<string, any>>;
    /**
     * additional tiptap options, undocumented
     * @internal
     */
    _tiptapOptions?: Partial<EditorOptions>;
    /**
     * Register extensions to the editor.
     *
     * See [Extensions](/docs/features/extensions) for more info.
     *
     * @remarks `ExtensionFactory[]`
     */
    extensions?: Array<ExtensionFactoryInstance>;
}
export declare class BlockNoteEditor<BSchema extends BlockSchema = DefaultBlockSchema, ISchema extends InlineContentSchema = DefaultInlineContentSchema, SSchema extends StyleSchema = DefaultStyleSchema> extends EventEmitter<{
    create: void;
}> {
    protected readonly options: Partial<BlockNoteEditorOptions<BSchema, ISchema, SSchema>>;
    /**
     * The underlying prosemirror schema
     */
    readonly pmSchema: Schema;
    readonly _tiptapEditor: TiptapEditor & {
        contentComponent: any;
    };
    /**
     * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements
     * in the correct context (used by `ReactRenderUtil`)
     */
    elementRenderer: ((node: any, container: HTMLElement) => void) | null;
    /**
     * Cache of all blocks. This makes sure we don't have to "recompute" blocks if underlying Prosemirror Nodes haven't changed.
     * This is especially useful when we want to keep track of the same block across multiple operations,
     * with this cache, blocks stay the same object reference (referential equality with ===).
     */
    blockCache: BlockCache;
    /**
     * The dictionary contains translations for the editor.
     */
    readonly dictionary: Dictionary & Record<string, any>;
    /**
     * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.
     */
    readonly schema: BlockNoteSchema<BSchema, ISchema, SSchema>;
    readonly blockImplementations: BlockSpecs;
    readonly inlineContentImplementations: InlineContentSpecs;
    readonly styleImplementations: StyleSpecs;
    /**
     * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).
     * This method should set when creating the editor as this is application-specific.
     *
     * `undefined` means the application doesn't support file uploads.
     *
     * @param file The file that should be uploaded.
     * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)
     */
    readonly uploadFile: ((file: File, blockId?: string) => Promise<string | Record<string, any>>) | undefined;
    private onUploadStartCallbacks;
    private onUploadEndCallbacks;
    readonly resolveFileUrl?: (url: string) => Promise<string>;
    /**
     * Editor settings
     */
    readonly settings: {
        tables: {
            splitCells: boolean;
            cellBackgroundColor: boolean;
            cellTextColor: boolean;
            headers: boolean;
        };
    };
    static create<Options extends Partial<BlockNoteEditorOptions<any, any, any>> | undefined>(options?: Options): Options extends {
        schema: CustomBlockNoteSchema<infer BSchema, infer ISchema, infer SSchema>;
    } ? BlockNoteEditor<BSchema, ISchema, SSchema> : BlockNoteEditor<DefaultBlockSchema, DefaultInlineContentSchema, DefaultStyleSchema>;
    protected constructor(options: Partial<BlockNoteEditorOptions<BSchema, ISchema, SSchema>>);
    private readonly _blockManager;
    private readonly _eventManager;
    private readonly _exportManager;
    private readonly _extensionManager;
    private readonly _selectionManager;
    private readonly _stateManager;
    private readonly _styleManager;
    /**
     * BlockNote extensions that are added to the editor, keyed by the extension key
     */
    get extensions(): Map<string, import("./BlockNoteExtension.js").Extension<any, string>>;
    /**
     * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
     *
     * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
     *
     * @example
     * ```ts
     * editor.exec((state, dispatch, view) => {
     *   dispatch(state.tr.insertText("Hello, world!"));
     * });
     * ```
     */
    exec(command: Command): boolean;
    /**
     * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
     *
     * @example
     * ```ts
     * if (editor.canExec(command)) {
     *   // show button
     * } else {
     *   // hide button
     * }
     * ```
     */
    canExec(command: Command): boolean;
    /**
     * Execute a function within a "blocknote transaction".
     * All changes to the editor within the transaction will be grouped together, so that
     * we can dispatch them as a single operation (thus creating only a single undo step)
     *
     * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
     *
     * @example
     * ```ts
     * // All changes to the editor will be grouped together
     * editor.transact((tr) => {
     *   tr.insertText("Hello, world!");
     * // These two operations will be grouped together in a single undo step
     *   editor.transact((tr) => {
     *     tr.insertText("Hello, world!");
     *   });
     * });
     * ```
     */
    transact<T>(callback: (
    /**
     * The current active transaction, this will automatically be dispatched to the editor when the callback is complete
     * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.
     */
    tr: Transaction) => T): T;
    /**
     * Remove extension(s) from the editor
     */
    unregisterExtension: ExtensionManager["unregisterExtension"];
    /**
     * Register extension(s) to the editor
     */
    registerExtension: ExtensionManager["registerExtension"];
    /**
     * Get an extension from the editor
     */
    getExtension: ExtensionManager["getExtension"];
    /**
     * Mount the editor to a DOM element.
     *
     * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting
     */
    mount: (element: HTMLElement) => void;
    /**
     * Unmount the editor from the DOM element it is bound to
     */
    unmount: () => void;
    /**
     * Get the underlying prosemirror state
     * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
     * @see https://prosemirror.net/docs/ref/#state.EditorState
     */
    get prosemirrorState(): import("prosemirror-state").EditorState;
    /**
     * Get the underlying prosemirror view
     * @see https://prosemirror.net/docs/ref/#view.EditorView
     */
    get prosemirrorView(): import("prosemirror-view").EditorView;
    get domElement(): HTMLDivElement | undefined;
    isFocused(): boolean;
    get headless(): boolean;
    /**
     * Focus on the editor
     */
    focus(): void;
    /**
     * Blur the editor
     */
    blur(): void;
    onUploadStart(callback: (blockId?: string) => void): () => void;
    onUploadEnd(callback: (blockId?: string) => void): () => void;
    /**
     * @deprecated, use `editor.document` instead
     */
    get topLevelBlocks(): Block<BSchema, ISchema, SSchema>[];
    /**
     * Gets a snapshot of all top-level (non-nested) blocks in the editor.
     * @returns A snapshot of all top-level (non-nested) blocks in the editor.
     */
    get document(): Block<BSchema, ISchema, SSchema>[];
    /**
     * Gets a snapshot of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block that should be
     * retrieved.
     * @returns The block that matches the identifier, or `undefined` if no
     * matching block was found.
     */
    getBlock(blockIdentifier: BlockIdentifier): Block<BSchema, ISchema, SSchema> | undefined;
    /**
     * Gets a snapshot of the previous sibling of an existing block from the
     * editor.
     * @param blockIdentifier The identifier of an existing block for which the
     * previous sibling should be retrieved.
     * @returns The previous sibling of the block that matches the identifier.
     * `undefined` if no matching block was found, or it's the first child/block
     * in the document.
     */
    getPrevBlock(blockIdentifier: BlockIdentifier): Block<BSchema, ISchema, SSchema> | undefined;
    /**
     * Gets a snapshot of the next sibling of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block for which the
     * next sibling should be retrieved.
     * @returns The next sibling of the block that matches the identifier.
     * `undefined` if no matching block was found, or it's the last child/block in
     * the document.
     */
    getNextBlock(blockIdentifier: BlockIdentifier): Block<BSchema, ISchema, SSchema> | undefined;
    /**
     * Gets a snapshot of the parent of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block for which the
     * parent should be retrieved.
     * @returns The parent of the block that matches the identifier. `undefined`
     * if no matching block was found, or the block isn't nested.
     */
    getParentBlock(blockIdentifier: BlockIdentifier): Block<BSchema, ISchema, SSchema> | undefined;
    /**
     * Traverses all blocks in the editor depth-first, and executes a callback for each.
     * @param callback The callback to execute for each block. Returning `false` stops the traversal.
     * @param reverse Whether the blocks should be traversed in reverse order.
     */
    forEachBlock(callback: (block: Block<BSchema, ISchema, SSchema>) => boolean, reverse?: boolean): void;
    /**
     * Executes a callback whenever the editor's contents change.
     * @param callback The callback to execute.
     *
     * @deprecated use {@link BlockNoteEditor.onChange} instead
     */
    onEditorContentChange(callback: () => void): void;
    /**
     * Executes a callback whenever the editor's selection changes.
     * @param callback The callback to execute.
     *
     * @deprecated use `onSelectionChange` instead
     */
    onEditorSelectionChange(callback: () => void): void;
    /**
     * Executes a callback before any change is applied to the editor, allowing you to cancel the change.
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onBeforeChange(callback: (context: {
        getChanges: () => BlocksChanged<BSchema, ISchema, SSchema>;
        tr: Transaction;
    }) => boolean | void): () => void;
    /**
     * Gets a snapshot of the current text cursor position.
     * @returns A snapshot of the current text cursor position.
     */
    getTextCursorPosition(): TextCursorPosition<BSchema, ISchema, SSchema>;
    /**
     * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
     * not be found.
     * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
     * @param placement Whether the text cursor should be placed at the start or end of the block.
     */
    setTextCursorPosition(targetBlock: BlockIdentifier, placement?: "start" | "end"): void;
    /**
     * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
     * that the selection spans across.
     *
     * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
     */
    getSelection(): Selection<BSchema, ISchema, SSchema> | undefined;
    /**
     * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
     * that the selection spans across.
     *
     * If the selection starts / ends halfway through a block, the returned block will be
     * only the part of the block that is included in the selection.
     */
    getSelectionCutBlocks(expandToWords?: boolean): {
        blocks: Block<Record<string, import("../index.js").BlockConfig<string, import("../index.js").PropSchema, "inline" | "none" | "table">>, InlineContentSchema, StyleSchema>[];
        blockCutAtStart: string | undefined;
        blockCutAtEnd: string | undefined;
        _meta: {
            startPos: number;
            endPos: number;
        };
    };
    /**
     * Sets the selection to a range of blocks.
     * @param startBlock The identifier of the block that should be the start of the selection.
     * @param endBlock The identifier of the block that should be the end of the selection.
     */
    setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier): void;
    /**
     * Checks if the editor is currently editable, or if it's locked.
     * @returns True if the editor is editable, false otherwise.
     */
    get isEditable(): boolean;
    /**
     * Makes the editor editable or locks it, depending on the argument passed.
     * @param editable True to make the editor editable, or false to lock it.
     */
    set isEditable(editable: boolean);
    /**
     * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
     * error if the reference block could not be found.
     * @param blocksToInsert An array of partial blocks that should be inserted.
     * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
     * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
     * `referenceBlock`.
     */
    insertBlocks(blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[], referenceBlock: BlockIdentifier, placement?: "before" | "after"): Block<any, any, any>[];
    /**
     * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
     * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
     * not be found.
     * @param blockToUpdate The block that should be updated.
     * @param update A partial block which defines how the existing block should be changed.
     */
    updateBlock(blockToUpdate: BlockIdentifier, update: PartialBlock<BSchema, ISchema, SSchema>): Block<any, any, any>;
    /**
     * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
     * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
     */
    removeBlocks(blocksToRemove: BlockIdentifier[]): Block<Record<string, import("../index.js").BlockConfig<string, import("../index.js").PropSchema, "inline" | "none" | "table">>, InlineContentSchema, StyleSchema>[];
    /**
     * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
     * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
     * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
     * @param blocksToRemove An array of blocks that should be replaced.
     * @param blocksToInsert An array of partial blocks to replace the old ones with.
     */
    replaceBlocks(blocksToRemove: BlockIdentifier[], blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[]): {
        insertedBlocks: Block<any, any, any>[];
        removedBlocks: Block<any, any, any>[];
    };
    /**
     * Undo the last action.
     */
    undo(): boolean;
    /**
     * Redo the last action.
     */
    redo(): boolean;
    /**
     * Insert a piece of content at the current cursor position.
     *
     * @param content can be a string, or array of partial inline content elements
     */
    insertInlineContent(content: PartialInlineContent<ISchema, SSchema>, { updateSelection }?: {
        updateSelection?: boolean;
    }): void;
    /**
     * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
     */
    getActiveStyles(): Styles<SSchema>;
    /**
     * Adds styles to the currently selected content.
     * @param styles The styles to add.
     */
    addStyles(styles: Styles<SSchema>): void;
    /**
     * Removes styles from the currently selected content.
     * @param styles The styles to remove.
     */
    removeStyles(styles: Styles<SSchema>): void;
    /**
     * Toggles styles on the currently selected content.
     * @param styles The styles to toggle.
     */
    toggleStyles(styles: Styles<SSchema>): void;
    /**
     * Gets the currently selected text.
     */
    getSelectedText(): string;
    /**
     * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
     */
    getSelectedLinkUrl(): string | undefined;
    /**
     * Creates a new link to replace the selected content.
     * @param url The link URL.
     * @param text The text to display the link with.
     */
    createLink(url: string, text?: string): void;
    /**
     * Checks if the block containing the text cursor can be nested.
     */
    canNestBlock(): boolean;
    /**
     * Nests the block containing the text cursor into the block above it.
     */
    nestBlock(): void;
    /**
     * Checks if the block containing the text cursor is nested.
     */
    canUnnestBlock(): boolean;
    /**
     * Lifts the block containing the text cursor out of its parent.
     */
    unnestBlock(): void;
    /**
     * Moves the selected blocks up. If the previous block has children, moves
     * them to the end of its children. If there is no previous block, but the
     * current blocks share a common parent, moves them out of & before it.
     */
    moveBlocksUp(): void;
    /**
     * Moves the selected blocks down. If the next block has children, moves
     * them to the start of its children. If there is no next block, but the
     * current blocks share a common parent, moves them out of & after it.
     */
    moveBlocksDown(): void;
    /**
     * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
     * items are un-nested in the output HTML.
     *
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    blocksToHTMLLossy(blocks?: PartialBlock<BSchema, ISchema, SSchema>[]): string;
    /**
     * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
     *
     * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
     * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
     *
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    blocksToFullHTML(blocks?: PartialBlock<BSchema, ISchema, SSchema>[]): string;
    /**
     * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
     * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
     * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
     * @param html The HTML string to parse blocks from.
     * @returns The blocks parsed from the HTML string.
     */
    tryParseHTMLToBlocks(html: string): Block<BSchema, ISchema, SSchema>[];
    /**
     * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
     * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
     * @param blocks An array of blocks that should be serialized into Markdown.
     * @returns The blocks, serialized as a Markdown string.
     */
    blocksToMarkdownLossy(blocks?: PartialBlock<BSchema, ISchema, SSchema>[]): string;
    /**
     * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
     * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
     * as text.
     * @param markdown The Markdown string to parse blocks from.
     * @returns The blocks parsed from the Markdown string.
     */
    tryParseMarkdownToBlocks(markdown: string): Block<BSchema, ISchema, SSchema>[];
    /**
     * A callback function that runs whenever the editor's contents change.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onChange(callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>, context: {
        /**
         * Returns the blocks that were inserted, updated, or deleted by the change that occurred.
         */
        getChanges(): BlocksChanged<BSchema, ISchema, SSchema>;
    }) => void, 
    /**
     * If true, the callback will be triggered when the changes are caused by a remote user
     * @default true
     */
    includeUpdatesFromRemote?: boolean): import("./managers/EventManager.js").Unsubscribe;
    /**
     * A callback function that runs whenever the text cursor position or selection changes.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onSelectionChange(callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>) => void, includeSelectionChangedByRemote?: boolean): import("./managers/EventManager.js").Unsubscribe;
    /**
     * A callback function that runs when the editor has been mounted.
     *
     * This can be useful for plugins to initialize themselves after the editor has been mounted.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onMount(callback: (ctx: {
        editor: BlockNoteEditor<BSchema, ISchema, SSchema>;
    }) => void): void;
    /**
     * A callback function that runs when the editor has been unmounted.
     *
     * This can be useful for plugins to clean up themselves after the editor has been unmounted.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onUnmount(callback: (ctx: {
        editor: BlockNoteEditor<BSchema, ISchema, SSchema>;
    }) => void): void;
    /**
     * Gets the bounding box of the current selection.
     * @returns The bounding box of the current selection.
     */
    getSelectionBoundingBox(): DOMRect | undefined;
    get isEmpty(): boolean;
    /**
     * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
     * @param html The HTML to paste.
     * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
     */
    pasteHTML(html: string, raw?: boolean): void;
    /**
     * Paste text into the editor. Defaults to interpreting text as markdown.
     * @param text The text to paste.
     */
    pasteText(text: string): boolean;
    /**
     * Paste markdown into the editor.
     * @param markdown The markdown to paste.
     */
    pasteMarkdown(markdown: string): void;
}
