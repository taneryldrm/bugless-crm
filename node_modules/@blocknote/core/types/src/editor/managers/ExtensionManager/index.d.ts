import { AnyExtension as AnyTiptapExtension } from "@tiptap/core";
import type { BlockNoteEditor, BlockNoteEditorOptions } from "../../BlockNoteEditor.js";
import type { Extension, ExtensionFactoryInstance, ExtensionFactory } from "../../BlockNoteExtension.js";
export declare class ExtensionManager {
    private editor;
    private options;
    /**
     * A set of extension keys which are disabled by the options
     */
    private disabledExtensions;
    /**
     * A list of all the extensions that are registered to the editor
     */
    private extensions;
    /**
     * A map of all the abort controllers for each extension that has an init method defined
     */
    private abortMap;
    /**
     * A map of all the extension factories that are registered to the editor
     */
    private extensionFactories;
    /**
     * Because a single blocknote extension can both have it's own prosemirror plugins & additional generated ones (e.g. keymap & input rules plugins)
     * We need to keep track of all the plugins for each extension, so that we can remove them when the extension is unregistered
     */
    private extensionPlugins;
    constructor(editor: BlockNoteEditor<any, any, any>, options: BlockNoteEditorOptions<any, any, any>);
    /**
     * Register one or more extensions to the editor after the editor is initialized.
     *
     * This allows users to switch on & off extensions "at runtime".
     */
    registerExtension(extension: Extension | ExtensionFactoryInstance | (Extension | ExtensionFactoryInstance)[]): void;
    /**
     * Register an extension to the editor
     * @param extension - The extension to register
     * @returns The extension instance
     */
    private addExtension;
    /**
     * Resolve an extension or a list of extensions into a list of extension instances
     * @param toResolve - The extension or list of extensions to resolve
     * @returns A list of extension instances
     */
    private resolveExtensions;
    /**
     * Unregister an extension from the editor
     * @param toUnregister - The extension to unregister
     * @returns void
     */
    unregisterExtension(toUnregister: undefined | string | Extension | ExtensionFactory | (Extension | ExtensionFactory | string | undefined)[]): void;
    /**
     * Allows resetting the current prosemirror state's plugins
     * @param update - A function that takes the current plugins and returns the new plugins
     * @returns void
     */
    private updatePlugins;
    /**
     * Get all the extensions that are registered to the editor
     */
    getTiptapExtensions(): AnyTiptapExtension[];
    /**
     * This maps a blocknote extension into an array of Prosemirror plugins if it has any of the following:
     * - plugins
     * - keyboard shortcuts
     * - input rules
     */
    private getProsemirrorPluginsFromExtension;
    /**
     * Get all extensions
     */
    getExtensions(): Map<string, Extension>;
    /**
     * Get a specific extension by it's instance
     */
    getExtension<const Ext extends Extension | ExtensionFactory = Extension>(extension: string): (Ext extends Extension ? Ext : Ext extends ExtensionFactory ? ReturnType<ReturnType<Ext>> : never) | undefined;
    getExtension<const T extends ExtensionFactory>(extension: T): ReturnType<ReturnType<T>> | undefined;
    /**
     * Check if an extension exists
     */
    hasExtension(key: string | Extension | ExtensionFactory): boolean;
}
