{"version":3,"file":"yjs.js","sources":["../src/yjs/utils.ts"],"sourcesContent":["import {\n  prosemirrorToYDoc,\n  prosemirrorToYXmlFragment,\n  yXmlFragmentToProseMirrorRootNode,\n} from \"y-prosemirror\";\nimport * as Y from \"yjs\";\n\nimport {\n  type Block,\n  type BlockNoteEditor,\n  type BlockSchema,\n  type InlineContentSchema,\n  type PartialBlock,\n  type StyleSchema,\n  blockToNode,\n  docToBlocks,\n} from \"../index.js\";\n\n/**\n * Turn Prosemirror JSON to BlockNote style JSON\n * @param editor BlockNote editor\n * @param json Prosemirror JSON\n * @returns BlockNote style JSON\n */\nexport function _prosemirrorJSONToBlocks<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, ISchema, SSchema>, json: any) {\n  // note: theoretically this should also be possible without creating prosemirror nodes,\n  // but this is definitely the easiest way\n  const doc = editor.pmSchema.nodeFromJSON(json);\n  return docToBlocks<BSchema, ISchema, SSchema>(doc);\n}\n\n/**\n * Turn BlockNote JSON to Prosemirror node / state\n * @param editor BlockNote editor\n * @param blocks BlockNote blocks\n * @returns Prosemirror root node\n */\nexport function _blocksToProsemirrorNode<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  blocks: PartialBlock<BSchema, ISchema, SSchema>[],\n) {\n  const pmNodes = blocks.map((b) => blockToNode(b, editor.pmSchema));\n\n  const doc = editor.pmSchema.topNodeType.create(\n    null,\n    editor.pmSchema.nodes[\"blockGroup\"].create(null, pmNodes),\n  );\n  return doc;\n}\n\n/** YJS / BLOCKNOTE conversions */\n\n/**\n * Turn a Y.XmlFragment collaborative doc into a BlockNote document (BlockNote style JSON of all blocks)\n * @param editor BlockNote editor\n * @param xmlFragment Y.XmlFragment\n * @returns BlockNote document (BlockNote style JSON of all blocks)\n */\nexport function yXmlFragmentToBlocks<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  xmlFragment: Y.XmlFragment,\n) {\n  const pmNode = yXmlFragmentToProseMirrorRootNode(\n    xmlFragment,\n    editor.pmSchema,\n  );\n  return docToBlocks<BSchema, ISchema, SSchema>(pmNode);\n}\n\n/**\n * Convert blocks to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param editor BlockNote editor\n * @param blocks the blocks to convert\n * @param xmlFragment XML fragment name\n * @returns Y.XmlFragment\n */\nexport function blocksToYXmlFragment<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  blocks: Block<BSchema, ISchema, SSchema>[],\n  xmlFragment?: Y.XmlFragment,\n) {\n  return prosemirrorToYXmlFragment(\n    _blocksToProsemirrorNode(editor, blocks),\n    xmlFragment,\n  );\n}\n\n/**\n * Turn a Y.Doc collaborative doc into a BlockNote document (BlockNote style JSON of all blocks)\n * @param editor BlockNote editor\n * @param ydoc Y.Doc\n * @param xmlFragment XML fragment name\n * @returns BlockNote document (BlockNote style JSON of all blocks)\n */\nexport function yDocToBlocks<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  ydoc: Y.Doc,\n  xmlFragment = \"prosemirror\",\n) {\n  return yXmlFragmentToBlocks(editor, ydoc.getXmlFragment(xmlFragment));\n}\n\n/**\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param editor BlockNote editor\n * @param blocks the blocks to convert\n * @param xmlFragment XML fragment name\n */\nexport function blocksToYDoc<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  blocks: PartialBlock<BSchema, ISchema, SSchema>[],\n  xmlFragment = \"prosemirror\",\n) {\n  return prosemirrorToYDoc(\n    _blocksToProsemirrorNode(editor, blocks),\n    xmlFragment,\n  );\n}\n"],"names":["_prosemirrorJSONToBlocks","editor","json","doc","docToBlocks","_blocksToProsemirrorNode","blocks","pmNodes","b","blockToNode","yXmlFragmentToBlocks","xmlFragment","pmNode","yXmlFragmentToProseMirrorRootNode","blocksToYXmlFragment","prosemirrorToYXmlFragment","yDocToBlocks","ydoc","blocksToYDoc","prosemirrorToYDoc"],"mappings":";;AAwBO,SAASA,EAIdC,GAAoDC,GAAW;AAG/D,QAAMC,IAAMF,EAAO,SAAS,aAAaC,CAAI;AAC7C,SAAOE,EAAuCD,CAAG;AACnD;AAQO,SAASE,EAKdJ,GACAK,GACA;AACA,QAAMC,IAAUD,EAAO,IAAI,CAACE,MAAMC,EAAYD,GAAGP,EAAO,QAAQ,CAAC;AAMjE,SAJYA,EAAO,SAAS,YAAY;AAAA,IACtC;AAAA,IACAA,EAAO,SAAS,MAAM,WAAc,OAAO,MAAMM,CAAO;AAAA,EAAA;AAG5D;AAUO,SAASG,EAKdT,GACAU,GACA;AACA,QAAMC,IAASC;AAAA,IACbF;AAAA,IACAV,EAAO;AAAA,EAAA;AAET,SAAOG,EAAuCQ,CAAM;AACtD;AAcO,SAASE,EAKdb,GACAK,GACAK,GACA;AACA,SAAOI;AAAA,IACLV,EAAyBJ,GAAQK,CAAM;AAAA,IACvCK;AAAA,EAAA;AAEJ;AASO,SAASK,EAKdf,GACAgB,GACAN,IAAc,eACd;AACA,SAAOD,EAAqBT,GAAQgB,EAAK,eAAeN,CAAW,CAAC;AACtE;AAWO,SAASO,EAKdjB,GACAK,GACAK,IAAc,eACd;AACA,SAAOQ;AAAA,IACLd,EAAyBJ,GAAQK,CAAM;AAAA,IACvCK;AAAA,EAAA;AAEJ;"}