var Oe = Object.defineProperty;
var Fe = (o, e, t) => e in o ? Oe(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var h = (o, e, t) => Fe(o, typeof e != "symbol" ? e + "" : e, t);
import { Slice as N, Fragment as A, DOMSerializer as he, DOMParser as $e, Node as He } from "prosemirror-model";
import { ReplaceStep as Ve, ReplaceAroundStep as V } from "prosemirror-transform";
import { n as U, i as O, g as C, b as q, a as b, t as Ue, U as F, q as _, r as $, d as ze, s as Ge, u as Re, v as Y, w as B, x as me, y as je, z as ke, A as z } from "./blockToNode-BNoNIXU7.js";
import { B as ns, G as ss, C as rs, D as is, N as as, E as cs, O as ls, F as ds, H as us, I as ps, L as fs, J as hs, M as ms, K as ks } from "./blockToNode-BNoNIXU7.js";
import { ak as H, al as We, am as Ke, an as Je, aj as x, ao as qe, ap as Ye, a5 as Qe, a8 as G, aq as Xe, ar as Ze, a6 as et, as as Q, a9 as ge, at as tt } from "./defaultBlocks-DvCGYzqu.js";
import { aw as bs, av as ys, E as Ss, a as Bs, F as Cs, r as xs, N as Es, a4 as Ms, ad as ws, aG as Ts, ax as Ps, b as vs, d as Is, e as As, a0 as _s, aM as Ds, au as Ls, c as Ns, f as Os, ag as Fs, ah as $s, aB as Hs, x as Vs, y as Us, A as zs, z as Gs, g as Rs, h as js, T as Ws, j as Ks, k as Js, l as qs, n as Ys, o as Qs, q as Xs, s as Zs, w as er, aC as tr, aH as or, B as nr, C as sr, H as rr, I as ir, J as ar, K as cr, aE as lr, aI as dr, M as ur, D as pr, G as fr, S as hr, O as mr, Q as kr, W as gr, U as br, _ as yr, Z as Sr, a2 as Br, Y as Cr, X as xr, R as Er, $ as Mr, m as wr, aN as Tr, aK as Pr, az as vr, af as Ir, i as Ar, ay as _r, aD as Dr, ae as Lr, a7 as Nr, t as Or, u as Fr, v as $r, aJ as Hr, ai as Vr, aL as Ur, a1 as zr, V as Gr, p as Rr, a3 as jr, aF as Wr, L as Kr, aO as Jr, P as qr, aA as Yr } from "./defaultBlocks-DvCGYzqu.js";
import { j as ot, k as be, l as nt, m as st, n as rt, c as R, F as it, Y as at, a as ct, b as lt, S as dt, B as ye, D as ut, L as pt, N as ft, P as ht, g as mt, i as kt, H as gt, h as bt, e as yt, V as St, d as Bt } from "./TrailingNode-8cXFaQUm.js";
import { s as Ct, B as xt } from "./BlockNoteSchema-BOW16JHv.js";
import { C as Xr, b as Zr, c as ei, a as ti, g as oi, u as ni, w as si } from "./BlockNoteSchema-BOW16JHv.js";
import { Node as D, Extension as E, mergeAttributes as Et, Mark as X, extensions as I, isNodeSelection as Mt, posToDOMRect as wt, selectionToInsertionEnd as Tt, getSchema as Pt, createDocument as vt, Editor as It } from "@tiptap/core";
import { E as Se } from "./EventEmitter-CjSwpTbz.js";
import { Fragment as Z, Slice as ne } from "@tiptap/pm/model";
import { e as At } from "./en-njEqD7AG.js";
import { inputRules as _t, InputRule as Dt } from "@handlewithcare/prosemirror-inputrules";
import { keymap as Lt } from "@tiptap/pm/keymap";
import { c as Nt, o as Ot } from "./BlockNoteExtension-C2X7LW-V.js";
import { a as ii } from "./BlockNoteExtension-C2X7LW-V.js";
import { Gapcursor as Ft } from "@tiptap/extension-gapcursor";
import { Link as $t } from "@tiptap/extension-link";
import { Text as Ht } from "@tiptap/extension-text";
import { NodeSelection as L, TextSelection as M, Plugin as ee } from "prosemirror-state";
import { CellSelection as te, TableMap as se } from "prosemirror-tables";
import { S as Vt } from "./ShowSelection-Dz-NEase.js";
import Ut from "remark-gfm";
import zt from "remark-parse";
import Gt, { defaultHandlers as re } from "remark-rehype";
import Rt from "rehype-stringify";
import { unified as jt } from "unified";
import { TextSelection as Wt } from "@tiptap/pm/state";
function Kt(o, e) {
  const t = [
    {
      tag: `[data-inline-content-type="${o.type}"]`,
      contentElement: (n) => {
        const s = n;
        return s.matches("[data-editable]") ? s : s.querySelector("[data-editable]") || s;
      }
    }
  ];
  return e && t.push({
    tag: "*",
    getAttrs(n) {
      if (typeof n == "string")
        return !1;
      const s = e == null ? void 0 : e(n);
      return s === void 0 ? !1 : s;
    }
  }), t;
}
function Qn(o, e) {
  var n;
  const t = D.create({
    name: o.type,
    inline: !0,
    group: "inline",
    draggable: (n = e.meta) == null ? void 0 : n.draggable,
    selectable: o.content === "styled",
    atom: o.content === "none",
    content: o.content === "styled" ? "inline*" : "",
    addAttributes() {
      return Ke(o.propSchema);
    },
    addKeyboardShortcuts() {
      return We(o);
    },
    parseHTML() {
      return Kt(
        o,
        e.parse
      );
    },
    renderHTML({ node: s }) {
      const r = this.options.editor, i = e.render.call(
        { renderType: "dom", props: void 0 },
        U(
          s,
          r.schema.inlineContentSchema,
          r.schema.styleSchema
        ),
        // TODO: fix cast
        () => {
        },
        r
      );
      return H(
        i,
        o.type,
        s.attrs,
        o.propSchema
      );
    },
    addNodeView() {
      return (s) => {
        const { node: r, getPos: i } = s, c = this.options.editor, a = e.render.call(
          { renderType: "nodeView", props: s },
          U(
            r,
            c.schema.inlineContentSchema,
            c.schema.styleSchema
          ),
          // TODO: fix cast
          (l) => {
            const d = O([l], c.pmSchema), u = i();
            u && c.transact(
              (p) => p.replaceWith(u, u + r.nodeSize, d)
            );
          },
          c
        );
        return H(
          a,
          o.type,
          r.attrs,
          o.propSchema
        );
      };
    }
  });
  return Je(
    t,
    o.propSchema,
    {
      ...e,
      toExternalHTML: e.toExternalHTML,
      render(s, r, i) {
        const c = e.render(
          s,
          r,
          i
        );
        return H(
          c,
          o.type,
          s.props,
          o.propSchema
        );
      }
    }
  );
}
function Jt(o, e, t, n = "before") {
  const s = typeof t == "string" ? t : t.id, r = C(o), i = e.map(
    (d) => q(d, r)
  ), c = x(s, o.doc);
  if (!c)
    throw new Error(`Block with ID ${s} not found`);
  let a = c.posBeforeNode;
  return n === "after" && (a += c.node.nodeSize), o.step(
    new Ve(a, a, new N(A.from(i), 0, 0))
  ), i.map(
    (d) => b(d, r)
  );
}
function j(o) {
  if (!o || o.type.name !== "column")
    throw new Error("Invalid columnPos: does not point to column node.");
  const e = o.firstChild;
  if (!e)
    throw new Error("Invalid column: does not have child node.");
  const t = e.firstChild;
  if (!t)
    throw new Error("Invalid blockContainer: does not have child node.");
  return o.childCount === 1 && e.childCount === 1 && t.type.name === "paragraph" && t.content.content.length === 0;
}
function qt(o, e) {
  const t = o.doc.resolve(e), n = t.nodeAfter;
  if (!n || n.type.name !== "columnList")
    throw new Error(
      "Invalid columnListPos: does not point to columnList node."
    );
  for (let s = n.childCount - 1; s >= 0; s--) {
    const r = o.doc.resolve(t.pos + 1).posAtIndex(s), c = o.doc.resolve(r).nodeAfter;
    if (!c || c.type.name !== "column")
      throw new Error("Invalid columnPos: does not point to column node.");
    j(c) && o.delete(r, r + c.nodeSize);
  }
}
function W(o, e) {
  qt(o, e);
  const n = o.doc.resolve(e).nodeAfter;
  if (!n || n.type.name !== "columnList")
    throw new Error(
      "Invalid columnListPos: does not point to columnList node."
    );
  if (n.childCount > 2)
    return;
  if (n.childCount < 2)
    throw new Error("Invalid columnList: contains fewer than two children.");
  const s = e + 1, i = o.doc.resolve(s).nodeAfter, c = e + n.nodeSize - 1, l = o.doc.resolve(c).nodeBefore;
  if (!i || !l)
    throw new Error("Invalid columnList: does not contain children.");
  const d = j(i), u = j(l);
  if (d && u) {
    o.delete(e, e + n.nodeSize);
    return;
  }
  if (d) {
    o.step(
      new V(
        // Replaces `columnList`.
        e,
        e + n.nodeSize,
        // Replaces with content of last `column`.
        c - l.nodeSize + 1,
        c - 1,
        // Doesn't append anything.
        N.empty,
        0,
        !1
      )
    );
    return;
  }
  if (u) {
    o.step(
      new V(
        // Replaces `columnList`.
        e,
        e + n.nodeSize,
        // Replaces with content of first `column`.
        s + 1,
        s + i.nodeSize - 1,
        // Doesn't append anything.
        N.empty,
        0,
        !1
      )
    );
    return;
  }
}
function ie(o, e, t) {
  const n = C(o), s = t.map(
    (u) => q(u, n)
  ), r = new Set(
    e.map(
      (u) => typeof u == "string" ? u : u.id
    )
  ), i = [], c = /* @__PURE__ */ new Set(), a = typeof e[0] == "string" ? e[0] : e[0].id;
  let l = 0;
  if (o.doc.descendants((u, p) => {
    if (r.size === 0)
      return !1;
    if (!u.type.isInGroup("bnBlock") || !r.has(u.attrs.id))
      return !0;
    if (i.push(b(u, n)), r.delete(u.attrs.id), t.length > 0 && u.attrs.id === a) {
      const g = o.doc.nodeSize;
      o.insert(p, s);
      const y = o.doc.nodeSize;
      l += g - y;
    }
    const m = o.doc.nodeSize, f = o.doc.resolve(p - l);
    f.node().type.name === "column" ? c.add(f.before(-1)) : f.node().type.name === "columnList" && c.add(f.before()), f.node().type.name === "blockGroup" && f.node(f.depth - 1).type.name !== "doc" && f.node().childCount === 1 ? o.delete(f.before(), f.after()) : o.delete(p - l, p - l + u.nodeSize);
    const k = o.doc.nodeSize;
    return l += m - k, !1;
  }), r.size > 0) {
    const u = [...r].join(`
`);
    throw Error(
      "Blocks with the following IDs could not be found in the editor: " + u
    );
  }
  return c.forEach((u) => W(o, u)), { insertedBlocks: s.map(
    (u) => b(u, n)
  ), removedBlocks: i };
}
function Yt(o, e, t, n, s) {
  let r;
  if (e)
    if (typeof e == "string")
      r = O([e], o.pmSchema, n);
    else if (Array.isArray(e))
      r = O(e, o.pmSchema, n);
    else if (e.type === "tableContent")
      r = Ue(e, o.pmSchema);
    else
      throw new F(e.type);
  else throw new Error("blockContent is required");
  const c = ((s == null ? void 0 : s.document) ?? document).createDocumentFragment();
  for (const a of r)
    if (a.type.name !== "text" && o.schema.inlineContentSchema[a.type.name]) {
      const l = o.schema.inlineContentSpecs[a.type.name].implementation;
      if (l) {
        const d = U(
          a,
          o.schema.inlineContentSchema,
          o.schema.styleSchema
        ), u = l.render.call(
          {
            renderType: "dom",
            props: void 0
          },
          d,
          () => {
          },
          o
        );
        if (u) {
          if (c.appendChild(u.dom), u.contentDOM) {
            const p = t.serializeFragment(
              a.content,
              s
            );
            u.contentDOM.dataset.editable = "", u.contentDOM.appendChild(p);
          }
          continue;
        }
      }
    } else if (a.type.name === "text") {
      let l = document.createTextNode(
        a.textContent
      );
      for (const d of a.marks.toReversed())
        if (d.type.name in o.schema.styleSpecs) {
          const u = o.schema.styleSpecs[d.type.name].implementation.render(d.attrs.stringValue, o);
          u.contentDOM.appendChild(l), l = u.dom;
        } else {
          const u = d.type.spec.toDOM(d, !0), p = he.renderSpec(document, u);
          p.contentDOM.appendChild(l), l = p.dom;
        }
      c.appendChild(l);
    } else {
      const l = t.serializeFragment(
        A.from([a]),
        s
      );
      c.appendChild(l);
    }
  return c;
}
function Qt(o, e, t, n) {
  var u, p, m, f, k;
  const s = o.pmSchema.nodes.blockContainer, r = e.props || {};
  for (const [g, y] of Object.entries(
    o.schema.blockSchema[e.type].propSchema
  ))
    !(g in r) && y.default !== void 0 && (r[g] = y.default);
  const i = e.children || [], a = o.blockImplementations[e.type].implementation.render.call(
    {
      renderType: "dom",
      props: void 0
    },
    { ...e, props: r, children: i },
    o
  );
  if (a.contentDOM && e.content) {
    const g = Yt(
      o,
      e.content,
      // TODO
      t,
      e.type,
      n
    );
    a.contentDOM.appendChild(g);
  }
  if (o.pmSchema.nodes[e.type].isInGroup("bnBlock")) {
    if (e.children && e.children.length > 0) {
      const g = Be(
        o,
        e.children,
        t,
        n
      );
      (u = a.contentDOM) == null || u.append(g);
    }
    return a.dom;
  }
  const d = (m = (p = s.spec) == null ? void 0 : p.toDOM) == null ? void 0 : m.call(
    p,
    s.create({
      id: e.id,
      ...r
    })
  );
  return (f = d.contentDOM) == null || f.appendChild(a.dom), e.children && e.children.length > 0 && ((k = d.contentDOM) == null || k.appendChild(
    Ce(o, e.children, t, n)
  )), d.dom;
}
function Be(o, e, t, n) {
  const r = ((n == null ? void 0 : n.document) ?? document).createDocumentFragment();
  for (const i of e) {
    const c = Qt(o, i, t, n);
    r.appendChild(c);
  }
  return r;
}
const Ce = (o, e, t, n) => {
  var c;
  const s = o.pmSchema.nodes.blockGroup, r = s.spec.toDOM(s.create({})), i = Be(o, e, t, n);
  return (c = r.contentDOM) == null || c.appendChild(i), r.dom;
}, Xt = (o, e) => {
  const t = he.fromSchema(o);
  return {
    serializeBlocks: (n, s) => Ce(e, n, t, s).outerHTML
  };
};
function Zt(o) {
  return o.transact((e) => {
    const t = _(e.doc, e.selection.anchor);
    if (e.selection instanceof te)
      return {
        type: "cell",
        anchorBlockId: t.node.attrs.id,
        anchorCellOffset: e.selection.$anchorCell.pos - t.posBeforeNode,
        headCellOffset: e.selection.$headCell.pos - t.posBeforeNode
      };
    if (e.selection instanceof L)
      return {
        type: "node",
        anchorBlockId: t.node.attrs.id
      };
    {
      const n = _(e.doc, e.selection.head);
      return {
        type: "text",
        anchorBlockId: t.node.attrs.id,
        headBlockId: n.node.attrs.id,
        anchorOffset: e.selection.anchor - t.posBeforeNode,
        headOffset: e.selection.head - n.posBeforeNode
      };
    }
  });
}
function eo(o, e) {
  var s, r;
  const t = (s = x(e.anchorBlockId, o.doc)) == null ? void 0 : s.posBeforeNode;
  if (t === void 0)
    throw new Error(
      `Could not find block with ID ${e.anchorBlockId} to update selection`
    );
  let n;
  if (e.type === "cell")
    n = te.create(
      o.doc,
      t + e.anchorCellOffset,
      t + e.headCellOffset
    );
  else if (e.type === "node")
    n = L.create(o.doc, t + 1);
  else {
    const i = (r = x(e.headBlockId, o.doc)) == null ? void 0 : r.posBeforeNode;
    if (i === void 0)
      throw new Error(
        `Could not find block with ID ${e.headBlockId} to update selection`
      );
    n = M.create(
      o.doc,
      t + e.anchorOffset,
      i + e.headOffset
    );
  }
  o.setSelection(n);
}
function K(o) {
  return o.map((e) => e.type === "columnList" ? e.children.map((t) => K(t.children)).flat() : {
    ...e,
    children: K(e.children)
  }).flat();
}
function xe(o, e, t) {
  o.transact((n) => {
    var i;
    const s = ((i = o.getSelection()) == null ? void 0 : i.blocks) || [
      o.getTextCursorPosition().block
    ], r = Zt(o);
    o.removeBlocks(s), o.insertBlocks(K(s), e, t), eo(n, r);
  });
}
function Ee(o) {
  return !o || o.type !== "columnList";
}
function Me(o, e, t) {
  let n, s;
  if (e ? e.children.length > 0 ? (n = e.children[e.children.length - 1], s = "after") : (n = e, s = "before") : t && (n = t, s = "before"), !n || !s)
    return;
  const r = o.getParentBlock(n);
  return Ee(r) ? { referenceBlock: n, placement: s } : Me(
    o,
    s === "after" ? n : o.getPrevBlock(n),
    r
  );
}
function we(o, e, t) {
  let n, s;
  if (e ? e.children.length > 0 ? (n = e.children[0], s = "before") : (n = e, s = "after") : t && (n = t, s = "after"), !n || !s)
    return;
  const r = o.getParentBlock(n);
  return Ee(r) ? { referenceBlock: n, placement: s } : we(
    o,
    s === "before" ? n : o.getNextBlock(n),
    r
  );
}
function to(o) {
  o.transact(() => {
    const e = o.getSelection(), t = (e == null ? void 0 : e.blocks[0]) || o.getTextCursorPosition().block, n = Me(
      o,
      o.getPrevBlock(t),
      o.getParentBlock(t)
    );
    n && xe(
      o,
      n.referenceBlock,
      n.placement
    );
  });
}
function oo(o) {
  o.transact(() => {
    const e = o.getSelection(), t = (e == null ? void 0 : e.blocks[(e == null ? void 0 : e.blocks.length) - 1]) || o.getTextCursorPosition().block, n = we(
      o,
      o.getNextBlock(t),
      o.getParentBlock(t)
    );
    n && xe(
      o,
      n.referenceBlock,
      n.placement
    );
  });
}
function no(o, e, t) {
  const { $from: n, $to: s } = o.selection, r = n.blockRange(
    s,
    (f) => f.childCount > 0 && (f.type.name === "blockGroup" || f.type.name === "column")
    // change necessary to not look at first item child type
  );
  if (!r)
    return !1;
  const i = r.startIndex;
  if (i === 0)
    return !1;
  const a = r.parent.child(i - 1);
  if (a.type !== e)
    return !1;
  const l = a.lastChild && a.lastChild.type === t, d = A.from(l ? e.create() : null), u = new N(
    A.from(
      e.create(null, A.from(t.create(null, d)))
      // change necessary to create "groupType" instead of parent.type
    ),
    l ? 3 : 1,
    0
  ), p = r.start, m = r.end;
  return o.step(
    new V(
      p - (l ? 3 : 1),
      m,
      p,
      m,
      u,
      1,
      !0
    )
  ).scrollIntoView(), !0;
}
function Te(o) {
  return o.transact((e) => no(
    e,
    o.pmSchema.nodes.blockContainer,
    o.pmSchema.nodes.blockGroup
  ));
}
function so(o) {
  o._tiptapEditor.commands.liftListItem("blockContainer");
}
function ro(o) {
  return o.transact((e) => {
    const { bnBlock: t } = $(e);
    return e.doc.resolve(t.beforePos).nodeBefore !== null;
  });
}
function io(o) {
  return o.transact((e) => {
    const { bnBlock: t } = $(e);
    return e.doc.resolve(t.beforePos).depth > 1;
  });
}
function ao(o, e) {
  const t = typeof e == "string" ? e : e.id, n = C(o), s = x(t, o);
  if (s)
    return b(s.node, n);
}
function co(o, e) {
  const t = typeof e == "string" ? e : e.id, n = x(t, o), s = C(o);
  if (!n)
    return;
  const i = o.resolve(n.posBeforeNode).nodeBefore;
  if (i)
    return b(i, s);
}
function lo(o, e) {
  const t = typeof e == "string" ? e : e.id, n = x(t, o), s = C(o);
  if (!n)
    return;
  const i = o.resolve(
    n.posBeforeNode + n.node.nodeSize
  ).nodeAfter;
  if (i)
    return b(i, s);
}
function uo(o, e) {
  const t = typeof e == "string" ? e : e.id, n = C(o), s = x(t, o);
  if (!s)
    return;
  const r = o.resolve(s.posBeforeNode), i = r.node(), c = r.node(-1), a = c.type.name !== "doc" ? i.type.name === "blockGroup" ? c : i : void 0;
  if (a)
    return b(a, n);
}
class po {
  constructor(e) {
    this.editor = e;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    return this.editor.transact((e) => ze(e.doc, this.editor.pmSchema));
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be
   * retrieved.
   * @returns The block that matches the identifier, or `undefined` if no
   * matching block was found.
   */
  getBlock(e) {
    return this.editor.transact((t) => ao(t.doc, e));
  }
  /**
   * Gets a snapshot of the previous sibling of an existing block from the
   * editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * previous sibling should be retrieved.
   * @returns The previous sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the first child/block
   * in the document.
   */
  getPrevBlock(e) {
    return this.editor.transact((t) => co(t.doc, e));
  }
  /**
   * Gets a snapshot of the next sibling of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * next sibling should be retrieved.
   * @returns The next sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the last child/block in
   * the document.
   */
  getNextBlock(e) {
    return this.editor.transact((t) => lo(t.doc, e));
  }
  /**
   * Gets a snapshot of the parent of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * parent should be retrieved.
   * @returns The parent of the block that matches the identifier. `undefined`
   * if no matching block was found, or the block isn't nested.
   */
  getParentBlock(e) {
    return this.editor.transact(
      (t) => uo(t.doc, e)
    );
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(e, t = !1) {
    const n = this.document.slice();
    t && n.reverse();
    function s(r) {
      for (const i of r) {
        if (e(i) === !1)
          return !1;
        const c = t ? i.children.slice().reverse() : i.children;
        if (!s(c))
          return !1;
      }
      return !0;
    }
    s(n);
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`.
   */
  insertBlocks(e, t, n = "before") {
    return this.editor.transact(
      (s) => Jt(s, e, t, n)
    );
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(e, t) {
    return this.editor.transact((n) => qe(n, e, t));
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(e) {
    return this.editor.transact(
      (t) => ie(t, e, []).removedBlocks
    );
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(e, t) {
    return this.editor.transact(
      (n) => ie(n, e, t)
    );
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    return ro(this.editor);
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    Te(this.editor);
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    return io(this.editor);
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    so(this.editor);
  }
  /**
   * Moves the selected blocks up. If the previous block has children, moves
   * them to the end of its children. If there is no previous block, but the
   * current blocks share a common parent, moves them out of & before it.
   */
  moveBlocksUp() {
    return to(this.editor);
  }
  /**
   * Moves the selected blocks down. If the next block has children, moves
   * them to the start of its children. If there is no next block, but the
   * current blocks share a common parent, moves them out of & after it.
   */
  moveBlocksDown() {
    return oo(this.editor);
  }
}
class fo extends Se {
  constructor(e) {
    super(), this.editor = e, e.on("create", () => {
      e._tiptapEditor.on(
        "update",
        ({ transaction: t, appendedTransactions: n }) => {
          this.emit("onChange", { editor: e, transaction: t, appendedTransactions: n });
        }
      ), e._tiptapEditor.on("selectionUpdate", ({ transaction: t }) => {
        this.emit("onSelectionChange", { editor: e, transaction: t });
      }), e._tiptapEditor.on("mount", () => {
        this.emit("onMount", { editor: e });
      }), e._tiptapEditor.on("unmount", () => {
        this.emit("onUnmount", { editor: e });
      });
    });
  }
  /**
   * Register a callback that will be called when the editor changes.
   */
  onChange(e, t = !0) {
    const n = ({
      transaction: s,
      appendedTransactions: r
    }) => {
      !t && ae(s) || e(this.editor, {
        getChanges() {
          return ot(
            s,
            r
          );
        }
      });
    };
    return this.on("onChange", n), () => {
      this.off("onChange", n);
    };
  }
  /**
   * Register a callback that will be called when the selection changes.
   */
  onSelectionChange(e, t = !1) {
    const n = (s) => {
      !t && ae(s.transaction) || e(this.editor);
    };
    return this.on("onSelectionChange", n), () => {
      this.off("onSelectionChange", n);
    };
  }
  /**
   * Register a callback that will be called when the editor is mounted.
   */
  onMount(e) {
    return this.on("onMount", e), () => {
      this.off("onMount", e);
    };
  }
  /**
   * Register a callback that will be called when the editor is unmounted.
   */
  onUnmount(e) {
    return this.on("onUnmount", e), () => {
      this.off("onUnmount", e);
    };
  }
}
function ae(o) {
  return !!o.getMeta("y-sync$");
}
function ho(o) {
  return Array.prototype.indexOf.call(o.parentElement.childNodes, o);
}
function mo(o) {
  return o.nodeType === 3 && !/\S/.test(o.nodeValue || "");
}
function ko(o) {
  o.querySelectorAll("li > ul, li > ol").forEach((e) => {
    const t = ho(e), n = e.parentElement, s = Array.from(n.childNodes).slice(
      t + 1
    );
    e.remove(), s.forEach((r) => {
      r.remove();
    }), n.insertAdjacentElement("afterend", e), s.reverse().forEach((r) => {
      if (mo(r))
        return;
      const i = document.createElement("li");
      i.append(r), e.insertAdjacentElement("afterend", i);
    }), n.childNodes.length === 0 && n.remove();
  });
}
function go(o) {
  o.querySelectorAll("li + ul, li + ol").forEach((e) => {
    var r, i;
    const t = e.previousElementSibling, n = document.createElement("div");
    t.insertAdjacentElement("afterend", n), n.append(t);
    const s = document.createElement("div");
    for (s.setAttribute("data-node-type", "blockGroup"), n.append(s); ((r = n.nextElementSibling) == null ? void 0 : r.nodeName) === "UL" || ((i = n.nextElementSibling) == null ? void 0 : i.nodeName) === "OL"; )
      s.append(n.nextElementSibling);
  });
}
let ce = null;
function bo() {
  return ce || (ce = document.implementation.createHTMLDocument("title"));
}
function yo(o) {
  if (typeof o == "string") {
    const e = bo().createElement("div");
    e.innerHTML = o, o = e;
  }
  return ko(o), go(o), o;
}
function Pe(o, e) {
  const t = yo(o), s = $e.fromSchema(e).parse(t, {
    topNode: e.nodes.blockGroup.create()
  }), r = [];
  for (let i = 0; i < s.childCount; i++)
    r.push(b(s.child(i), e));
  return r;
}
function So(o, e) {
  const t = e.value ? e.value : "", n = {};
  e.lang && (n["data-language"] = e.lang);
  let s = {
    type: "element",
    tagName: "code",
    properties: n,
    children: [{ type: "text", value: t }]
  };
  return e.meta && (s.data = { meta: e.meta }), o.patch(e, s), s = o.applyData(e, s), s = {
    type: "element",
    tagName: "pre",
    properties: {},
    children: [s]
  }, o.patch(e, s), s;
}
function Bo(o, e) {
  var r;
  const t = String((e == null ? void 0 : e.url) || ""), n = e != null && e.title ? String(e.title) : void 0;
  let s = {
    type: "element",
    tagName: "video",
    properties: {
      src: t,
      "data-name": n,
      "data-url": t,
      controls: !0
    },
    children: []
  };
  return (r = o.patch) == null || r.call(o, e, s), s = o.applyData ? o.applyData(e, s) : s, s;
}
function ve(o) {
  return jt().use(zt).use(Ut).use(Gt, {
    handlers: {
      ...re,
      image: (t, n) => {
        const s = String((n == null ? void 0 : n.url) || "");
        return Ye(s) ? Bo(t, n) : re.image(t, n);
      },
      code: So,
      blockquote: (t, n) => {
        const s = {
          type: "element",
          tagName: "blockquote",
          properties: {},
          // The only difference from the original is that we don't wrap the children with line endings
          children: t.wrap(t.all(n), !1)
        };
        return t.patch(n, s), t.applyData(n, s);
      }
    }
  }).use(Rt).processSync(o).value;
}
function Co(o, e) {
  const t = ve(o);
  return Pe(t, e);
}
class xo {
  constructor(e) {
    this.editor = e;
  }
  /**
   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToHTMLLossy(e = this.editor.document) {
    return be(
      this.editor.pmSchema,
      this.editor
    ).exportBlocks(e, {});
  }
  /**
   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
   *
   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToFullHTML(e = this.editor.document) {
    return Xt(
      this.editor.pmSchema,
      this.editor
    ).serializeBlocks(e, {});
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  tryParseHTMLToBlocks(e) {
    return Pe(e, this.editor.pmSchema);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  blocksToMarkdownLossy(e = this.editor.document) {
    return nt(e, this.editor.pmSchema, this.editor, {});
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  tryParseMarkdownToBlocks(e) {
    return Co(e, this.editor.pmSchema);
  }
  /**
   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
   * @param html The HTML to paste.
   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
   */
  pasteHTML(e, t = !1) {
    var s;
    let n = e;
    if (!t) {
      const r = this.tryParseHTMLToBlocks(e);
      n = this.blocksToFullHTML(r);
    }
    n && ((s = this.editor.prosemirrorView) == null || s.pasteHTML(n));
  }
  /**
   * Paste text into the editor. Defaults to interpreting text as markdown.
   * @param text The text to paste.
   */
  pasteText(e) {
    var t;
    return (t = this.editor.prosemirrorView) == null ? void 0 : t.pasteText(e);
  }
  /**
   * Paste markdown into the editor.
   * @param markdown The markdown to paste.
   */
  pasteMarkdown(e) {
    const t = ve(e);
    return this.pasteHTML(t);
  }
}
const oe = [
  "vscode-editor-data",
  "blocknote/html",
  "text/markdown",
  "text/html",
  "text/plain",
  "Files"
];
function Eo(o, e) {
  if (!o.startsWith(".") || !e.startsWith("."))
    throw new Error("The strings provided are not valid file extensions.");
  return o === e;
}
function Mo(o, e) {
  const t = o.split("/"), n = e.split("/");
  if (t.length !== 2)
    throw new Error(`The string ${o} is not a valid MIME type.`);
  if (n.length !== 2)
    throw new Error(`The string ${e} is not a valid MIME type.`);
  return t[1] === "*" || n[1] === "*" ? t[0] === n[0] : (t[0] === "*" || n[0] === "*" || t[0] === n[0]) && t[1] === n[1];
}
function le(o, e, t, n = "after") {
  let s;
  return Array.isArray(e.content) && e.content.length === 0 ? s = o.updateBlock(e, t).id : s = o.insertBlocks(
    [t],
    e,
    n
  )[0].id, s;
}
async function Ie(o, e) {
  var r;
  if (!e.uploadFile) {
    console.warn(
      "Attempted ot insert file, but uploadFile is not set in the BlockNote editor options"
    );
    return;
  }
  const t = "dataTransfer" in o ? o.dataTransfer : o.clipboardData;
  if (t === null)
    return;
  let n = null;
  for (const i of oe)
    if (t.types.includes(i)) {
      n = i;
      break;
    }
  if (n !== "Files")
    return;
  const s = t.items;
  if (s) {
    o.preventDefault();
    for (let i = 0; i < s.length; i++) {
      let c = "file";
      for (const l of Object.values(e.schema.blockSpecs))
        for (const d of ((r = l.implementation.meta) == null ? void 0 : r.fileBlockAccept) || []) {
          const u = d.startsWith("."), p = s[i].getAsFile();
          if (p && (!u && p.type && Mo(s[i].type, d) || u && Eo(
            "." + p.name.split(".").pop(),
            d
          ))) {
            c = l.config.type;
            break;
          }
        }
      const a = s[i].getAsFile();
      if (a) {
        const l = {
          type: c,
          props: {
            name: a.name
          }
        };
        let d;
        if (o.type === "paste") {
          const m = e.getTextCursorPosition().block;
          d = le(e, m, l);
        } else if (o.type === "drop") {
          const m = {
            left: o.clientX,
            top: o.clientY
          }, f = e.prosemirrorView.posAtCoords(m);
          if (!f)
            return;
          d = e.transact((k) => {
            var S;
            const g = _(k.doc, f.pos), y = (S = e.domElement) == null ? void 0 : S.querySelector(
              `[data-id="${g.node.attrs.id}"]`
            ), T = y == null ? void 0 : y.getBoundingClientRect();
            return le(
              e,
              e.getBlock(g.node.attrs.id),
              l,
              T && (T.top + T.bottom) / 2 > m.top ? "before" : "after"
            );
          });
        } else
          return;
        const u = await e.uploadFile(a, d), p = typeof u == "string" ? {
          props: {
            url: u
          }
        } : { ...u };
        e.updateBlock(d, p);
      }
    }
  }
}
const wo = (o) => E.create({
  name: "dropFile",
  addProseMirrorPlugins() {
    return [
      new ee({
        props: {
          handleDOMEvents: {
            drop(e, t) {
              if (!o.isEditable)
                return;
              let n = null;
              for (const s of oe)
                if (t.dataTransfer.types.includes(s)) {
                  n = s;
                  break;
                }
              return n === null ? !0 : n === "Files" ? (Ie(t, o), !0) : !1;
            }
          }
        }
      })
    ];
  }
}), To = /(^|\n) {0,3}#{1,6} {1,8}[^\n]{1,64}\r?\n\r?\n\s{0,32}\S/, Po = /(_|__|\*|\*\*|~~|==|\+\+)(?!\s)(?:[^\s](?:.{0,62}[^\s])?|\S)(?=\1)/, vo = /\[[^\]]{1,128}\]\(https?:\/\/\S{1,999}\)/, Io = /(?:\s|^)`(?!\s)(?:[^\s`](?:[^`]{0,46}[^\s`])?|[^\s`])`([^\w]|$)/, Ao = /(?:^|\n)\s{0,5}-\s{1}[^\n]+\n\s{0,15}-\s/, _o = /(?:^|\n)\s{0,5}\d+\.\s{1}[^\n]+\n\s{0,15}\d+\.\s/, Do = /\n{2} {0,3}-{2,48}\n{2}/, Lo = /(?:\n|^)(```|~~~|\$\$)(?!`|~)[^\s]{0,64} {0,64}[^\n]{0,64}\n[\s\S]{0,9999}?\s*\1 {0,64}(?:\n+|$)/, No = /(?:\n|^)(?!\s)\w[^\n]{0,64}\r?\n(-|=)\1{0,64}\n\n\s{0,64}(\w|$)/, Oo = /(?:^|(\r?\n\r?\n))( {0,3}>[^\n]{1,333}\n){1,999}($|(\r?\n))/, Fo = /^\s*\|(.+\|)+\s*$/m, $o = /^\s*\|(\s*[-:]+[-:]\s*\|)+\s*$/m, Ho = /^\s*\|(.+\|)+\s*$/m, Vo = (o) => To.test(o) || Po.test(o) || vo.test(o) || Io.test(o) || Ao.test(o) || _o.test(o) || Do.test(o) || Lo.test(o) || No.test(o) || Oo.test(o) || Fo.test(o) || $o.test(o) || Ho.test(o);
async function Uo(o, e) {
  const { schema: t } = e.state;
  if (!o.clipboardData)
    return !1;
  const n = o.clipboardData.getData("text/plain");
  if (!n)
    return !1;
  if (!t.nodes.codeBlock)
    return e.pasteText(n), !0;
  const s = o.clipboardData.getData("vscode-editor-data"), r = s ? JSON.parse(s) : void 0, i = r == null ? void 0 : r.mode;
  return i ? (e.pasteHTML(
    `<pre><code class="language-${i}">${n.replace(
      /\r\n?/g,
      `
`
    )}</code></pre>`
  ), !0) : !1;
}
function zo({
  event: o,
  editor: e,
  prioritizeMarkdownOverHTML: t,
  plainTextAsMarkdown: n
}) {
  var c;
  if (e.transact(
    (a) => a.selection.$from.parent.type.spec.code && a.selection.$to.parent.type.spec.code
  )) {
    const a = (c = o.clipboardData) == null ? void 0 : c.getData("text/plain");
    if (a)
      return e.pasteText(a), !0;
  }
  let r;
  for (const a of oe)
    if (o.clipboardData.types.includes(a)) {
      r = a;
      break;
    }
  if (!r)
    return !0;
  if (r === "vscode-editor-data")
    return Uo(o, e.prosemirrorView), !0;
  if (r === "Files")
    return Ie(o, e), !0;
  const i = o.clipboardData.getData(r);
  if (r === "blocknote/html")
    return e.pasteHTML(i, !0), !0;
  if (r === "text/markdown")
    return e.pasteMarkdown(i), !0;
  if (t) {
    const a = o.clipboardData.getData("text/plain");
    if (Vo(a))
      return e.pasteMarkdown(a), !0;
  }
  return r === "text/html" ? (e.pasteHTML(i), !0) : n ? (e.pasteMarkdown(i), !0) : (e.pasteText(i), !0);
}
const Go = (o, e) => E.create({
  name: "pasteFromClipboard",
  addProseMirrorPlugins() {
    return [
      new ee({
        props: {
          handleDOMEvents: {
            paste(t, n) {
              if (n.preventDefault(), !!o.isEditable)
                return e({
                  event: n,
                  editor: o,
                  defaultPasteHandler: ({
                    prioritizeMarkdownOverHTML: s = !0,
                    plainTextAsMarkdown: r = !0
                  } = {}) => zo({
                    event: n,
                    editor: o,
                    prioritizeMarkdownOverHTML: s,
                    plainTextAsMarkdown: r
                  })
                });
            }
          }
        }
      })
    ];
  }
});
function Ro(o, e, t) {
  var c;
  let n = !1;
  const s = o.state.selection instanceof te;
  if (!s) {
    const a = o.state.doc.slice(
      o.state.selection.from,
      o.state.selection.to,
      !1
    ).content, l = [];
    for (let d = 0; d < a.childCount; d++)
      l.push(a.child(d));
    n = l.find(
      (d) => d.type.isInGroup("bnBlock") || d.type.name === "blockGroup" || d.type.spec.group === "blockContent"
    ) === void 0, n && (e = a);
  }
  let r;
  const i = be(
    o.state.schema,
    t
  );
  if (s) {
    ((c = e.firstChild) == null ? void 0 : c.type.name) === "table" && (e = e.firstChild.content);
    const a = Ge(
      e,
      t.schema.inlineContentSchema,
      t.schema.styleSchema
    );
    r = `<table>${i.exportInlineContent(
      a,
      {}
    )}</table>`;
  } else if (n) {
    const a = Re(
      e,
      t.schema.inlineContentSchema,
      t.schema.styleSchema
    );
    r = i.exportInlineContent(a, {});
  } else {
    const a = rt(e);
    r = i.exportBlocks(a, {});
  }
  return r;
}
function Ae(o, e) {
  "node" in o.state.selection && o.state.selection.node.type.spec.group === "blockContent" && e.transact(
    (i) => i.setSelection(
      new L(i.doc.resolve(o.state.selection.from - 1))
    )
  );
  const t = o.serializeForClipboard(
    o.state.selection.content()
  ).dom.innerHTML, n = o.state.selection.content().content, s = Ro(
    o,
    n,
    e
  ), r = st(s);
  return { clipboardHTML: t, externalHTML: s, markdown: r };
}
const de = () => {
  const o = window.getSelection();
  if (!o || o.isCollapsed)
    return !0;
  let e = o.focusNode;
  for (; e; ) {
    if (e instanceof HTMLElement && e.getAttribute("contenteditable") === "false")
      return !0;
    e = e.parentElement;
  }
  return !1;
}, ue = (o, e, t) => {
  t.preventDefault(), t.clipboardData.clearData();
  const { clipboardHTML: n, externalHTML: s, markdown: r } = Ae(
    e,
    o
  );
  t.clipboardData.setData("blocknote/html", n), t.clipboardData.setData("text/html", s), t.clipboardData.setData("text/plain", r);
}, jo = (o) => E.create({
  name: "copyToClipboard",
  addProseMirrorPlugins() {
    return [
      new ee({
        props: {
          handleDOMEvents: {
            copy(e, t) {
              return de() || ue(o, e, t), !0;
            },
            cut(e, t) {
              return de() || (ue(o, e, t), e.editable && e.dispatch(e.state.tr.deleteSelection())), !0;
            },
            // This is for the use-case in which only a block without content
            // is selected, e.g. an image block, and dragged (not using the
            // drag handle).
            dragstart(e, t) {
              if (!("node" in e.state.selection) || e.state.selection.node.type.spec.group !== "blockContent")
                return;
              o.transact(
                (i) => i.setSelection(
                  new L(
                    i.doc.resolve(e.state.selection.from - 1)
                  )
                )
              ), t.preventDefault(), t.dataTransfer.clearData();
              const { clipboardHTML: n, externalHTML: s, markdown: r } = Ae(e, o);
              return t.dataTransfer.setData("blocknote/html", n), t.dataTransfer.setData("text/html", s), t.dataTransfer.setData("text/plain", r), !0;
            }
          }
        }
      })
    ];
  }
}), Wo = E.create({
  name: "blockBackgroundColor",
  addGlobalAttributes() {
    return [
      {
        types: ["tableCell", "tableHeader"],
        attributes: {
          backgroundColor: Qe()
        }
      }
    ];
  }
}), Ko = D.create({
  name: "hardBreak",
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  priority: 10,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: o }) {
    return ["br", Et(this.options.HTMLAttributes, o)];
  },
  renderText() {
    return `
`;
  }
}), J = (o, e) => {
  const t = o.resolve(e), n = t.index();
  if (n === 0)
    return;
  const s = t.posAtIndex(n - 1);
  return Y(
    o.resolve(s)
  );
}, _e = (o, e) => {
  for (; e.childContainer; ) {
    const t = e.childContainer.node, n = o.resolve(e.childContainer.beforePos + 1).posAtIndex(t.childCount - 1);
    e = Y(o.resolve(n));
  }
  return e;
}, Jo = (o, e) => o.isBlockContainer && o.blockContent.node.type.spec.content === "inline*" && o.blockContent.node.childCount > 0 && e.isBlockContainer && e.blockContent.node.type.spec.content === "inline*", qo = (o, e, t, n) => {
  if (!n.isBlockContainer)
    throw new Error(
      `Attempted to merge block at position ${n.bnBlock.beforePos} into previous block at position ${t.bnBlock.beforePos}, but next block is not a block container`
    );
  if (n.childContainer) {
    const s = o.doc.resolve(
      n.childContainer.beforePos + 1
    ), r = o.doc.resolve(
      n.childContainer.afterPos - 1
    ), i = s.blockRange(r);
    if (e) {
      const c = o.doc.resolve(n.bnBlock.beforePos);
      o.tr.lift(i, c.depth);
    }
  }
  if (e) {
    if (!t.isBlockContainer)
      throw new Error(
        `Attempted to merge block at position ${n.bnBlock.beforePos} into previous block at position ${t.bnBlock.beforePos}, but previous block is not a block container`
      );
    e(
      o.tr.delete(
        t.blockContent.afterPos - 1,
        n.blockContent.beforePos + 1
      )
    );
  }
  return !0;
}, pe = (o) => ({
  state: e,
  dispatch: t
}) => {
  const n = e.doc.resolve(o), s = Y(n), r = J(
    e.doc,
    s.bnBlock.beforePos
  );
  if (!r)
    return !1;
  const i = _e(
    e.doc,
    r
  );
  return Jo(i, s) ? qo(e, t, i, s) : !1;
}, Yo = E.create({
  priority: 50,
  // TODO: The shortcuts need a refactor. Do we want to use a command priority
  //  design as there is now, or clump the logic into a single function?
  addKeyboardShortcuts() {
    const o = () => this.editor.commands.first(({ chain: n, commands: s }) => [
      // Deletes the selection if it's not empty.
      () => s.deleteSelection(),
      // Undoes an input rule if one was triggered in the last editor state change.
      () => s.undoInputRule(),
      // Reverts block content type to a paragraph if the selection is at the start of the block.
      () => s.command(({ state: r }) => {
        const i = B(r);
        if (!i.isBlockContainer)
          return !1;
        const c = r.selection.from === i.blockContent.beforePos + 1, a = i.blockContent.node.type.name === "paragraph";
        return c && !a ? s.command(
          Ze(i.bnBlock.beforePos, {
            type: "paragraph",
            props: {}
          })
        ) : !1;
      }),
      // Removes a level of nesting if the block is indented if the selection is at the start of the block.
      () => s.command(({ state: r }) => {
        const i = B(r);
        if (!i.isBlockContainer)
          return !1;
        const { blockContent: c } = i;
        return r.selection.from === c.beforePos + 1 ? s.liftListItem("blockContainer") : !1;
      }),
      // Merges block with the previous one if it isn't indented, and the selection is at the start of the
      // block. The target block for merging must contain inline content.
      () => s.command(({ state: r }) => {
        const i = B(r);
        if (!i.isBlockContainer)
          return !1;
        const { bnBlock: c, blockContent: a } = i, l = r.selection.from === a.beforePos + 1, d = r.selection.empty, u = c.beforePos;
        return l && d ? n().command(pe(u)).scrollIntoView().run() : !1;
      }),
      () => s.command(({ state: r, tr: i, dispatch: c }) => {
        const a = B(r);
        if (!a.isBlockContainer || !(i.selection.from === a.blockContent.beforePos + 1))
          return !1;
        const d = i.doc.resolve(a.bnBlock.beforePos);
        if (d.nodeBefore || d.node().type.name !== "column")
          return !1;
        const m = i.doc.resolve(a.bnBlock.beforePos), f = i.doc.resolve(m.before()), k = f.before();
        if (c) {
          const g = i.doc.slice(
            a.bnBlock.beforePos,
            a.bnBlock.afterPos
          ).content;
          i.delete(
            a.bnBlock.beforePos,
            a.bnBlock.afterPos
          ), f.index() === 0 ? (W(i, k), i.insert(k, g), i.setSelection(
            M.near(i.doc.resolve(k))
          )) : (i.insert(f.pos - 1, g), i.setSelection(
            M.near(i.doc.resolve(f.pos - 1))
          ), W(i, k));
        }
        return !0;
      }),
      // Deletes the current block if it's an empty block with inline content,
      // and moves the selection to the previous block.
      () => s.command(({ state: r }) => {
        const i = B(r);
        if (!i.isBlockContainer)
          return !1;
        if (i.blockContent.node.childCount === 0 && i.blockContent.node.type.spec.content === "inline*") {
          const a = J(
            r.doc,
            i.bnBlock.beforePos
          );
          if (!a || !a.isBlockContainer)
            return !1;
          let l = n();
          if (a.blockContent.node.type.spec.content === "tableRow+") {
            const f = i.bnBlock.beforePos - 1 - 1 - 1 - 1 - 1;
            l = l.setTextSelection(
              f
            );
          } else if (a.blockContent.node.type.spec.content === "") {
            const d = a.blockContent.afterPos - a.blockContent.node.nodeSize;
            l = l.setNodeSelection(
              d
            );
          } else {
            const d = a.blockContent.afterPos - a.blockContent.node.nodeSize;
            l = l.setTextSelection(d);
          }
          return l.deleteRange({
            from: i.bnBlock.beforePos,
            to: i.bnBlock.afterPos
          }).scrollIntoView().run();
        }
        return !1;
      }),
      // Deletes previous block if it contains no content and isn't a table,
      // when the selection is empty and at the start of the block. Moves the
      // current block into the deleted block's place.
      () => s.command(({ state: r }) => {
        const i = B(r);
        if (!i.isBlockContainer)
          throw new Error("todo");
        const c = r.selection.from === i.blockContent.beforePos + 1, a = r.selection.empty, l = J(
          r.doc,
          i.bnBlock.beforePos
        );
        if (l && c && a) {
          const d = _e(
            r.doc,
            l
          );
          if (!d.isBlockContainer)
            throw new Error("todo");
          if (d.blockContent.node.type.spec.content === "" || d.blockContent.node.type.spec.content === "inline*" && d.blockContent.node.childCount === 0)
            return n().cut(
              {
                from: i.bnBlock.beforePos,
                to: i.bnBlock.afterPos
              },
              d.bnBlock.afterPos
            ).deleteRange({
              from: d.bnBlock.beforePos,
              to: d.bnBlock.afterPos
            }).run();
        }
        return !1;
      })
    ]), e = () => this.editor.commands.first(({ commands: n }) => [
      // Deletes the selection if it's not empty.
      () => n.deleteSelection(),
      // Merges block with the next one (at the same nesting level or lower),
      // if one exists, the block has no children, and the selection is at the
      // end of the block.
      () => n.command(({ state: s }) => {
        const r = B(s);
        if (!r.isBlockContainer)
          return !1;
        const {
          bnBlock: i,
          blockContent: c,
          childContainer: a
        } = r, { depth: l } = s.doc.resolve(i.beforePos), d = i.afterPos === s.doc.nodeSize - 3, u = s.selection.from === c.afterPos - 1, p = s.selection.empty;
        if (!d && u && p && !(a !== void 0)) {
          let f = l, k = i.afterPos + 1, g = s.doc.resolve(k).depth;
          for (; g < f; )
            f = g, k += 2, g = s.doc.resolve(k).depth;
          return n.command(pe(k - 1));
        }
        return !1;
      })
    ]), t = (n = !1) => this.editor.commands.first(({ commands: s, tr: r }) => [
      // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
      // of the block.
      () => s.command(({ state: i }) => {
        const c = B(i);
        if (!c.isBlockContainer)
          return !1;
        const { bnBlock: a, blockContent: l } = c, { depth: d } = i.doc.resolve(a.beforePos), u = i.selection.$anchor.parentOffset === 0, p = i.selection.anchor === i.selection.head, m = l.node.childCount === 0, f = d > 1;
        return u && p && m && f ? s.liftListItem("blockContainer") : !1;
      }),
      // Creates a hard break if block is configured to do so.
      () => s.command(({ state: i }) => {
        var l;
        const c = B(i), a = ((l = this.options.editor.schema.blockSchema[c.blockNoteType].meta) == null ? void 0 : l.hardBreakShortcut) ?? "shift+enter";
        if (a === "none")
          return !1;
        if (
          // If shortcut is not configured, or is configured as "shift+enter",
          // create a hard break for shift+enter, but not for enter.
          a === "shift+enter" && n || // If shortcut is configured as "enter", create a hard break for
          // both enter and shift+enter.
          a === "enter"
        ) {
          const d = r.storedMarks || r.selection.$head.marks().filter(
            (u) => this.editor.extensionManager.splittableMarks.includes(
              u.type.name
            )
          );
          return r.insert(
            r.selection.head,
            r.doc.type.schema.nodes.hardBreak.create()
          ).ensureMarks(d), !0;
        }
        return !1;
      }),
      // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
      // empty & at the start of the block.
      () => s.command(({ state: i, dispatch: c }) => {
        const a = B(i);
        if (!a.isBlockContainer)
          return !1;
        const { bnBlock: l, blockContent: d } = a, u = i.selection.$anchor.parentOffset === 0, p = i.selection.anchor === i.selection.head, m = d.node.childCount === 0;
        if (u && p && m) {
          const f = l.afterPos, k = f + 2;
          if (c) {
            const g = i.schema.nodes.blockContainer.createAndFill();
            i.tr.insert(f, g).scrollIntoView(), i.tr.setSelection(
              new M(i.doc.resolve(k))
            );
          }
          return !0;
        }
        return !1;
      }),
      // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
      // deletes the selection beforehand, if it's not empty.
      () => s.command(({ state: i, chain: c }) => {
        const a = B(i);
        if (!a.isBlockContainer)
          return !1;
        const { blockContent: l } = a, d = i.selection.$anchor.parentOffset === 0;
        return l.node.childCount === 0 ? !1 : (c().deleteSelection().command(
          Xe(
            i.selection.from,
            d,
            d
          )
        ).run(), !0);
      })
    ]);
    return {
      Backspace: o,
      Delete: e,
      Enter: () => t(),
      "Shift-Enter": () => t(!0),
      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
      // editor since the browser will try to use tab for keyboard navigation.
      Tab: () => {
        var n, s;
        return this.options.tabBehavior !== "prefer-indent" && ((n = this.options.editor.getExtension(R)) != null && n.store.state || ((s = this.options.editor.getExtension(G)) == null ? void 0 : s.store.state) !== void 0) ? !1 : Te(this.options.editor);
      },
      "Shift-Tab": () => {
        var n, s;
        return this.options.tabBehavior !== "prefer-indent" && ((n = this.options.editor.getExtension(R)) != null && n.store.state || ((s = this.options.editor.getExtension(G)) == null ? void 0 : s.store.state) !== void 0) ? !1 : this.editor.commands.liftListItem("blockContainer");
      },
      "Shift-Mod-ArrowUp": () => (this.options.editor.moveBlocksUp(), !0),
      "Shift-Mod-ArrowDown": () => (this.options.editor.moveBlocksDown(), !0),
      "Mod-z": () => this.options.editor.undo(),
      "Mod-y": () => this.options.editor.redo(),
      "Shift-Mod-z": () => this.options.editor.redo()
    };
  }
}), Qo = X.create({
  name: "insertion",
  inclusive: !1,
  excludes: "deletion modification insertion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" }
      // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)
    };
  },
  extendMarkSchema(o) {
    return o.name !== "insertion" ? {} : {
      blocknoteIgnore: !0,
      inclusive: !1,
      toDOM(e, t) {
        return [
          "ins",
          {
            "data-id": String(e.attrs.id),
            "data-inline": String(t),
            ...!t && { style: "display: contents" }
            // changed to "contents" to make this work for table rows
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "ins",
          getAttrs(e) {
            return e.dataset.id ? {
              id: parseInt(e.dataset.id, 10)
            } : !1;
          }
        }
      ]
    };
  }
}), Xo = X.create({
  name: "deletion",
  inclusive: !1,
  excludes: "insertion modification deletion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" }
      // note: validate is supported in prosemirror but not in tiptap
    };
  },
  extendMarkSchema(o) {
    return o.name !== "deletion" ? {} : {
      blocknoteIgnore: !0,
      inclusive: !1,
      // attrs: {
      //   id: { validate: "number" },
      // },
      toDOM(e, t) {
        return [
          "del",
          {
            "data-id": String(e.attrs.id),
            "data-inline": String(t),
            ...!t && { style: "display: contents" }
            // changed to "contents" to make this work for table rows
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "del",
          getAttrs(e) {
            return e.dataset.id ? {
              id: parseInt(e.dataset.id, 10)
            } : !1;
          }
        }
      ]
    };
  }
}), Zo = X.create({
  name: "modification",
  inclusive: !1,
  excludes: "deletion insertion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" },
      type: { validate: "string" },
      attrName: { default: null, validate: "string|null" },
      previousValue: { default: null },
      newValue: { default: null }
    };
  },
  extendMarkSchema(o) {
    return o.name !== "modification" ? {} : {
      blocknoteIgnore: !0,
      inclusive: !1,
      // attrs: {
      //   id: { validate: "number" },
      //   type: { validate: "string" },
      //   attrName: { default: null, validate: "string|null" },
      //   previousValue: { default: null },
      //   newValue: { default: null },
      // },
      toDOM(e, t) {
        return [
          t ? "span" : "div",
          {
            "data-type": "modification",
            "data-id": String(e.attrs.id),
            "data-mod-type": e.attrs.type,
            "data-mod-prev-val": JSON.stringify(e.attrs.previousValue),
            // TODO: Try to serialize marks with toJSON?
            "data-mod-new-val": JSON.stringify(e.attrs.newValue)
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "span[data-type='modification']",
          getAttrs(e) {
            return e.dataset.id ? {
              id: parseInt(e.dataset.id, 10),
              type: e.dataset.modType,
              previousValue: e.dataset.modPrevVal,
              newValue: e.dataset.modNewVal
            } : !1;
          }
        },
        {
          tag: "div[data-type='modification']",
          getAttrs(e) {
            return e.dataset.id ? {
              id: parseInt(e.dataset.id, 10),
              type: e.dataset.modType,
              previousValue: e.dataset.modPrevVal
            } : !1;
          }
        }
      ]
    };
  }
}), en = E.create({
  name: "textAlignment",
  addGlobalAttributes() {
    return [
      {
        // Generally text alignment is handled through props using the custom
        // blocks API. Tables are the only blocks that are created as TipTap
        // nodes and ported to blocks, so we need to add text alignment in a
        // separate extension.
        types: ["tableCell", "tableHeader"],
        attributes: {
          textAlignment: {
            default: "left",
            parseHTML: (o) => o.getAttribute("data-text-alignment"),
            renderHTML: (o) => o.textAlignment === "left" ? {} : {
              "data-text-alignment": o.textAlignment
            }
          }
        }
      }
    ];
  }
}), tn = E.create({
  name: "blockTextColor",
  addGlobalAttributes() {
    return [
      {
        types: ["table", "tableCell", "tableHeader"],
        attributes: {
          textColor: et()
        }
      }
    ];
  }
}), on = {
  blockColor: "data-block-color",
  blockStyle: "data-block-style",
  id: "data-id",
  depth: "data-depth",
  depthChange: "data-depth-change"
}, nn = D.create({
  name: "blockContainer",
  group: "blockGroupChild bnBlock",
  // A block always contains content, and optionally a blockGroup which contains nested blocks
  content: "blockContent blockGroup?",
  // Ensures content-specific keyboard handlers trigger first.
  priority: 50,
  defining: !0,
  marks: "insertion modification deletion",
  parseHTML() {
    return [
      {
        tag: "div[data-node-type=" + this.name + "]",
        getAttrs: (o) => {
          if (typeof o == "string")
            return !1;
          const e = {};
          for (const [t, n] of Object.entries(on))
            o.getAttribute(n) && (e[t] = o.getAttribute(n));
          return e;
        }
      },
      // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.
      {
        tag: 'div[data-node-type="blockOuter"]',
        skip: !0
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    var s;
    const e = document.createElement("div");
    e.className = "bn-block-outer", e.setAttribute("data-node-type", "blockOuter");
    for (const [r, i] of Object.entries(o))
      r !== "class" && e.setAttribute(r, i);
    const t = {
      ...((s = this.options.domAttributes) == null ? void 0 : s.block) || {},
      ...o
    }, n = document.createElement("div");
    n.className = Q("bn-block", t.class), n.setAttribute("data-node-type", this.name);
    for (const [r, i] of Object.entries(t))
      r !== "class" && n.setAttribute(r, i);
    return e.appendChild(n), {
      dom: e,
      contentDOM: n
    };
  }
}), sn = D.create({
  name: "blockGroup",
  group: "childContainer",
  content: "blockGroupChild+",
  marks: "deletion insertion modification",
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (o) => typeof o == "string" ? !1 : o.getAttribute("data-node-type") === "blockGroup" ? null : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    var n;
    const e = {
      ...((n = this.options.domAttributes) == null ? void 0 : n.blockGroup) || {},
      ...o
    }, t = document.createElement("div");
    t.className = Q(
      "bn-block-group",
      e.class
    ), t.setAttribute("data-node-type", "blockGroup");
    for (const [s, r] of Object.entries(e))
      s !== "class" && t.setAttribute(s, r);
    return {
      dom: t,
      contentDOM: t
    };
  }
}), rn = D.create({
  name: "doc",
  topNode: !0,
  content: "blockGroup",
  marks: "insertion modification deletion"
}), an = Nt(
  ({ options: o }) => ({
    key: "collaboration",
    blockNoteExtensions: [
      it(o),
      at(o),
      ct(o),
      lt(),
      dt(o)
    ]
  })
);
let fe = !1;
function cn(o, e) {
  const t = [
    I.ClipboardTextSerializer,
    I.Commands,
    I.Editable,
    I.FocusEvents,
    I.Tabindex,
    Ft,
    me.configure({
      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)
      types: ["blockContainer", "columnList", "column"],
      setIdAttribute: e.setIdAttribute
    }),
    Ko,
    Ht,
    // marks:
    Qo,
    Xo,
    Zo,
    $t.extend({
      inclusive: !1
    }).configure({
      defaultProtocol: Bt,
      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450
      protocols: fe ? [] : St
    }),
    ...Object.values(o.schema.styleSpecs).map((n) => n.implementation.mark.configure({
      editor: o
    })),
    tn,
    Wo,
    en,
    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)
    E.create({
      name: "OverrideEscape",
      addKeyboardShortcuts: () => ({
        Escape: () => {
          var n;
          return (n = o.getExtension(ge)) != null && n.shown() ? !1 : (o.blur(), !0);
        }
      })
    }),
    // nodes
    rn,
    nn.configure({
      editor: o,
      domAttributes: e.domAttributes
    }),
    Yo.configure({
      editor: o,
      tabBehavior: e.tabBehavior
    }),
    sn.configure({
      domAttributes: e.domAttributes
    }),
    ...Object.values(o.schema.inlineContentSpecs).filter((n) => n.config !== "link" && n.config !== "text").map((n) => n.implementation.node.configure({
      editor: o
    })),
    ...Object.values(o.schema.blockSpecs).flatMap((n) => [
      // the node extension implementations
      ..."node" in n.implementation ? [
        n.implementation.node.configure({
          editor: o,
          domAttributes: e.domAttributes
        })
      ] : []
    ]),
    jo(o),
    Go(
      o,
      e.pasteHandler || ((n) => n.defaultPasteHandler())
    ),
    wo(o)
  ];
  return fe = !0, t;
}
function ln(o, e) {
  const t = [
    ye(),
    ut(e),
    G(e),
    R(e),
    pt(e),
    ft(),
    ht(e),
    Vt(e),
    mt(e),
    ge(e),
    ...e.trailingBlock !== !1 ? [kt()] : []
  ];
  return e.collaboration ? t.push(an(e.collaboration)) : t.push(gt()), "table" in o.schema.blockSpecs && t.push(bt(e)), e.animations !== !1 && t.push(yt()), t;
}
class dn {
  constructor(e, t) {
    /**
     * A set of extension keys which are disabled by the options
     */
    h(this, "disabledExtensions", /* @__PURE__ */ new Set());
    /**
     * A list of all the extensions that are registered to the editor
     */
    h(this, "extensions", []);
    /**
     * A map of all the abort controllers for each extension that has an init method defined
     */
    h(this, "abortMap", /* @__PURE__ */ new Map());
    /**
     * A map of all the extension factories that are registered to the editor
     */
    h(this, "extensionFactories", /* @__PURE__ */ new Map());
    /**
     * Because a single blocknote extension can both have it's own prosemirror plugins & additional generated ones (e.g. keymap & input rules plugins)
     * We need to keep track of all the plugins for each extension, so that we can remove them when the extension is unregistered
     */
    h(this, "extensionPlugins", /* @__PURE__ */ new Map());
    this.editor = e, this.options = t, e.onMount(() => {
      for (const n of this.extensions)
        if (n.mount) {
          const s = new window.AbortController(), r = n.mount({
            dom: e.prosemirrorView.dom,
            root: e.prosemirrorView.root,
            signal: s.signal
          });
          r && s.signal.addEventListener("abort", () => {
            r();
          }), this.abortMap.set(n, s);
        }
    }), e.onUnmount(() => {
      for (const [n, s] of this.abortMap.entries())
        this.abortMap.delete(n), s.abort();
    }), this.disabledExtensions = new Set(t.disableExtensions || []);
    for (const n of ln(this.editor, this.options))
      this.addExtension(n);
    for (const n of this.options.extensions ?? [])
      this.addExtension(n);
    for (const n of Object.values(this.editor.schema.blockSpecs))
      for (const s of n.extensions ?? [])
        this.addExtension(s);
  }
  /**
   * Register one or more extensions to the editor after the editor is initialized.
   *
   * This allows users to switch on & off extensions "at runtime".
   */
  registerExtension(e) {
    var r;
    const t = [].concat(e).filter(Boolean);
    if (!t.length) {
      console.warn("No extensions found to register", e);
      return;
    }
    const n = t.map((i) => this.addExtension(i)).filter(Boolean), s = /* @__PURE__ */ new Set();
    for (const i of n)
      i != null && i.tiptapExtensions && console.warn(
        `Extension ${i.key} has tiptap extensions, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,
        i
      ), (r = i == null ? void 0 : i.inputRules) != null && r.length && console.warn(
        `Extension ${i.key} has input rules, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,
        i
      ), this.getProsemirrorPluginsFromExtension(i).plugins.forEach(
        (c) => {
          s.add(c);
        }
      );
    this.updatePlugins((i) => [...i, ...s]);
  }
  /**
   * Register an extension to the editor
   * @param extension - The extension to register
   * @returns The extension instance
   */
  addExtension(e) {
    let t;
    if (typeof e == "function" ? t = e({ editor: this.editor }) : t = e, !(!t || this.disabledExtensions.has(t.key))) {
      if (typeof e == "function") {
        const n = t[Ot];
        typeof n == "function" && this.extensionFactories.set(n, t);
      }
      if (this.extensions.push(t), t.blockNoteExtensions)
        for (const n of t.blockNoteExtensions)
          this.addExtension(n);
      return t;
    }
  }
  /**
   * Resolve an extension or a list of extensions into a list of extension instances
   * @param toResolve - The extension or list of extensions to resolve
   * @returns A list of extension instances
   */
  resolveExtensions(e) {
    const t = [];
    if (typeof e == "function") {
      const n = this.extensionFactories.get(e);
      n && t.push(n);
    } else if (Array.isArray(e))
      for (const n of e)
        t.push(...this.resolveExtensions(n));
    else if (typeof e == "object" && "key" in e)
      t.push(e);
    else if (typeof e == "string") {
      const n = this.extensions.find((s) => s.key === e);
      n && t.push(n);
    }
    return t;
  }
  /**
   * Unregister an extension from the editor
   * @param toUnregister - The extension to unregister
   * @returns void
   */
  unregisterExtension(e) {
    var r;
    const t = this.resolveExtensions(e);
    if (!t.length) {
      console.warn("No extensions found to unregister", e);
      return;
    }
    let n = !1;
    const s = /* @__PURE__ */ new Set();
    for (const i of t) {
      this.extensions = this.extensions.filter((a) => a !== i), this.extensionFactories.forEach((a, l) => {
        a === i && this.extensionFactories.delete(l);
      }), (r = this.abortMap.get(i)) == null || r.abort(), this.abortMap.delete(i);
      const c = this.extensionPlugins.get(i);
      c == null || c.forEach((a) => {
        s.add(a);
      }), this.extensionPlugins.delete(i), i.tiptapExtensions && !n && (n = !0, console.warn(
        `Extension ${i.key} has tiptap extensions, but they will not be removed. Please separate the extension into multiple extensions if you want to remove them, or re-initialize the editor.`,
        e
      ));
    }
    this.updatePlugins(
      (i) => i.filter((c) => !s.has(c))
    );
  }
  /**
   * Allows resetting the current prosemirror state's plugins
   * @param update - A function that takes the current plugins and returns the new plugins
   * @returns void
   */
  updatePlugins(e) {
    const t = this.editor.prosemirrorState, n = t.reconfigure({
      plugins: e(t.plugins.slice())
    });
    this.editor.prosemirrorView.updateState(n);
  }
  /**
   * Get all the extensions that are registered to the editor
   */
  getTiptapExtensions() {
    var s;
    const e = cn(
      this.editor,
      this.options
    ).filter((r) => !this.disabledExtensions.has(r.name)), t = Ct(this.extensions), n = /* @__PURE__ */ new Map();
    for (const r of this.extensions) {
      r.tiptapExtensions && e.push(...r.tiptapExtensions);
      const i = t(r.key), { plugins: c, inputRules: a } = this.getProsemirrorPluginsFromExtension(r);
      c.length && e.push(
        E.create({
          name: r.key,
          priority: i,
          addProseMirrorPlugins: () => c
        })
      ), a.length && (n.has(i) || n.set(i, []), n.get(i).push(...a));
    }
    e.push(
      E.create({
        name: "blocknote-input-rules",
        addProseMirrorPlugins() {
          const r = [];
          return Array.from(n.keys()).sort().reverse().forEach((i) => {
            r.push(...n.get(i));
          }), [_t({ rules: r })];
        }
      })
    );
    for (const r of ((s = this.options._tiptapOptions) == null ? void 0 : s.extensions) ?? [])
      e.push(r);
    return e;
  }
  /**
   * This maps a blocknote extension into an array of Prosemirror plugins if it has any of the following:
   * - plugins
   * - keyboard shortcuts
   * - input rules
   */
  getProsemirrorPluginsFromExtension(e) {
    var s, r, i;
    const t = [...e.prosemirrorPlugins ?? []], n = [];
    return !((s = e.prosemirrorPlugins) != null && s.length) && !Object.keys(e.keyboardShortcuts || {}).length && !((r = e.inputRules) != null && r.length) ? { plugins: t, inputRules: n } : (this.extensionPlugins.set(e, t), (i = e.inputRules) != null && i.length && n.push(
      ...e.inputRules.map((c) => new Dt(c.find, (a, l, d, u) => {
        const p = c.replace({
          match: l,
          range: { from: d, to: u },
          editor: this.editor
        });
        if (p) {
          const m = this.editor.getTextCursorPosition();
          if (this.editor.schema.blockSchema[m.block.type].content !== "inline")
            return null;
          const f = $(a.tr), k = a.tr.deleteRange(d, u);
          return tt(k, f.bnBlock.beforePos, p), k;
        }
        return null;
      }))
    ), Object.keys(e.keyboardShortcuts || {}).length && t.push(
      Lt(
        Object.fromEntries(
          Object.entries(e.keyboardShortcuts).map(([c, a]) => [
            c,
            () => a({ editor: this.editor })
          ])
        )
      )
    ), { plugins: t, inputRules: n });
  }
  /**
   * Get all extensions
   */
  getExtensions() {
    return new Map(
      this.extensions.map((e) => [e.key, e])
    );
  }
  getExtension(e) {
    if (typeof e == "string") {
      const t = this.extensions.find((n) => n.key === e);
      return t || void 0;
    } else if (typeof e == "function") {
      const t = this.extensionFactories.get(e);
      return t || void 0;
    }
    throw new Error(`Invalid extension type: ${typeof e}`);
  }
  /**
   * Check if an extension exists
   */
  hasExtension(e) {
    return typeof e == "string" ? this.extensions.some((t) => t.key === e) : typeof e == "object" && "key" in e ? this.extensions.some((t) => t.key === e.key) : typeof e == "function" ? this.extensionFactories.has(e) : !1;
  }
}
function un(o, e) {
  let { $from: t, $to: n } = e;
  if (t.pos > t.start() && t.pos < o.content.size) {
    const s = o.textBetween(t.pos, t.pos + 1);
    if (/^[\w\p{P}]$/u.test(s)) {
      const i = o.textBetween(t.start(), t.pos).match(/[\w\p{P}]+$/u);
      i && (t = o.resolve(t.pos - i[0].length));
    }
  }
  if (n.pos < n.end() && n.pos > 0) {
    const s = o.textBetween(n.pos - 1, n.pos);
    if (/^[\w\p{P}]$/u.test(s)) {
      const i = o.textBetween(n.pos, n.end()).match(/^[\w\p{P}]+/u);
      i && (n = o.resolve(n.pos + i[0].length));
    }
  }
  return { $from: t, $to: n, from: t.pos, to: n.pos };
}
function pn(o) {
  const e = C(o);
  if (o.selection.empty || "node" in o.selection)
    return;
  const t = o.doc.resolve(
    _(o.doc, o.selection.from).posBeforeNode
  ), n = o.doc.resolve(
    _(o.doc, o.selection.to).posBeforeNode
  ), s = (l, d) => {
    const u = t.posAtIndex(l, d), p = o.doc.resolve(u).nodeAfter;
    if (!p)
      throw new Error(
        `Error getting selection - node not found at position ${u}`
      );
    return b(p, e);
  }, r = [], i = t.sharedDepth(n.pos), c = t.index(i), a = n.index(i);
  if (t.depth > i) {
    r.push(b(t.nodeAfter, e));
    for (let l = t.depth; l > i; l--)
      if (t.node(l).type.isInGroup("childContainer")) {
        const u = t.index(l) + 1, p = t.node(l).childCount;
        for (let m = u; m < p; m++)
          r.push(s(m, l));
      }
  } else
    r.push(s(c, i));
  for (let l = c + 1; l <= a; l++)
    r.push(s(l, i));
  if (r.length === 0)
    throw new Error(
      `Error getting selection - selection doesn't span any blocks (${o.selection})`
    );
  return {
    blocks: r
  };
}
function fn(o, e, t) {
  const n = typeof e == "string" ? e : e.id, s = typeof t == "string" ? t : t.id, r = C(o), i = ke(r);
  if (n === s)
    throw new Error(
      `Attempting to set selection with the same anchor and head blocks (id ${n})`
    );
  const c = x(n, o.doc);
  if (!c)
    throw new Error(`Block with ID ${n} not found`);
  const a = x(s, o.doc);
  if (!a)
    throw new Error(`Block with ID ${s} not found`);
  const l = z(c), d = z(a), u = i.blockSchema[l.blockNoteType], p = i.blockSchema[d.blockNoteType];
  if (!l.isBlockContainer || u.content === "none")
    throw new Error(
      `Attempting to set selection anchor in block without content (id ${n})`
    );
  if (!d.isBlockContainer || p.content === "none")
    throw new Error(
      `Attempting to set selection anchor in block without content (id ${s})`
    );
  let m, f;
  if (u.content === "table") {
    const k = se.get(l.blockContent.node);
    m = l.blockContent.beforePos + k.positionAt(0, 0, l.blockContent.node) + 1 + 2;
  } else
    m = l.blockContent.beforePos + 1;
  if (p.content === "table") {
    const k = se.get(d.blockContent.node), g = d.blockContent.beforePos + k.positionAt(
      k.height - 1,
      k.width - 1,
      d.blockContent.node
    ) + 1, y = o.doc.resolve(g).nodeAfter.nodeSize;
    f = g + y - 2;
  } else
    f = d.blockContent.afterPos - 1;
  o.setSelection(M.create(o.doc, m, f));
}
function hn(o, e = !1) {
  const t = C(o), n = e ? un(o.doc, o.selection) : o.selection;
  let s = n.$from, r = n.$to;
  for (; r.parentOffset >= r.parent.nodeSize - 2 && r.depth > 0; )
    r = o.doc.resolve(r.pos + 1);
  for (; r.parentOffset === 0 && r.depth > 0; )
    r = o.doc.resolve(r.pos - 1);
  for (; s.parentOffset === 0 && s.depth > 0; )
    s = o.doc.resolve(s.pos - 1);
  for (; s.parentOffset >= s.parent.nodeSize - 2 && s.depth > 0; )
    s = o.doc.resolve(s.pos + 1);
  const i = je(
    o.doc.slice(s.pos, r.pos, !0),
    t
  );
  return {
    _meta: {
      startPos: s.pos,
      endPos: r.pos
    },
    ...i
  };
}
function mn(o) {
  const { bnBlock: e } = $(o), t = C(o.doc), n = o.doc.resolve(e.beforePos), s = n.nodeBefore, r = o.doc.resolve(e.afterPos).nodeAfter;
  let i;
  return n.depth > 1 && (i = n.node(), i.type.isInGroup("bnBlock") || (i = n.node(n.depth - 1))), {
    block: b(e.node, t),
    prevBlock: s === null ? void 0 : b(s, t),
    nextBlock: r === null ? void 0 : b(r, t),
    parentBlock: i === void 0 ? void 0 : b(i, t)
  };
}
function De(o, e, t = "start") {
  const n = typeof e == "string" ? e : e.id, s = C(o.doc), r = ke(s), i = x(n, o.doc);
  if (!i)
    throw new Error(`Block with ID ${n} not found`);
  const c = z(i), a = r.blockSchema[c.blockNoteType].content;
  if (c.isBlockContainer) {
    const l = c.blockContent;
    if (a === "none") {
      o.setSelection(L.create(o.doc, l.beforePos));
      return;
    }
    if (a === "inline")
      t === "start" ? o.setSelection(
        M.create(o.doc, l.beforePos + 1)
      ) : o.setSelection(
        M.create(o.doc, l.afterPos - 1)
      );
    else if (a === "table")
      t === "start" ? o.setSelection(
        M.create(o.doc, l.beforePos + 4)
      ) : o.setSelection(
        M.create(o.doc, l.afterPos - 4)
      );
    else
      throw new F(a);
  } else {
    const l = t === "start" ? c.childContainer.node.firstChild : c.childContainer.node.lastChild;
    De(o, l.attrs.id, t);
  }
}
class kn {
  constructor(e) {
    this.editor = e;
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
   */
  getSelection() {
    return this.editor.transact((e) => pn(e));
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned block will be
   * only the part of the block that is included in the selection.
   */
  getSelectionCutBlocks(e = !1) {
    return this.editor.transact((t) => hn(t, e));
  }
  /**
   * Sets the selection to a range of blocks.
   * @param startBlock The identifier of the block that should be the start of the selection.
   * @param endBlock The identifier of the block that should be the end of the selection.
   */
  setSelection(e, t) {
    return this.editor.transact((n) => fn(n, e, t));
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    return this.editor.transact((e) => mn(e));
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(e, t = "start") {
    return this.editor.transact(
      (n) => De(n, e, t)
    );
  }
  /**
   * Gets the bounding box of the current selection.
   */
  getSelectionBoundingBox() {
    if (!this.editor.prosemirrorView)
      return;
    const { selection: e } = this.editor.prosemirrorState, { ranges: t } = e, n = Math.min(...t.map((r) => r.$from.pos)), s = Math.max(...t.map((r) => r.$to.pos));
    if (Mt(e)) {
      const r = this.editor.prosemirrorView.nodeDOM(n);
      if (r)
        return r.getBoundingClientRect();
    }
    return wt(
      this.editor.prosemirrorView,
      n,
      s
    ).toJSON();
  }
}
class gn {
  constructor(e) {
    /**
     * Stores the currently active transaction, which is the accumulated transaction from all {@link dispatch} calls during a {@link transact} calls
     */
    h(this, "activeTransaction", null);
    // Flag to indicate if we're in a `can` call
    h(this, "isInCan", !1);
    this.editor = e;
  }
  /**
   * For any command that can be executed, you can check if it can be executed by calling `editor.can(command)`.
   * @example
   * ```ts
   * if (editor.can(editor.undo)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   */
  can(e) {
    try {
      return this.isInCan = !0, e();
    } finally {
      this.isInCan = !1;
    }
  }
  /**
   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
   *
   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
   *
   * @example
   * ```ts
   * editor.exec((state, dispatch, view) => {
   *   dispatch(state.tr.insertText("Hello, world!"));
   * });
   * ```
   */
  exec(e) {
    if (this.activeTransaction)
      throw new Error(
        "`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call"
      );
    if (this.isInCan)
      return this.canExec(e);
    const t = this.prosemirrorState, n = this.prosemirrorView;
    return e(t, (r) => this.prosemirrorView.dispatch(r), n);
  }
  /**
   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
   *
   * @example
   * ```ts
   * if (editor.canExec(command)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   * ```
   */
  canExec(e) {
    if (this.activeTransaction)
      throw new Error(
        "`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call"
      );
    const t = this.prosemirrorState, n = this.prosemirrorView;
    return e(t, void 0, n);
  }
  /**
   * Execute a function within a "blocknote transaction".
   * All changes to the editor within the transaction will be grouped together, so that
   * we can dispatch them as a single operation (thus creating only a single undo step)
   *
   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
   *
   * @example
   * ```ts
   * // All changes to the editor will be grouped together
   * editor.transact((tr) => {
   *   tr.insertText("Hello, world!");
   * // These two operations will be grouped together in a single undo step
   *   editor.transact((tr) => {
   *     tr.insertText("Hello, world!");
   *   });
   * });
   * ```
   */
  transact(e) {
    if (this.activeTransaction)
      return e(this.activeTransaction);
    try {
      this.activeTransaction = this.editor._tiptapEditor.state.tr;
      const t = e(this.activeTransaction), n = this.activeTransaction;
      return this.activeTransaction = null, n && // Only dispatch if the transaction was actually modified in some way
      (n.docChanged || n.selectionSet || n.scrolledIntoView || n.storedMarksSet || !n.isGeneric) && this.prosemirrorView.dispatch(n), t;
    } finally {
      this.activeTransaction = null;
    }
  }
  /**
   * Get the underlying prosemirror state
   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
   * @see https://prosemirror.net/docs/ref/#state.EditorState
   */
  get prosemirrorState() {
    if (this.activeTransaction)
      throw new Error(
        "`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state"
      );
    return this.editor._tiptapEditor.state;
  }
  /**
   * Get the underlying prosemirror view
   * @see https://prosemirror.net/docs/ref/#view.EditorView
   */
  get prosemirrorView() {
    return this.editor._tiptapEditor.view;
  }
  isFocused() {
    var e;
    return ((e = this.prosemirrorView) == null ? void 0 : e.hasFocus()) || !1;
  }
  focus() {
    var e;
    (e = this.prosemirrorView) == null || e.focus();
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    if (!this.editor._tiptapEditor) {
      if (!this.editor.headless)
        throw new Error("no editor, but also not headless?");
      return !1;
    }
    return this.editor._tiptapEditor.isEditable === void 0 ? !0 : this.editor._tiptapEditor.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(e) {
    if (!this.editor._tiptapEditor) {
      if (!this.editor.headless)
        throw new Error("no editor, but also not headless?");
      return;
    }
    this.editor._tiptapEditor.options.editable !== e && this.editor._tiptapEditor.setEditable(e);
  }
  /**
   * Undo the last action.
   */
  undo() {
    const e = this.editor.getExtension("yUndo");
    if (e)
      return this.exec(e.undoCommand);
    const t = this.editor.getExtension("history");
    if (t)
      return this.exec(t.undoCommand);
    throw new Error("No undo plugin found");
  }
  /**
   * Redo the last action.
   */
  redo() {
    const e = this.editor.getExtension("yUndo");
    if (e)
      return this.exec(e.redoCommand);
    const t = this.editor.getExtension("history");
    if (t)
      return this.exec(t.redoCommand);
    throw new Error("No redo plugin found");
  }
}
function bn(o, e, t, n = { updateSelection: !0 }) {
  let { from: s, to: r } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, i = !0, c = !0, a = "";
  if (t.forEach((l) => {
    l.check(), i && l.isText && l.marks.length === 0 ? a += l.text : i = !1, c = c ? l.isBlock : !1;
  }), s === r && c) {
    const { parent: l } = o.doc.resolve(s);
    l.isTextblock && !l.type.spec.code && !l.childCount && (s -= 1, r += 1);
  }
  return i ? o.insertText(a, s, r) : o.replaceWith(s, r, t), n.updateSelection && Tt(o, o.steps.length - 1, -1), !0;
}
class yn {
  constructor(e) {
    this.editor = e;
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(e, { updateSelection: t = !1 } = {}) {
    const n = O(e, this.editor.pmSchema);
    this.editor.transact((s) => {
      bn(
        s,
        {
          from: s.selection.from,
          to: s.selection.to
        },
        n,
        {
          updateSelection: t
        }
      );
    });
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    return this.editor.transact((e) => {
      const t = {}, n = e.selection.$to.marks();
      for (const s of n) {
        const r = this.editor.schema.styleSchema[s.type.name];
        if (!r) {
          // Links are not considered styles in blocknote
          s.type.name !== "link" && // "blocknoteIgnore" tagged marks (such as comments) are also not considered BlockNote "styles"
          !s.type.spec.blocknoteIgnore && console.warn("mark not found in styleschema", s.type.name);
          continue;
        }
        r.propSchema === "boolean" ? t[r.type] = !0 : t[r.type] = s.attrs.stringValue;
      }
      return t;
    });
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(e) {
    for (const [t, n] of Object.entries(e)) {
      const s = this.editor.schema.styleSchema[t];
      if (!s)
        throw new Error(`style ${t} not found in styleSchema`);
      if (s.propSchema === "boolean")
        this.editor._tiptapEditor.commands.setMark(t);
      else if (s.propSchema === "string")
        this.editor._tiptapEditor.commands.setMark(t, {
          stringValue: n
        });
      else
        throw new F(s.propSchema);
    }
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(e) {
    for (const t of Object.keys(e))
      this.editor._tiptapEditor.commands.unsetMark(t);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(e) {
    for (const [t, n] of Object.entries(e)) {
      const s = this.editor.schema.styleSchema[t];
      if (!s)
        throw new Error(`style ${t} not found in styleSchema`);
      if (s.propSchema === "boolean")
        this.editor._tiptapEditor.commands.toggleMark(t);
      else if (s.propSchema === "string")
        this.editor._tiptapEditor.commands.toggleMark(t, {
          stringValue: n
        });
      else
        throw new F(s.propSchema);
    }
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this.editor.transact((e) => e.doc.textBetween(e.selection.from, e.selection.to));
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this.editor._tiptapEditor.getAttributes("link").href;
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(e, t) {
    if (e === "")
      return;
    const n = this.editor.pmSchema.mark("link", { href: e });
    this.editor.transact((s) => {
      const { from: r, to: i } = s.selection;
      t ? s.insertText(t, r, i).addMark(r, r + t.length, n) : s.setSelection(Wt.create(s.doc, i)).addMark(
        r,
        i,
        n
      );
    });
  }
}
function Sn(o, e) {
  const t = [];
  return o.forEach((n, s, r) => {
    r !== e && t.push(n);
  }), Z.from(t);
}
function Bn(o, e) {
  const t = [];
  for (let n = 0; n < o.childCount; n++)
    if (o.child(n).type.name === "tableRow")
      if (t.length > 0 && t[t.length - 1].type.name === "table") {
        const s = t[t.length - 1], r = s.copy(s.content.addToEnd(o.child(n)));
        t[t.length - 1] = r;
      } else {
        const s = e.nodes.table.createChecked(
          void 0,
          o.child(n)
        );
        t.push(s);
      }
    else
      t.push(o.child(n));
  return o = Z.from(t), o;
}
function Cn(o, e) {
  let t = Z.from(o.content);
  if (t = Bn(t, e.state.schema), !xn(t, e))
    return new ne(t, o.openStart, o.openEnd);
  for (let n = 0; n < t.childCount; n++)
    if (t.child(n).type.spec.group === "blockContent") {
      const s = [t.child(n)];
      if (n + 1 < t.childCount && t.child(n + 1).type.name === "blockGroup") {
        const i = t.child(n + 1).child(0).child(0);
        (i.type.name === "bulletListItem" || i.type.name === "numberedListItem" || i.type.name === "checkListItem") && (s.push(t.child(n + 1)), t = Sn(t, n + 1));
      }
      const r = e.state.schema.nodes.blockContainer.createChecked(
        void 0,
        s
      );
      t = t.replaceChild(n, r);
    }
  return new ne(t, o.openStart, o.openEnd);
}
function xn(o, e) {
  var r, i;
  const t = o.childCount === 1, n = ((r = o.firstChild) == null ? void 0 : r.type.spec.content) === "inline*", s = ((i = o.firstChild) == null ? void 0 : i.type.spec.content) === "tableRow+";
  if (t) {
    if (n)
      return !1;
    if (s) {
      const c = B(e.state);
      if (c.isBlockContainer)
        return !(c.blockContent.node.type.spec.content === "tableRow+");
    }
  }
  return !0;
}
const En = {
  enableInputRules: !0,
  enablePasteRules: !0,
  enableCoreExtensions: !1
};
class Le extends Se {
  constructor(t) {
    var l, d, u, p, m, f, k, g, y, T;
    super();
    /**
     * The underlying prosemirror schema
     */
    h(this, "pmSchema");
    h(this, "_tiptapEditor");
    /**
     * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements
     * in the correct context (used by `ReactRenderUtil`)
     */
    h(this, "elementRenderer", null);
    /**
     * Cache of all blocks. This makes sure we don't have to "recompute" blocks if underlying Prosemirror Nodes haven't changed.
     * This is especially useful when we want to keep track of the same block across multiple operations,
     * with this cache, blocks stay the same object reference (referential equality with ===).
     */
    h(this, "blockCache", /* @__PURE__ */ new WeakMap());
    /**
     * The dictionary contains translations for the editor.
     */
    h(this, "dictionary");
    /**
     * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.
     */
    h(this, "schema");
    h(this, "blockImplementations");
    h(this, "inlineContentImplementations");
    h(this, "styleImplementations");
    /**
     * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).
     * This method should set when creating the editor as this is application-specific.
     *
     * `undefined` means the application doesn't support file uploads.
     *
     * @param file The file that should be uploaded.
     * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)
     */
    h(this, "uploadFile");
    h(this, "onUploadStartCallbacks", []);
    h(this, "onUploadEndCallbacks", []);
    h(this, "resolveFileUrl");
    /**
     * Editor settings
     */
    h(this, "settings");
    // Manager instances
    h(this, "_blockManager");
    h(this, "_eventManager");
    h(this, "_exportManager");
    h(this, "_extensionManager");
    h(this, "_selectionManager");
    h(this, "_stateManager");
    h(this, "_styleManager");
    /**
     * Remove extension(s) from the editor
     */
    h(this, "unregisterExtension", (...t) => this._extensionManager.unregisterExtension(...t));
    /**
     * Register extension(s) to the editor
     */
    h(this, "registerExtension", (...t) => this._extensionManager.registerExtension(...t));
    /**
     * Get an extension from the editor
     */
    h(this, "getExtension", (...t) => this._extensionManager.getExtension(...t));
    /**
     * Mount the editor to a DOM element.
     *
     * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting
     */
    h(this, "mount", (t) => {
      this._tiptapEditor.mount({ mount: t });
    });
    /**
     * Unmount the editor from the DOM element it is bound to
     */
    h(this, "unmount", () => {
      this._tiptapEditor.unmount();
    });
    this.options = t, this.dictionary = t.dictionary || At, this.settings = {
      tables: {
        splitCells: ((l = t == null ? void 0 : t.tables) == null ? void 0 : l.splitCells) ?? !1,
        cellBackgroundColor: ((d = t == null ? void 0 : t.tables) == null ? void 0 : d.cellBackgroundColor) ?? !1,
        cellTextColor: ((u = t == null ? void 0 : t.tables) == null ? void 0 : u.cellTextColor) ?? !1,
        headers: ((p = t == null ? void 0 : t.tables) == null ? void 0 : p.headers) ?? !1
      }
    };
    const n = {
      defaultStyles: !0,
      schema: t.schema || xt.create(),
      ...t,
      placeholders: {
        ...this.dictionary.placeholders,
        ...t.placeholders
      }
    };
    if (this.schema = n.schema, this.blockImplementations = n.schema.blockSpecs, this.inlineContentImplementations = n.schema.inlineContentSpecs, this.styleImplementations = n.schema.styleSpecs, n.uploadFile) {
      const S = n.uploadFile;
      this.uploadFile = async (P, w) => {
        this.onUploadStartCallbacks.forEach(
          (v) => v.apply(this, [w])
        );
        try {
          return await S(P, w);
        } finally {
          this.onUploadEndCallbacks.forEach(
            (v) => v.apply(this, [w])
          );
        }
      };
    }
    this.resolveFileUrl = n.resolveFileUrl, this._eventManager = new fo(this), this._extensionManager = new dn(this, n);
    const s = this._extensionManager.getTiptapExtensions(), r = this._extensionManager.hasExtension("ySync") || this._extensionManager.hasExtension("liveblocksExtension");
    r && n.initialContent && console.warn(
      "When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider"
    );
    const i = {
      ...En,
      ...n._tiptapOptions,
      element: null,
      autofocus: n.autofocus ?? !1,
      extensions: s,
      editorProps: {
        ...(m = n._tiptapOptions) == null ? void 0 : m.editorProps,
        attributes: {
          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not
          // editable, so you can't focus it. We want to revert this as we have
          // UI behaviour that relies on it.
          tabIndex: "0",
          ...(k = (f = n._tiptapOptions) == null ? void 0 : f.editorProps) == null ? void 0 : k.attributes,
          ...(g = n.domAttributes) == null ? void 0 : g.editor,
          class: Q(
            "bn-editor",
            n.defaultStyles ? "bn-default-styles" : "",
            ((T = (y = n.domAttributes) == null ? void 0 : y.editor) == null ? void 0 : T.class) || ""
          )
        },
        transformPasted: Cn
      }
    };
    try {
      const S = n.initialContent || (r ? [
        {
          type: "paragraph",
          id: "initialBlockId"
        }
      ] : [
        {
          type: "paragraph",
          id: me.options.generateID()
        }
      ]);
      if (!Array.isArray(S) || S.length === 0)
        throw new Error(
          "initialContent must be a non-empty array of blocks, received: " + S
        );
      const P = Pt(i.extensions), w = S.map(
        (Ne) => q(Ne, P, this.schema.styleSchema).toJSON()
      ), v = vt(
        {
          type: "doc",
          content: [
            {
              type: "blockGroup",
              content: w
            }
          ]
        },
        P,
        i.parseOptions
      );
      this._tiptapEditor = new It({
        ...i,
        content: v.toJSON()
      }), this.pmSchema = this._tiptapEditor.schema;
    } catch (S) {
      throw new Error(
        "Error creating document from blocks passed as `initialContent`",
        { cause: S }
      );
    }
    let c;
    const a = this.pmSchema.nodes.doc.createAndFill;
    this.pmSchema.nodes.doc.createAndFill = (...S) => {
      if (c)
        return c;
      const P = a.apply(this.pmSchema.nodes.doc, S), w = JSON.parse(JSON.stringify(P.toJSON()));
      return w.content[0].content[0].attrs.id = "initialBlockId", c = He.fromJSON(this.pmSchema, w), c;
    }, this.pmSchema.cached.blockNoteEditor = this, this._blockManager = new po(this), this._exportManager = new xo(this), this._selectionManager = new kn(this), this._stateManager = new gn(this), this._styleManager = new yn(this), this.emit("create");
  }
  static create(t) {
    return new Le(t ?? {});
  }
  /**
   * BlockNote extensions that are added to the editor, keyed by the extension key
   */
  get extensions() {
    return this._extensionManager.getExtensions();
  }
  /**
   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
   *
   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
   *
   * @example
   * ```ts
   * editor.exec((state, dispatch, view) => {
   *   dispatch(state.tr.insertText("Hello, world!"));
   * });
   * ```
   */
  exec(t) {
    return this._stateManager.exec(t);
  }
  /**
   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
   *
   * @example
   * ```ts
   * if (editor.canExec(command)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   * ```
   */
  canExec(t) {
    return this._stateManager.canExec(t);
  }
  /**
   * Execute a function within a "blocknote transaction".
   * All changes to the editor within the transaction will be grouped together, so that
   * we can dispatch them as a single operation (thus creating only a single undo step)
   *
   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
   *
   * @example
   * ```ts
   * // All changes to the editor will be grouped together
   * editor.transact((tr) => {
   *   tr.insertText("Hello, world!");
   * // These two operations will be grouped together in a single undo step
   *   editor.transact((tr) => {
   *     tr.insertText("Hello, world!");
   *   });
   * });
   * ```
   */
  transact(t) {
    return this._stateManager.transact(t);
  }
  /**
   * Get the underlying prosemirror state
   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
   * @see https://prosemirror.net/docs/ref/#state.EditorState
   */
  get prosemirrorState() {
    return this._stateManager.prosemirrorState;
  }
  /**
   * Get the underlying prosemirror view
   * @see https://prosemirror.net/docs/ref/#view.EditorView
   */
  get prosemirrorView() {
    return this._stateManager.prosemirrorView;
  }
  get domElement() {
    var t;
    if (!this.headless)
      return (t = this.prosemirrorView) == null ? void 0 : t.dom;
  }
  isFocused() {
    var t;
    return this.headless ? !1 : ((t = this.prosemirrorView) == null ? void 0 : t.hasFocus()) || !1;
  }
  get headless() {
    return !this._tiptapEditor.isInitialized;
  }
  /**
   * Focus on the editor
   */
  focus() {
    this.headless || this.prosemirrorView.focus();
  }
  /**
   * Blur the editor
   */
  blur() {
    var t;
    this.headless || (t = this.domElement) == null || t.blur();
  }
  // TODO move to extension
  onUploadStart(t) {
    return this.onUploadStartCallbacks.push(t), () => {
      const n = this.onUploadStartCallbacks.indexOf(t);
      n > -1 && this.onUploadStartCallbacks.splice(n, 1);
    };
  }
  onUploadEnd(t) {
    return this.onUploadEndCallbacks.push(t), () => {
      const n = this.onUploadEndCallbacks.indexOf(t);
      n > -1 && this.onUploadEndCallbacks.splice(n, 1);
    };
  }
  /**
   * @deprecated, use `editor.document` instead
   */
  get topLevelBlocks() {
    return this.document;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    return this._blockManager.document;
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be
   * retrieved.
   * @returns The block that matches the identifier, or `undefined` if no
   * matching block was found.
   */
  getBlock(t) {
    return this._blockManager.getBlock(t);
  }
  /**
   * Gets a snapshot of the previous sibling of an existing block from the
   * editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * previous sibling should be retrieved.
   * @returns The previous sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the first child/block
   * in the document.
   */
  getPrevBlock(t) {
    return this._blockManager.getPrevBlock(t);
  }
  /**
   * Gets a snapshot of the next sibling of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * next sibling should be retrieved.
   * @returns The next sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the last child/block in
   * the document.
   */
  getNextBlock(t) {
    return this._blockManager.getNextBlock(t);
  }
  /**
   * Gets a snapshot of the parent of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * parent should be retrieved.
   * @returns The parent of the block that matches the identifier. `undefined`
   * if no matching block was found, or the block isn't nested.
   */
  getParentBlock(t) {
    return this._blockManager.getParentBlock(t);
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(t, n = !1) {
    this._blockManager.forEachBlock(t, n);
  }
  /**
   * Executes a callback whenever the editor's contents change.
   * @param callback The callback to execute.
   *
   * @deprecated use {@link BlockNoteEditor.onChange} instead
   */
  onEditorContentChange(t) {
    this._tiptapEditor.on("update", t);
  }
  /**
   * Executes a callback whenever the editor's selection changes.
   * @param callback The callback to execute.
   *
   * @deprecated use `onSelectionChange` instead
   */
  onEditorSelectionChange(t) {
    this._tiptapEditor.on("selectionUpdate", t);
  }
  /**
   * Executes a callback before any change is applied to the editor, allowing you to cancel the change.
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onBeforeChange(t) {
    return this._extensionManager.getExtension(ye).subscribe(t);
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    return this._selectionManager.getTextCursorPosition();
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(t, n = "start") {
    return this._selectionManager.setTextCursorPosition(t, n);
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
   */
  getSelection() {
    return this._selectionManager.getSelection();
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned block will be
   * only the part of the block that is included in the selection.
   */
  getSelectionCutBlocks(t = !1) {
    return this._selectionManager.getSelectionCutBlocks(t);
  }
  /**
   * Sets the selection to a range of blocks.
   * @param startBlock The identifier of the block that should be the start of the selection.
   * @param endBlock The identifier of the block that should be the end of the selection.
   */
  setSelection(t, n) {
    return this._selectionManager.setSelection(t, n);
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    return this._stateManager.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(t) {
    this._stateManager.isEditable = t;
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`.
   */
  insertBlocks(t, n, s = "before") {
    return this._blockManager.insertBlocks(
      t,
      n,
      s
    );
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(t, n) {
    return this._blockManager.updateBlock(t, n);
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(t) {
    return this._blockManager.removeBlocks(t);
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(t, n) {
    return this._blockManager.replaceBlocks(t, n);
  }
  /**
   * Undo the last action.
   */
  undo() {
    return this._stateManager.undo();
  }
  /**
   * Redo the last action.
   */
  redo() {
    return this._stateManager.redo();
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(t, { updateSelection: n = !1 } = {}) {
    this._styleManager.insertInlineContent(t, { updateSelection: n });
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    return this._styleManager.getActiveStyles();
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(t) {
    this._styleManager.addStyles(t);
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(t) {
    this._styleManager.removeStyles(t);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(t) {
    this._styleManager.toggleStyles(t);
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this._styleManager.getSelectedText();
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this._styleManager.getSelectedLinkUrl();
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(t, n) {
    this._styleManager.createLink(t, n);
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    return this._blockManager.canNestBlock();
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    this._blockManager.nestBlock();
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    return this._blockManager.canUnnestBlock();
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    this._blockManager.unnestBlock();
  }
  /**
   * Moves the selected blocks up. If the previous block has children, moves
   * them to the end of its children. If there is no previous block, but the
   * current blocks share a common parent, moves them out of & before it.
   */
  moveBlocksUp() {
    return this._blockManager.moveBlocksUp();
  }
  /**
   * Moves the selected blocks down. If the next block has children, moves
   * them to the start of its children. If there is no next block, but the
   * current blocks share a common parent, moves them out of & after it.
   */
  moveBlocksDown() {
    return this._blockManager.moveBlocksDown();
  }
  /**
   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToHTMLLossy(t = this.document) {
    return this._exportManager.blocksToHTMLLossy(t);
  }
  /**
   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
   *
   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToFullHTML(t = this.document) {
    return this._exportManager.blocksToFullHTML(t);
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  tryParseHTMLToBlocks(t) {
    return this._exportManager.tryParseHTMLToBlocks(t);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  blocksToMarkdownLossy(t = this.document) {
    return this._exportManager.blocksToMarkdownLossy(t);
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  tryParseMarkdownToBlocks(t) {
    return this._exportManager.tryParseMarkdownToBlocks(t);
  }
  /**
   * A callback function that runs whenever the editor's contents change.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onChange(t, n) {
    return this._eventManager.onChange(t, n);
  }
  /**
   * A callback function that runs whenever the text cursor position or selection changes.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onSelectionChange(t, n) {
    return this._eventManager.onSelectionChange(
      t,
      n
    );
  }
  /**
   * A callback function that runs when the editor has been mounted.
   *
   * This can be useful for plugins to initialize themselves after the editor has been mounted.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onMount(t) {
    this._eventManager.onMount(t);
  }
  /**
   * A callback function that runs when the editor has been unmounted.
   *
   * This can be useful for plugins to clean up themselves after the editor has been unmounted.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onUnmount(t) {
    this._eventManager.onUnmount(t);
  }
  /**
   * Gets the bounding box of the current selection.
   * @returns The bounding box of the current selection.
   */
  getSelectionBoundingBox() {
    return this._selectionManager.getSelectionBoundingBox();
  }
  get isEmpty() {
    const t = this.document;
    return t.length === 0 || t.length === 1 && t[0].type === "paragraph" && t[0].content.length === 0;
  }
  /**
   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
   * @param html The HTML to paste.
   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
   */
  pasteHTML(t, n = !1) {
    this._exportManager.pasteHTML(t, n);
  }
  /**
   * Paste text into the editor. Defaults to interpreting text as markdown.
   * @param text The text to paste.
   */
  pasteText(t) {
    return this._exportManager.pasteText(t);
  }
  /**
   * Paste markdown into the editor.
   * @param markdown The markdown to paste.
   */
  pasteMarkdown(t) {
    return this._exportManager.pasteMarkdown(t);
  }
}
class Xn {
  constructor(e, t, n) {
    this.mappings = t, this.options = n;
  }
  async resolveFile(e) {
    var n;
    if (!((n = this.options) != null && n.resolveFileUrl))
      return (await fetch(e)).blob();
    const t = await this.options.resolveFileUrl(e);
    return t instanceof Blob ? t : (await fetch(t)).blob();
  }
  mapStyles(e) {
    return Object.entries(e).map(([n, s]) => this.mappings.styleMapping[n](s, this));
  }
  mapInlineContent(e) {
    return this.mappings.inlineContentMapping[e.type](
      e,
      this
    );
  }
  transformInlineContent(e) {
    return e.map((t) => this.mapInlineContent(t));
  }
  async mapBlock(e, t, n, s) {
    return this.mappings.blockMapping[e.type](
      e,
      this,
      t,
      n,
      s
    );
  }
}
function Zn(o) {
  return {
    createBlockMapping: (e) => e,
    createInlineContentMapping: (e) => e,
    createStyleMapping: (e) => e
  };
}
function es(o, ...e) {
  const t = [...o];
  for (const n of e)
    for (const s of n) {
      const r = t.findLastIndex(
        (i) => i.group === s.group
      );
      r === -1 ? t.push(s) : t.splice(r + 1, 0, s);
    }
  return t;
}
export {
  Le as BlockNoteEditor,
  xt as BlockNoteSchema,
  bs as COLORS_DARK_MODE_DEFAULT,
  ys as COLORS_DEFAULT,
  Xr as CustomBlockNoteSchema,
  Ss as EMPTY_CELL_HEIGHT,
  Bs as EMPTY_CELL_WIDTH,
  Se as EventEmitter,
  Xn as Exporter,
  Cs as FILE_AUDIO_ICON_SVG,
  xs as FILE_IMAGE_ICON_SVG,
  Es as FILE_VIDEO_ICON_SVG,
  Pe as HTMLToBlocks,
  me as UniqueID,
  F as UnreachableCaseError,
  Ms as addDefaultPropsExternalHTML,
  H as addInlineContentAttributes,
  We as addInlineContentKeyboardShortcuts,
  ws as addNodeAndExtensionsToSpec,
  Ts as addStyleAttributes,
  Ps as applyNonSelectableBlockFix,
  ns as assertEmpty,
  vs as audioParse,
  Is as audioRender,
  As as audioToExternalHTML,
  _s as blockHasType,
  q as blockToNode,
  nt as blocksToMarkdown,
  Ds as camelToDataKebab,
  Ls as captureCellAnchor,
  Zr as checkPageBreakBlocksInSchema,
  st as cleanHTMLToMarkdown,
  es as combineByGroup,
  Re as contentNodeToInlineContent,
  Ge as contentNodeToTableContent,
  Ns as createAudioBlockConfig,
  Os as createAudioBlockSpec,
  Fs as createBlockConfig,
  $s as createBlockSpec,
  Hs as createBlockSpecFromTiptapNode,
  Vs as createBulletListItemBlockConfig,
  Us as createBulletListItemBlockSpec,
  zs as createCheckListItemBlockSpec,
  Gs as createCheckListItemConfig,
  Rs as createCodeBlockConfig,
  js as createCodeBlockSpec,
  Ws as createDefaultBlockDOMOutputSpec,
  Ks as createDividerBlockConfig,
  Js as createDividerBlockSpec,
  Nt as createExtension,
  be as createExternalHTMLExporter,
  qs as createFileBlockConfig,
  Ys as createFileBlockSpec,
  Qs as createHeadingBlockConfig,
  Xs as createHeadingBlockSpec,
  Zs as createImageBlockConfig,
  er as createImageBlockSpec,
  Qn as createInlineContentSpec,
  Je as createInlineContentSpecFromTipTapNode,
  Xt as createInternalHTMLSerializer,
  tr as createInternalInlineContentSpec,
  or as createInternalStyleSpec,
  nr as createNumberedListItemBlockConfig,
  sr as createNumberedListItemBlockSpec,
  ei as createPageBreakBlockConfig,
  ti as createPageBreakBlockSpec,
  rr as createParagraphBlockConfig,
  ir as createParagraphBlockSpec,
  ar as createQuoteBlockConfig,
  cr as createQuoteBlockSpec,
  ii as createStore,
  lr as createStyleSpec,
  dr as createStyleSpecFromTipTapMark,
  ur as createTableBlockSpec,
  pr as createToggleListItemBlockConfig,
  fr as createToggleListItemBlockSpec,
  hr as createToggleWrapper,
  mr as createVideoBlockConfig,
  kr as createVideoBlockSpec,
  gr as defaultBlockSpecs,
  br as defaultBlockToHTML,
  yr as defaultInlineContentSchema,
  Sr as defaultInlineContentSpecs,
  Br as defaultProps,
  Cr as defaultStyleSchema,
  xr as defaultStyleSpecs,
  Er as defaultToggledState,
  ze as docToBlocks,
  Mr as editorHasBlockWithType,
  un as expandPMRangeToWords,
  wr as fileParse,
  Tr as filenameFromURL,
  W as fixColumnList,
  Pr as formatKeyboardShortcut,
  Qe as getBackgroundColorAttribute,
  ao as getBlock,
  ss as getBlockCache,
  vr as getBlockFromPos,
  z as getBlockInfo,
  Y as getBlockInfoFromResolvedPos,
  B as getBlockInfoFromSelection,
  $ as getBlockInfoFromTransaction,
  rs as getBlockInfoWithManualOffset,
  ke as getBlockNoteSchema,
  is as getBlockSchema,
  ot as getBlocksChangedByTransaction,
  as as getColspan,
  Kt as getInlineContentParseRules,
  cs as getInlineContentSchema,
  Ir as getInlineContentSchemaFromSpecs,
  Ar as getLanguageId,
  _ as getNearestBlockPos,
  lo as getNextBlock,
  x as getNodeById,
  oi as getPageBreakSlashMenuItems,
  uo as getParentBlock,
  _r as getParseRules,
  C as getPmSchema,
  co as getPrevBlock,
  ls as getRowspan,
  Dr as getStyleParseRules,
  ds as getStyleSchema,
  Lr as getStyleSchemaFromSpecs,
  Nr as getTextAlignmentAttribute,
  et as getTextColorAttribute,
  Or as imageParse,
  Fr as imageRender,
  $r as imageToExternalHTML,
  O as inlineContentToNodes,
  Jt as insertBlocks,
  Hr as isAppleOS,
  j as isEmptyColumn,
  us as isLinkInlineContent,
  Vr as isNodeBlock,
  ps as isPartialLinkInlineContent,
  fs as isPartialTableCell,
  Ur as isSafari,
  hs as isStyledTextInlineContent,
  ms as isTableCell,
  zr as isTableCellSelection,
  Ye as isVideoUrl,
  ks as mapTableCell,
  Zn as mappingFactory,
  Co as markdownToBlocks,
  ve as markdownToHTML,
  Q as mergeCSSClasses,
  Gr as mergeParagraphs,
  b as nodeToBlock,
  U as nodeToCustomInlineContent,
  Rr as parseAudioElement,
  jr as parseDefaultProps,
  Ke as propsToAttributes,
  je as prosemirrorSliceToSlicedBlocks,
  ie as removeAndInsertBlocks,
  qt as removeEmptyColumns,
  Ae as selectedFragmentToHTML,
  Wr as stylePropsToAttributes,
  Ue as tableContentToNodes,
  Kr as tablePropSchema,
  Jr as trackPosition,
  qe as updateBlock,
  Ze as updateBlockCommand,
  tt as updateBlockTr,
  ni as uploadToTmpFilesDotOrg_DEV_ONLY,
  qr as videoParse,
  si as withPageBreak,
  Yr as wrapInBlockStructure
};
//# sourceMappingURL=blocknote.js.map
