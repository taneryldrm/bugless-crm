var Oe = Object.defineProperty;
var _e = (e, t, n) => t in e ? Oe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var M = (e, t, n) => _e(e, typeof t != "symbol" ? t + "" : t, n);
import { TableMap as be, goToNextCell as ne, columnResizing as Ve, tableEditing as Re, CellSelection as Ce, TableView as We } from "prosemirror-tables";
import { Node as N, Mark as Fe, Extension as $e, callOrReturn as Ue, getExtensionField as qe, mergeAttributes as z, findParentNode as je } from "@tiptap/core";
import { TextSelection as ke, Plugin as Ge, PluginKey as Ze } from "prosemirror-state";
import { DecorationSet as oe, Decoration as re } from "prosemirror-view";
import { ReplaceStep as ze, Mapping as Xe } from "prosemirror-transform";
import { ySyncPluginKey as ae, absolutePositionToRelativePosition as Ke, relativePositionToAbsolutePosition as Qe } from "y-prosemirror";
import { c as k, a as ye } from "./BlockNoteExtension-C2X7LW-V.js";
import { b as X, v as Je, g as O, a as ve, i as se, t as Ye, U as et, q as tt, A as G, r as nt, w as Ee, J as ot } from "./blockToNode-BNoNIXU7.js";
import rt from "@tiptap/extension-bold";
import at from "@tiptap/extension-code";
import st from "@tiptap/extension-italic";
import it from "@tiptap/extension-strike";
import ct from "@tiptap/extension-underline";
import { DOMParser as xe, Fragment as lt, DOMSerializer as ie } from "@tiptap/pm/model";
import { createHighlightPlugin as dt } from "prosemirror-highlight";
import { createParser as ut } from "prosemirror-highlight/shiki";
import { Slice as we, Fragment as F, DOMParser as Se } from "prosemirror-model";
import { Plugin as pt, PluginKey as ft } from "@tiptap/pm/state";
import { DecorationSet as ce, Decoration as ht } from "@tiptap/pm/view";
const mt = () => typeof navigator < "u" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent));
function L(e, t = "Ctrl") {
  return mt() ? e.replace("Mod", "âŒ˜") : e.replace("Mod", t);
}
function D(...e) {
  return [
    // Converts to & from set to remove duplicates.
    ...new Set(
      e.filter((t) => t).join(" ").split(" ")
    )
  ].join(" ");
}
const uo = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
function gt(e, t, n, o) {
  const r = document.createElement("div");
  r.className = D(
    "bn-block-content",
    n.class
  ), r.setAttribute("data-content-type", e);
  for (const [s, i] of Object.entries(n))
    s !== "class" && r.setAttribute(s, i);
  const a = document.createElement(t);
  a.className = D(
    "bn-inline-content",
    o.class
  );
  for (const [s, i] of Object.entries(
    o
  ))
    s !== "class" && a.setAttribute(s, i);
  return r.appendChild(a), {
    dom: r,
    contentDOM: a
  };
}
const le = (e, t) => {
  let n = X(e, t.pmSchema);
  n.type.name === "blockContainer" && (n = n.firstChild);
  const o = t.pmSchema.nodes[n.type.name].spec.toDOM;
  if (o === void 0)
    throw new Error(
      "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
    );
  const r = o(n);
  if (typeof r != "object" || !("dom" in r))
    throw new Error(
      "Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property."
    );
  return r;
};
function bt(e, t = "<br>") {
  const n = e.querySelectorAll("p");
  if (n.length > 1) {
    const o = n[0];
    for (let r = 1; r < n.length; r++) {
      const a = n[r];
      o.innerHTML += t + a.innerHTML, a.remove();
    }
  }
}
function W(e) {
  return "data-" + e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function po(e) {
  const t = e.split("/");
  return !t.length || // invalid?
  t[t.length - 1] === "" ? e : t[t.length - 1];
}
function fo(e) {
  var n;
  const t = [
    "mp4",
    "webm",
    "ogg",
    "mov",
    "mkv",
    "flv",
    "avi",
    "wmv",
    "m4v"
  ];
  try {
    const r = ((n = new URL(e).pathname.split(".").pop()) == null ? void 0 : n.toLowerCase()) || "";
    return t.includes(r);
  } catch {
    return !1;
  }
}
function Ct(e) {
  const t = {};
  return Object.entries(e).forEach(([n, o]) => {
    t[n] = {
      default: o.default,
      keepOnSplit: !0,
      // Props are displayed in kebab-case as HTML attributes. If a prop's
      // value is the same as its default, we don't display an HTML
      // attribute for it.
      parseHTML: (r) => {
        const a = r.getAttribute(W(n));
        if (a === null)
          return null;
        if (o.default === void 0 && o.type === "boolean" || o.default !== void 0 && typeof o.default == "boolean")
          return a === "true" ? !0 : a === "false" ? !1 : null;
        if (o.default === void 0 && o.type === "number" || o.default !== void 0 && typeof o.default == "number") {
          const s = parseFloat(a);
          return !Number.isNaN(s) && Number.isFinite(s) ? s : null;
        }
        return a;
      },
      renderHTML: (r) => r[n] !== o.default ? {
        [W(n)]: r[n]
      } : {}
    };
  }), t;
}
function kt(e, t, n, o) {
  const r = e();
  if (r === void 0)
    throw new Error("Cannot find node position");
  const s = n.state.doc.resolve(r).node().attrs.id;
  if (!s)
    throw new Error("Block doesn't have id");
  const i = t.getBlock(s);
  if (i.type !== o)
    throw new Error("Block type does not match");
  return i;
}
function Z(e, t, n, o, r = !1, a) {
  const s = document.createElement("div");
  if (a !== void 0)
    for (const [i, c] of Object.entries(a))
      i !== "class" && s.setAttribute(i, c);
  s.className = D(
    "bn-block-content",
    (a == null ? void 0 : a.class) || ""
  ), s.setAttribute("data-content-type", t);
  for (const [i, c] of Object.entries(n)) {
    const u = o[i].default;
    c !== u && s.setAttribute(W(i), c);
  }
  return r && s.setAttribute("data-file-block", ""), s.appendChild(e.dom), e.contentDOM && (e.contentDOM.className = D(
    "bn-inline-content",
    e.contentDOM.className
  )), {
    ...e,
    dom: s
  };
}
function yt(e, t, n) {
  return {
    config: {
      type: e.type,
      content: e.content,
      propSchema: t
    },
    implementation: {
      node: e.node,
      render: le,
      toExternalHTML: le
    },
    extensions: n
  };
}
function vt(e, t) {
  e.stopEvent = (n) => (n.type === "mousedown" && setTimeout(() => {
    t.view.dom.blur();
  }, 10), !0);
}
function Et(e, t) {
  const n = [
    {
      tag: "[data-content-type=" + e.type + "]",
      contentElement: ".bn-inline-content"
    }
  ];
  return t.parse && n.push({
    tag: "*",
    getAttrs(o) {
      var a;
      if (typeof o == "string")
        return !1;
      const r = (a = t.parse) == null ? void 0 : a.call(t, o);
      return r === void 0 ? !1 : r;
    },
    // Because we do the parsing ourselves, we want to preserve whitespace for content we've parsed
    preserveWhitespace: !0,
    getContent: e.content === "inline" || e.content === "none" ? (o, r) => {
      var a;
      if (t.parseContent)
        return t.parseContent({
          el: o,
          schema: r
        });
      if (e.content === "inline") {
        const i = o.cloneNode(!0);
        return bt(
          i,
          (a = t.meta) != null && a.code ? `
` : "<br>"
        ), xe.fromSchema(r).parse(i, {
          topNode: r.nodes.paragraph.create(),
          preserveWhitespace: !0
        }).content;
      }
      return lt.empty;
    } : void 0
  }), n;
}
function ho(e, t, n, o) {
  var a, s, i, c;
  const r = t.node || N.create({
    name: e.type,
    content: e.content === "inline" ? "inline*" : e.content === "none" ? "" : e.content,
    group: "blockContent",
    selectable: ((a = t.meta) == null ? void 0 : a.selectable) ?? !0,
    isolating: ((s = t.meta) == null ? void 0 : s.isolating) ?? !0,
    code: ((i = t.meta) == null ? void 0 : i.code) ?? !1,
    defining: ((c = t.meta) == null ? void 0 : c.defining) ?? !0,
    priority: o,
    addAttributes() {
      return Ct(e.propSchema);
    },
    parseHTML() {
      return Et(e, t);
    },
    renderHTML({ HTMLAttributes: l }) {
      var d;
      const u = document.createElement("div");
      return Z(
        {
          dom: u,
          contentDOM: e.content === "inline" ? u : void 0
        },
        e.type,
        {},
        e.propSchema,
        ((d = t.meta) == null ? void 0 : d.fileBlockAccept) !== void 0,
        l
      );
    },
    addNodeView() {
      return (l) => {
        var f, E;
        const u = this.options.editor, d = kt(
          l.getPos,
          u,
          this.editor,
          e.type
        ), p = ((f = this.options.domAttributes) == null ? void 0 : f.blockContent) || {}, m = t.render.call(
          { blockContentDOMAttributes: p, props: l, renderType: "nodeView" },
          d,
          u
        );
        return ((E = t.meta) == null ? void 0 : E.selectable) === !1 && vt(m, this.editor), m;
      };
    }
  });
  if (r.name !== e.type)
    throw new Error(
      "Node name does not match block type. This is a bug in BlockNote."
    );
  return {
    config: e,
    implementation: {
      ...t,
      node: r,
      render(l, u) {
        var p;
        const d = ((p = r.options.domAttributes) == null ? void 0 : p.blockContent) || {};
        return t.render.call(
          {
            blockContentDOMAttributes: d,
            props: void 0,
            renderType: "dom"
          },
          l,
          u
        );
      },
      // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
      // post-processing in externalHTMLExporter should not be necessary
      toExternalHTML: (l, u) => {
        var p, m;
        const d = ((p = r.options.domAttributes) == null ? void 0 : p.blockContent) || {};
        return ((m = t.toExternalHTML) == null ? void 0 : m.call(
          { blockContentDOMAttributes: d },
          l,
          u
        )) ?? t.render.call(
          { blockContentDOMAttributes: d, renderType: "dom", props: void 0 },
          l,
          u
        );
      }
    },
    extensions: n
  };
}
function mo(e) {
  return e;
}
function v(e, t, n) {
  return (o = {}) => {
    const r = typeof e == "function" ? e(o) : e, a = typeof t == "function" ? t(o) : t, s = n ? typeof n == "function" ? n(o) : n : void 0;
    return {
      config: r,
      implementation: {
        ...a,
        // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
        // post-processing in externalHTMLExporter should not be necessary
        toExternalHTML(i, c) {
          var u, d;
          const l = (u = a.toExternalHTML) == null ? void 0 : u.call(
            { blockContentDOMAttributes: this.blockContentDOMAttributes },
            i,
            c
          );
          if (l !== void 0)
            return Z(
              l,
              i.type,
              i.props,
              r.propSchema,
              ((d = a.meta) == null ? void 0 : d.fileBlockAccept) !== void 0
            );
        },
        render(i, c) {
          var d;
          const l = a.render.call(
            {
              blockContentDOMAttributes: this.blockContentDOMAttributes,
              renderType: this.renderType,
              props: this.props
            },
            i,
            c
          );
          return Z(
            l,
            i.type,
            i.props,
            r.propSchema,
            ((d = a.meta) == null ? void 0 : d.fileBlockAccept) !== void 0,
            this.blockContentDOMAttributes
          );
        }
      },
      extensions: s
    };
  };
}
function go(e, t, n, o) {
  return e.dom.setAttribute("data-inline-content-type", t), Object.entries(n).filter(([r, a]) => {
    const s = o[r];
    return a !== s.default;
  }).map(([r, a]) => [W(r), a]).forEach(([r, a]) => e.dom.setAttribute(r, a)), e.contentDOM && e.contentDOM.setAttribute("data-editable", ""), e;
}
function bo(e) {
  return {
    Backspace: ({ editor: t }) => {
      const n = t.state.selection.$from;
      return t.state.selection.empty && n.node().type.name === e.type && n.parentOffset === 0;
    }
  };
}
function xt(e, t) {
  return {
    config: e,
    implementation: t
  };
}
function Co(e, t, n) {
  return xt(
    {
      type: e.name,
      propSchema: t,
      content: e.config.content === "inline*" ? "styled" : "none"
    },
    {
      ...n,
      node: e
    }
  );
}
function wt(e) {
  return Object.fromEntries(
    Object.entries(e).map(([t, n]) => [t, n.config])
  );
}
function St(e) {
  return e === "boolean" ? {} : {
    stringValue: {
      default: void 0,
      keepOnSplit: !0,
      parseHTML: (t) => t.getAttribute("data-value"),
      renderHTML: (t) => t.stringValue !== void 0 ? {
        "data-value": t.stringValue
      } : {}
    }
  };
}
function V(e, t, n, o) {
  return e.dom.setAttribute("data-style-type", t), o === "string" && e.dom.setAttribute("data-value", n), e.contentDOM && e.contentDOM.setAttribute("data-editable", ""), e;
}
function Me(e, t) {
  return {
    config: e,
    implementation: t
  };
}
function H(e, t) {
  return Me(
    {
      type: e.name,
      propSchema: t
    },
    {
      mark: e,
      render(n, o) {
        const r = o.pmSchema.marks[e.name].spec.toDOM;
        if (r === void 0)
          throw new Error(
            "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
          );
        const a = o.pmSchema.mark(e.name, {
          stringValue: n
        }), s = ie.renderSpec(
          document,
          r(a, !0)
        );
        if (typeof s != "object" || !("dom" in s))
          throw new Error(
            "Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property."
          );
        return s;
      },
      toExternalHTML(n, o) {
        const r = o.pmSchema.marks[e.name].spec.toDOM;
        if (r === void 0)
          throw new Error(
            "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
          );
        const a = o.pmSchema.mark(e.name, {
          stringValue: n
        }), s = ie.renderSpec(
          document,
          r(a, !0)
        );
        if (typeof s != "object" || !("dom" in s))
          throw new Error(
            "Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property."
          );
        return s;
      }
    }
  );
}
function Mt(e) {
  return Object.fromEntries(
    Object.entries(e).map(([t, n]) => [t, n.config])
  );
}
function Lt(e, t) {
  const n = [
    {
      tag: `[data-style-type="${e.type}"]`,
      contentElement: (o) => {
        const r = o;
        return r.matches("[data-editable]") ? r : r.querySelector("[data-editable]") || r;
      }
    }
  ];
  return t && n.push({
    tag: "*",
    // By default, styles can overlap each other, so the rules should not
    // completely consume the element they parse (which can have multiple
    // styles).
    consuming: !1,
    getAttrs(o) {
      if (typeof o == "string")
        return !1;
      const r = t == null ? void 0 : t(o);
      return r === void 0 ? !1 : { stringValue: r };
    }
  }), n;
}
function Le(e, t) {
  const n = Fe.create({
    name: e.type,
    addAttributes() {
      return St(e.propSchema);
    },
    parseHTML() {
      return Lt(e, t.parse);
    },
    renderHTML({ mark: o }) {
      const r = (t.toExternalHTML || t.render)(o.attrs.stringValue);
      return V(
        r,
        e.type,
        o.attrs.stringValue,
        e.propSchema
      );
    },
    addMarkView() {
      return ({ mark: o }) => {
        const r = t.render(o.attrs.stringValue);
        return V(
          r,
          e.type,
          o.attrs.stringValue,
          e.propSchema
        );
      };
    }
  });
  return Me(e, {
    ...t,
    mark: n,
    render: (o) => {
      const r = t.render(o);
      return V(
        r,
        e.type,
        o,
        e.propSchema
      );
    },
    toExternalHTML: (o) => {
      const r = (t.toExternalHTML || t.render)(o);
      return V(
        r,
        e.type,
        o,
        e.propSchema
      );
    }
  });
}
function Tt(e, t) {
  let n, o;
  if (t.firstChild.descendants((r, a) => n ? !1 : !Bt(r) || r.attrs.id !== e ? !0 : (n = r, o = a + 1, !1)), !(n === void 0 || o === void 0))
    return {
      node: n,
      posBeforeNode: o
    };
}
function Bt(e) {
  return e.type.isInGroup("bnBlock");
}
const ko = (e, t) => ({
  tr: n,
  dispatch: o
}) => (o && K(n, e, t), !0);
function K(e, t, n, o, r) {
  const a = Je(e.doc.resolve(t));
  let s = null;
  a.blockNoteType === "table" && (s = Pt(e));
  const i = O(e);
  if (o !== void 0 && r !== void 0 && o > r)
    throw new Error("Invalid replaceFromPos or replaceToPos");
  const c = i.nodes[a.blockNoteType], l = i.nodes[n.type || a.blockNoteType], u = l.isInGroup("bnBlock") ? l : i.nodes.blockContainer;
  if (a.isBlockContainer && l.isInGroup("blockContent")) {
    const d = o !== void 0 && o > a.blockContent.beforePos && o < a.blockContent.afterPos ? o - a.blockContent.beforePos - 1 : void 0, p = r !== void 0 && r > a.blockContent.beforePos && r < a.blockContent.afterPos ? r - a.blockContent.beforePos - 1 : void 0;
    de(n, e, a), At(
      n,
      e,
      c,
      l,
      a,
      d,
      p
    );
  } else if (!a.isBlockContainer && l.isInGroup("bnBlock"))
    de(n, e, a);
  else {
    const d = ve(a.bnBlock.node, i);
    e.replaceWith(
      a.bnBlock.beforePos,
      a.bnBlock.afterPos,
      X(
        {
          children: d.children,
          // if no children are passed in, use existing children
          ...n
        },
        i
      )
    );
    return;
  }
  e.setNodeMarkup(a.bnBlock.beforePos, u, {
    ...a.bnBlock.node.attrs,
    ...n.props
  }), s && Nt(e, a, s);
}
function At(e, t, n, o, r, a, s) {
  const i = O(t);
  let c = "keep";
  if (e.content)
    if (typeof e.content == "string")
      c = se(
        [e.content],
        i,
        o.name
      );
    else if (Array.isArray(e.content))
      c = se(e.content, i, o.name);
    else if (e.content.type === "tableContent")
      c = Ye(e.content, i);
    else
      throw new et(e.content.type);
  else
    n.spec.content === "" || o.spec.content !== n.spec.content && (c = []);
  if (c === "keep")
    t.setNodeMarkup(r.blockContent.beforePos, o, {
      ...r.blockContent.node.attrs,
      ...e.props
    });
  else if (a !== void 0 || s !== void 0) {
    t.setNodeMarkup(r.blockContent.beforePos, o, {
      ...r.blockContent.node.attrs,
      ...e.props
    });
    const l = r.blockContent.beforePos + 1 + (a ?? 0), u = r.blockContent.beforePos + 1 + (s ?? r.blockContent.node.content.size), d = t.doc.resolve(r.blockContent.beforePos).depth, p = t.doc.resolve(l).depth, m = t.doc.resolve(u).depth;
    t.replace(
      l,
      u,
      new we(
        F.from(c),
        p - d - 1,
        m - d - 1
      )
    );
  } else
    t.replaceWith(
      r.blockContent.beforePos,
      r.blockContent.afterPos,
      o.createChecked(
        {
          ...r.blockContent.node.attrs,
          ...e.props
        },
        c
      )
    );
}
function de(e, t, n) {
  const o = O(t);
  if (e.children !== void 0 && e.children.length > 0) {
    const r = e.children.map((a) => X(a, o));
    if (n.childContainer)
      t.step(
        new ze(
          n.childContainer.beforePos + 1,
          n.childContainer.afterPos - 1,
          new we(F.from(r), 0, 0)
        )
      );
    else {
      if (!n.isBlockContainer)
        throw new Error("impossible");
      t.insert(
        n.blockContent.afterPos,
        o.nodes.blockGroup.createChecked({}, r)
      );
    }
  }
}
function yo(e, t, n, o, r) {
  const a = typeof t == "string" ? t : t.id, s = Tt(a, e.doc);
  if (!s)
    throw new Error(`Block with ID ${a} not found`);
  K(
    e,
    s.posBeforeNode,
    n,
    o,
    r
  );
  const i = e.doc.resolve(s.posBeforeNode + 1).node(), c = O(e);
  return ve(i, c);
}
function Pt(e) {
  const t = "selection" in e ? e.selection : null;
  if (!(t instanceof ke))
    return null;
  const n = e.doc.resolve(t.head);
  let o = -1, r = -1;
  for (let w = n.depth; w >= 0; w--) {
    const x = n.node(w).type.name;
    if (o < 0 && (x === "tableCell" || x === "tableHeader") && (o = w), x === "table") {
      r = w;
      break;
    }
  }
  if (o < 0 || r < 0)
    return null;
  const a = n.before(o), s = n.before(r), i = e.doc.nodeAt(s);
  if (!i || i.type.name !== "table")
    return null;
  const c = be.get(i), l = a - (s + 1), u = c.map.indexOf(l);
  if (u < 0)
    return null;
  const d = Math.floor(u / c.width), p = u % c.width, f = a + 1 + 1, E = Math.max(0, t.head - f);
  return { row: d, col: p, offset: E };
}
function Nt(e, t, n) {
  var w;
  if (t.blockNoteType !== "table")
    return !1;
  let o = -1;
  if (t.isBlockContainer)
    o = e.mapping.map(t.blockContent.beforePos);
  else {
    const x = e.mapping.map(t.bnBlock.beforePos), P = x + (((w = e.doc.nodeAt(x)) == null ? void 0 : w.nodeSize) || 0);
    e.doc.nodesBetween(x, P, (g, S) => g.type.name === "table" ? (o = S, !1) : !0);
  }
  const r = o >= 0 ? e.doc.nodeAt(o) : null;
  if (!r || r.type.name !== "table")
    return !1;
  const a = be.get(r), s = Math.max(0, Math.min(n.row, a.height - 1)), i = Math.max(0, Math.min(n.col, a.width - 1)), c = s * a.width + i, l = a.map[c];
  if (l == null)
    return !1;
  const d = o + 1 + l + 1, p = e.doc.nodeAt(d), m = d + 1, f = p ? p.content.size : 0, E = m + Math.max(0, Math.min(n.offset, f));
  return "selection" in e && e.setSelection(ke.create(e.doc, E)), !0;
}
const T = {
  gray: {
    text: "#9b9a97",
    background: "#ebeced"
  },
  brown: {
    text: "#64473a",
    background: "#e9e5e3"
  },
  red: {
    text: "#e03e3e",
    background: "#fbe4e4"
  },
  orange: {
    text: "#d9730d",
    background: "#f6e9d9"
  },
  yellow: {
    text: "#dfab01",
    background: "#fbf3db"
  },
  green: {
    text: "#4d6461",
    background: "#ddedea"
  },
  blue: {
    text: "#0b6e99",
    background: "#ddebf1"
  },
  purple: {
    text: "#6940a5",
    background: "#eae4f2"
  },
  pink: {
    text: "#ad1a72",
    background: "#f4dfeb"
  }
}, vo = {
  gray: {
    text: "#bebdb8",
    background: "#9b9a97"
  },
  brown: {
    text: "#8e6552",
    background: "#64473a"
  },
  red: {
    text: "#ec4040",
    background: "#be3434"
  },
  orange: {
    text: "#e3790d",
    background: "#b7600a"
  },
  yellow: {
    text: "#dfab01",
    background: "#b58b00"
  },
  green: {
    text: "#6b8b87",
    background: "#4d6461"
  },
  blue: {
    text: "#0e87bc",
    background: "#0b6e99"
  },
  purple: {
    text: "#8552d7",
    background: "#6940a5"
  },
  pink: {
    text: "#da208f",
    background: "#ad1a72"
  }
}, h = {
  backgroundColor: {
    default: "default"
  },
  textColor: {
    default: "default"
  },
  textAlignment: {
    default: "left",
    values: ["left", "center", "right", "justify"]
  }
}, y = (e) => {
  const t = {};
  return e.hasAttribute("data-background-color") ? t.backgroundColor = e.getAttribute("data-background-color") : e.style.backgroundColor && (t.backgroundColor = e.style.backgroundColor), e.hasAttribute("data-text-color") ? t.textColor = e.getAttribute("data-text-color") : e.style.color && (t.textColor = e.style.color), t.textAlignment = h.textAlignment.values.includes(
    e.style.textAlign
  ) ? e.style.textAlign : void 0, t;
}, A = (e, t) => {
  e.backgroundColor && e.backgroundColor !== h.backgroundColor.default && (t.style.backgroundColor = e.backgroundColor in T ? T[e.backgroundColor].background : e.backgroundColor), e.textColor && e.textColor !== h.textColor.default && (t.style.color = e.textColor in T ? T[e.textColor].text : e.textColor), e.textAlignment && e.textAlignment !== h.textAlignment.default && (t.style.textAlign = e.textAlignment);
}, Eo = (e = "backgroundColor") => ({
  default: h.backgroundColor.default,
  parseHTML: (t) => t.hasAttribute("data-background-color") ? t.getAttribute("data-background-color") : t.style.backgroundColor ? t.style.backgroundColor : h.backgroundColor.default,
  renderHTML: (t) => t[e] === h.backgroundColor.default ? {} : {
    "data-background-color": t[e]
  }
}), xo = (e = "textColor") => ({
  default: h.textColor.default,
  parseHTML: (t) => t.hasAttribute("data-text-color") ? t.getAttribute("data-text-color") : t.style.color ? t.style.color : h.textColor.default,
  renderHTML: (t) => t[e] === h.textColor.default ? {} : {
    "data-text-color": t[e]
  }
}), wo = (e = "textAlignment") => ({
  default: h.textAlignment.default,
  parseHTML: (t) => t.hasAttribute("data-text-alignment") ? t.getAttribute("data-text-alignment") : t.style.textAlign ? t.style.textAlign : h.textAlignment.default,
  renderHTML: (t) => t[e] === h.textAlignment.default ? {} : {
    "data-text-alignment": t[e]
  }
}), $ = (e, t) => {
  const n = e.querySelector(
    t
  );
  if (!n)
    return;
  const o = e.querySelector("figcaption"), r = (o == null ? void 0 : o.textContent) ?? void 0;
  return { targetElement: n, caption: r };
}, I = k(({ editor: e }) => {
  const t = ye(void 0);
  function n() {
    t.setState(void 0);
  }
  return {
    key: "filePanel",
    store: t,
    mount({ signal: o }) {
      const r = e.onChange(
        n,
        // Don't trigger if the changes are caused by a remote user.
        !1
      ), a = e.onSelectionChange(
        n,
        // Don't trigger if the changes are caused by a remote user.
        !1
      );
      o.addEventListener("abort", () => {
        r(), a();
      });
    },
    closeMenu: n,
    showMenu(o) {
      t.setState(o);
    }
  };
}), Ht = (e, t, n) => {
  const o = document.createElement("div");
  o.className = "bn-add-file-button";
  const r = document.createElement("div");
  r.className = "bn-add-file-button-icon", n ? r.appendChild(n) : r.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', o.appendChild(r);
  const a = document.createElement("p");
  a.className = "bn-add-file-button-text", a.innerHTML = e.type in t.dictionary.file_blocks.add_button_text ? t.dictionary.file_blocks.add_button_text[e.type] : t.dictionary.file_blocks.add_button_text.file, o.appendChild(a);
  const s = (c) => {
    c.preventDefault(), c.stopPropagation();
  }, i = () => {
    var c;
    t.isEditable && ((c = t.getExtension(I)) == null || c.showMenu(e.id));
  };
  return o.addEventListener(
    "mousedown",
    s,
    !0
  ), o.addEventListener("click", i, !0), {
    dom: o,
    destroy: () => {
      o.removeEventListener(
        "mousedown",
        s,
        !0
      ), o.removeEventListener(
        "click",
        i,
        !0
      );
    }
  };
}, It = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', Dt = (e) => {
  const t = document.createElement("div");
  t.className = "bn-file-name-with-icon";
  const n = document.createElement("div");
  n.className = "bn-file-icon", n.innerHTML = It, t.appendChild(n);
  const o = document.createElement("p");
  return o.className = "bn-file-name", o.textContent = e.props.name, t.appendChild(o), {
    dom: t
  };
}, Q = (e, t, n, o) => {
  const r = document.createElement("div");
  if (r.className = "bn-file-block-content-wrapper", e.props.url === "") {
    const s = Ht(e, t, o);
    r.appendChild(s.dom);
    const i = t.onUploadStart((c) => {
      if (c === e.id) {
        r.removeChild(s.dom);
        const l = document.createElement("div");
        l.className = "bn-file-loading-preview", l.textContent = "Loading...", r.appendChild(l);
      }
    });
    return {
      dom: r,
      destroy: () => {
        i(), s.destroy();
      }
    };
  }
  const a = { dom: r };
  if (e.props.showPreview === !1 || !n) {
    const s = Dt(e);
    r.appendChild(s.dom), a.destroy = () => {
      var i;
      (i = s.destroy) == null || i.call(s);
    };
  } else
    r.appendChild(n.dom);
  if (e.props.caption) {
    const s = document.createElement("p");
    s.className = "bn-file-caption", s.textContent = e.props.caption, r.appendChild(s);
  }
  return a;
}, J = (e, t) => {
  const n = document.createElement("figure"), o = document.createElement("figcaption");
  return o.textContent = t, n.appendChild(e), n.appendChild(o), { dom: n };
}, U = (e, t) => {
  const n = document.createElement("div"), o = document.createElement("p");
  return o.textContent = t, n.appendChild(e), n.appendChild(o), {
    dom: n
  };
}, ue = (e) => ({ url: e.src || void 0 }), Ot = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z"></path></svg>', _t = (e) => ({
  type: "audio",
  propSchema: {
    backgroundColor: h.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: !0
    }
  },
  content: "none"
}), Vt = (e = {}) => (t) => {
  if (t.tagName === "AUDIO") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = y(t);
    return {
      ...ue(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = $(t, "audio");
    if (!n)
      return;
    const { targetElement: o, caption: r } = n, { backgroundColor: a } = y(t);
    return {
      ...ue(o),
      backgroundColor: a,
      caption: r
    };
  }
}, Rt = (e = {}) => (t, n) => {
  const o = document.createElement("div");
  o.innerHTML = e.icon ?? Ot;
  const r = document.createElement("audio");
  return r.className = "bn-audio", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((a) => {
    r.src = a;
  }) : r.src = t.props.url, r.controls = !0, r.contentEditable = "false", r.draggable = !1, Q(
    t,
    n,
    { dom: r },
    o.firstElementChild
  );
}, Wt = (e = {}) => (t, n) => {
  if (!t.props.url) {
    const r = document.createElement("p");
    return r.textContent = "Add audio", {
      dom: r
    };
  }
  let o;
  return t.props.showPreview ? (o = document.createElement("audio"), o.src = t.props.url) : (o = document.createElement("a"), o.href = t.props.url, o.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? J(o, t.props.caption) : U(o, t.props.caption) : {
    dom: o
  };
}, Ft = v(
  _t,
  (e) => ({
    meta: {
      fileBlockAccept: ["audio/*"]
    },
    parse: Vt(e),
    render: Rt(e),
    toExternalHTML: Wt(e),
    runsBefore: ["file"]
  })
), pe = Symbol.for("blocknote.shikiParser"), j = Symbol.for(
  "blocknote.shikiHighlighterPromise"
);
function $t(e) {
  const t = globalThis;
  let n, o, r = !1;
  return dt({
    parser: (s) => {
      if (!e.createHighlighter)
        return process.env.NODE_ENV === "development" && !r && (console.log(
          "For syntax highlighting of code blocks, you must provide a `createCodeBlockSpec({ createHighlighter: () => ... })` function"
        ), r = !0), [];
      if (!n)
        return t[j] = t[j] || e.createHighlighter(), t[j].then(
          (c) => {
            n = c;
          }
        );
      const i = Te(e, s.language);
      return !i || i === "text" || i === "none" || i === "plaintext" || i === "txt" ? [] : n.getLoadedLanguages().includes(i) ? (o || (o = t[pe] || ut(n), t[pe] = o), o(s)) : n.loadLanguage(i);
    },
    languageExtractor: (s) => s.attrs.language,
    nodeTypes: ["codeBlock"]
  });
}
const Ut = ({ defaultLanguage: e = "text" }) => ({
  type: "codeBlock",
  propSchema: {
    language: {
      default: e
    }
  },
  content: "inline"
}), qt = v(
  Ut,
  (e) => ({
    meta: {
      code: !0,
      defining: !0,
      isolating: !1
    },
    parse: (t) => {
      var r, a;
      if (t.tagName !== "PRE" || t.childElementCount !== 1 || ((r = t.firstElementChild) == null ? void 0 : r.tagName) !== "CODE")
        return;
      const n = t.firstElementChild;
      return { language: n.getAttribute("data-language") || ((a = n.className.split(" ").find((s) => s.includes("language-"))) == null ? void 0 : a.replace("language-", "")) };
    },
    parseContent: ({ el: t, schema: n }) => {
      const o = xe.fromSchema(n), r = t.firstElementChild;
      return o.parse(r, {
        preserveWhitespace: "full",
        topNode: n.nodes.codeBlock.create()
      }).content;
    },
    render(t, n) {
      const o = document.createDocumentFragment(), r = document.createElement("pre"), a = document.createElement("code");
      r.appendChild(a);
      let s;
      if (e.supportedLanguages) {
        const i = document.createElement("select");
        Object.entries(e.supportedLanguages ?? {}).forEach(
          ([u, { name: d }]) => {
            const p = document.createElement("option");
            p.value = u, p.text = d, i.appendChild(p);
          }
        ), i.value = t.props.language || e.defaultLanguage || "text";
        const c = (u) => {
          const d = u.target.value;
          n.updateBlock(t.id, { props: { language: d } });
        };
        i.addEventListener("change", c), s = () => i.removeEventListener("change", c);
        const l = document.createElement("div");
        l.contentEditable = "false", l.appendChild(i), o.appendChild(l);
      }
      return o.appendChild(r), {
        dom: o,
        contentDOM: a,
        destroy: () => {
          s == null || s();
        }
      };
    },
    toExternalHTML(t) {
      const n = document.createElement("pre"), o = document.createElement("code");
      return o.className = `language-${t.props.language}`, o.dataset.language = t.props.language, n.appendChild(o), {
        dom: n,
        contentDOM: o
      };
    }
  }),
  (e) => [
    k({
      key: "code-block-highlighter",
      prosemirrorPlugins: [$t(e)]
    }),
    k({
      key: "code-block-keyboard-shortcuts",
      keyboardShortcuts: {
        Delete: ({ editor: t }) => t.transact((n) => {
          const { block: o } = t.getTextCursorPosition();
          if (o.type !== "codeBlock")
            return !1;
          const { $from: r } = n.selection;
          return r.parent.textContent ? !1 : (t.removeBlocks([o]), !0);
        }),
        Tab: ({ editor: t }) => e.indentLineWithTab === !1 ? !1 : t.transact((n) => {
          const { block: o } = t.getTextCursorPosition();
          return o.type === "codeBlock" ? (n.insertText("  "), !0) : !1;
        }),
        Enter: ({ editor: t }) => t.transact((n) => {
          const { block: o, nextBlock: r } = t.getTextCursorPosition();
          if (o.type !== "codeBlock")
            return !1;
          const { $from: a } = n.selection, s = a.parentOffset === a.parent.nodeSize - 2, i = a.parent.textContent.endsWith(`

`);
          if (s && i) {
            if (n.delete(a.pos - 2, a.pos), r)
              return t.setTextCursorPosition(r, "start"), !0;
            const [c] = t.insertBlocks(
              [{ type: "paragraph" }],
              o,
              "after"
            );
            return t.setTextCursorPosition(c, "start"), !0;
          }
          return n.insertText(`
`), !0;
        }),
        "Shift-Enter": ({ editor: t }) => t.transact(() => {
          const { block: n } = t.getTextCursorPosition();
          if (n.type !== "codeBlock")
            return !1;
          const [o] = t.insertBlocks(
            // insert a new paragraph
            [{ type: "paragraph" }],
            n,
            "after"
          );
          return t.setTextCursorPosition(o, "start"), !0;
        })
      },
      inputRules: [
        {
          find: /^```(.*?)\s$/,
          replace: ({ match: t }) => {
            const n = t[1].trim();
            return {
              type: "codeBlock",
              props: {
                language: {
                  language: Te(e, n) ?? n
                }.language
              },
              content: []
            };
          }
        }
      ]
    })
  ]
);
function Te(e, t) {
  var n;
  return (n = Object.entries(e.supportedLanguages ?? {}).find(
    ([o, { aliases: r }]) => (r == null ? void 0 : r.includes(t)) || o === t
  )) == null ? void 0 : n[0];
}
const jt = () => ({
  type: "divider",
  propSchema: {},
  content: "none"
}), Gt = v(
  jt,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      if (e.tagName === "HR")
        return {};
    },
    render() {
      return {
        dom: document.createElement("hr")
      };
    }
  },
  [
    k({
      key: "divider-block-shortcuts",
      inputRules: [
        {
          find: new RegExp("^---$"),
          replace() {
            return { type: "divider", props: {}, content: [] };
          }
        }
      ]
    })
  ]
), fe = (e) => ({ url: e.src || void 0 }), Zt = () => ({
  type: "file",
  propSchema: {
    backgroundColor: h.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    }
  },
  content: "none"
}), zt = () => (e) => {
  if (e.tagName === "EMBED") {
    if (e.closest("figure"))
      return;
    const { backgroundColor: t } = y(e);
    return {
      ...fe(e),
      backgroundColor: t
    };
  }
  if (e.tagName === "FIGURE") {
    const t = $(e, "embed");
    if (!t)
      return;
    const { targetElement: n, caption: o } = t, { backgroundColor: r } = y(e);
    return {
      ...fe(n),
      backgroundColor: r,
      caption: o
    };
  }
}, Xt = v(Zt, {
  meta: {
    fileBlockAccept: ["*/*"]
  },
  parse: zt(),
  render(e, t) {
    return Q(e, t);
  },
  toExternalHTML(e) {
    if (!e.props.url) {
      const n = document.createElement("p");
      return n.textContent = "Add file", {
        dom: n
      };
    }
    const t = document.createElement("a");
    return t.href = e.props.url, t.textContent = e.props.name || e.props.url, e.props.caption ? U(t, e.props.caption) : {
      dom: t
    };
  }
}), Kt = {
  set: (e, t) => window.localStorage.setItem(
    `toggle-${e.id}`,
    t ? "true" : "false"
  ),
  get: (e) => window.localStorage.getItem(`toggle-${e.id}`) === "true"
}, Be = (e, t, n, o = Kt) => {
  if ("isToggleable" in e.props && !e.props.isToggleable)
    return {
      dom: n
    };
  const r = document.createElement("div"), a = document.createElement("div");
  a.className = "bn-toggle-wrapper";
  const s = document.createElement("button");
  s.className = "bn-toggle-button", s.type = "button", s.innerHTML = // https://fonts.google.com/icons?selected=Material+Symbols+Rounded:chevron_right:FILL@0;wght@700;GRAD@0;opsz@24&icon.query=chevron&icon.style=Rounded&icon.size=24&icon.color=%23e8eaed
  '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="CURRENTCOLOR"><path d="M320-200v-560l440 280-440 280Z"/></svg>';
  const i = (f) => f.preventDefault();
  s.addEventListener("mousedown", i);
  const c = () => {
    var f;
    a.getAttribute("data-show-children") === "true" ? (a.setAttribute("data-show-children", "false"), o.set(t.getBlock(e), !1), r.contains(l) && r.removeChild(l)) : (a.setAttribute("data-show-children", "true"), o.set(t.getBlock(e), !0), t.isEditable && ((f = t.getBlock(e)) == null ? void 0 : f.children.length) === 0 && !r.contains(l) && r.appendChild(l));
  };
  s.addEventListener("click", c), a.appendChild(s), a.appendChild(n);
  const l = document.createElement("button");
  l.className = "bn-toggle-add-block-button", l.type = "button", l.textContent = t.dictionary.toggle_blocks.add_block_button;
  const u = (f) => f.preventDefault();
  l.addEventListener(
    "mousedown",
    u
  );
  const d = () => {
    t.transact(() => {
      const f = t.updateBlock(e, {
        // Single empty block with default type.
        children: [{}]
      });
      t.setTextCursorPosition(f.children[0].id, "end"), t.focus();
    });
  };
  l.addEventListener("click", d), r.appendChild(a);
  let p = e.children.length;
  const m = t.onChange(() => {
    var E;
    const f = ((E = t.getBlock(e)) == null ? void 0 : E.children.length) ?? 0;
    f > p ? (a.getAttribute("data-show-children") === "false" && (a.setAttribute("data-show-children", "true"), o.set(t.getBlock(e), !0)), r.contains(l) && r.removeChild(l)) : f === 0 && f < p && (a.getAttribute("data-show-children") === "true" && (a.setAttribute("data-show-children", "false"), o.set(t.getBlock(e), !1)), r.contains(l) && r.removeChild(l)), p = f;
  });
  return o.get(e) ? (a.setAttribute("data-show-children", "true"), t.isEditable && e.children.length === 0 && r.appendChild(l)) : a.setAttribute("data-show-children", "false"), {
    dom: r,
    // Prevents re-renders when the toggle button is clicked.
    ignoreMutation: (f) => f instanceof MutationRecord && // We want to prevent re-renders when the view changes, so we ignore
    // all mutations where the `data-show-children` attribute is changed
    // or the "add block" button is added/removed.
    (f.type === "attributes" && f.target === a && f.attributeName === "data-show-children" || f.type === "childList" && (f.addedNodes[0] === l || f.removedNodes[0] === l)),
    destroy: () => {
      s.removeEventListener("mousedown", i), s.removeEventListener("click", c), l.removeEventListener(
        "mousedown",
        u
      ), l.removeEventListener(
        "click",
        d
      ), m == null || m();
    }
  };
}, Ae = [1, 2, 3, 4, 5, 6], Qt = (e) => ({ editor: t }) => {
  const n = t.getTextCursorPosition();
  return t.schema.blockSchema[n.block.type].content !== "inline" ? !1 : (t.updateBlock(n.block, {
    type: "heading",
    props: { level: e }
  }), !0);
}, Jt = ({
  defaultLevel: e = 1,
  levels: t = Ae,
  allowToggleHeadings: n = !0
} = {}) => ({
  type: "heading",
  propSchema: {
    ...h,
    level: { default: e, values: t },
    ...n ? { isToggleable: { default: !1, optional: !0 } } : {}
  },
  content: "inline"
}), Yt = v(
  Jt,
  ({ allowToggleHeadings: e = !0 } = {}) => ({
    meta: {
      isolating: !1
    },
    parse(t) {
      let n;
      switch (t.tagName) {
        case "H1":
          n = 1;
          break;
        case "H2":
          n = 2;
          break;
        case "H3":
          n = 3;
          break;
        case "H4":
          n = 4;
          break;
        case "H5":
          n = 5;
          break;
        case "H6":
          n = 6;
          break;
        default:
          return;
      }
      return {
        ...y(t),
        level: n
      };
    },
    render(t, n) {
      const o = document.createElement(`h${t.props.level}`);
      return e ? { ...Be(t, n, o), contentDOM: o } : {
        dom: o,
        contentDOM: o
      };
    },
    toExternalHTML(t) {
      const n = document.createElement(`h${t.props.level}`);
      return A(t.props, n), {
        dom: n,
        contentDOM: n
      };
    }
  }),
  ({ levels: e = Ae } = {}) => [
    k({
      key: "heading-shortcuts",
      keyboardShortcuts: Object.fromEntries(
        e.map((t) => [
          `Mod-Alt-${t}`,
          Qt(t)
        ]) ?? []
      ),
      inputRules: e.map((t) => ({
        find: new RegExp(`^(#{${t}})\\s$`),
        replace({ match: n }) {
          return {
            type: "heading",
            props: {
              level: n[1].length
            }
          };
        }
      }))
    })
  ]
), Pe = (e, t, n, o, r) => {
  const { dom: a, destroy: s } = Q(
    e,
    t,
    n,
    r
  ), i = a;
  i.style.position = "relative", e.props.url && e.props.showPreview && (e.props.previewWidth ? i.style.width = `${e.props.previewWidth}px` : i.style.width = "fit-content");
  const c = document.createElement("div");
  c.className = "bn-resize-handle", c.style.left = "4px";
  const l = document.createElement("div");
  l.className = "bn-resize-handle", l.style.right = "4px";
  const u = document.createElement("div");
  u.style.position = "absolute", u.style.height = "100%", u.style.width = "100%";
  let d, p = e.props.previewWidth;
  const m = (g) => {
    var ee, te;
    if (!d) {
      !t.isEditable && o.contains(c) && o.contains(l) && (o.removeChild(c), o.removeChild(l));
      return;
    }
    let S;
    const _ = "touches" in g ? g.touches[0].clientX : g.clientX;
    e.props.textAlignment === "center" ? d.handleUsed === "left" ? S = d.initialWidth + (d.initialClientX - _) * 2 : S = d.initialWidth + (_ - d.initialClientX) * 2 : d.handleUsed === "left" ? S = d.initialWidth + d.initialClientX - _ : S = d.initialWidth + _ - d.initialClientX, p = Math.min(
      Math.max(S, 64),
      ((te = (ee = t.domElement) == null ? void 0 : ee.firstElementChild) == null ? void 0 : te.clientWidth) || Number.MAX_VALUE
    ), i.style.width = `${p}px`;
  }, f = (g) => {
    (!g.target || !i.contains(g.target) || !t.isEditable) && o.contains(c) && o.contains(l) && (o.removeChild(c), o.removeChild(l)), d && (d = void 0, i.contains(u) && i.removeChild(u), t.updateBlock(e, {
      props: {
        previewWidth: p
      }
    }));
  }, E = () => {
    t.isEditable && (o.appendChild(c), o.appendChild(l));
  }, w = (g) => {
    g.relatedTarget === c || g.relatedTarget === l || d || t.isEditable && o.contains(c) && o.contains(l) && (o.removeChild(c), o.removeChild(l));
  }, x = (g) => {
    g.preventDefault(), i.contains(u) || i.appendChild(u);
    const S = "touches" in g ? g.touches[0].clientX : g.clientX;
    d = {
      handleUsed: "left",
      initialWidth: i.clientWidth,
      initialClientX: S
    };
  }, P = (g) => {
    g.preventDefault(), i.contains(u) || i.appendChild(u);
    const S = "touches" in g ? g.touches[0].clientX : g.clientX;
    d = {
      handleUsed: "right",
      initialWidth: i.clientWidth,
      initialClientX: S
    };
  };
  return window.addEventListener("mousemove", m), window.addEventListener("touchmove", m), window.addEventListener("mouseup", f), window.addEventListener("touchend", f), i.addEventListener("mouseenter", E), i.addEventListener("mouseleave", w), c.addEventListener(
    "mousedown",
    x
  ), c.addEventListener(
    "touchstart",
    x
  ), l.addEventListener(
    "mousedown",
    P
  ), l.addEventListener(
    "touchstart",
    P
  ), {
    dom: i,
    destroy: () => {
      s == null || s(), window.removeEventListener("mousemove", m), window.removeEventListener("touchmove", m), window.removeEventListener("mouseup", f), window.removeEventListener("touchend", f), i.removeEventListener("mouseenter", E), i.removeEventListener("mouseleave", w), c.removeEventListener(
        "mousedown",
        x
      ), c.removeEventListener(
        "touchstart",
        x
      ), l.removeEventListener(
        "mousedown",
        P
      ), l.removeEventListener(
        "touchstart",
        P
      );
    }
  };
}, he = (e) => {
  const t = e.src || void 0, n = e.width || void 0, o = e.alt || void 0;
  return { url: t, previewWidth: n, name: o };
}, en = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"></path></svg>', tn = (e = {}) => ({
  type: "image",
  propSchema: {
    textAlignment: h.textAlignment,
    backgroundColor: h.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: !0
    },
    // File preview width in px.
    previewWidth: {
      default: void 0,
      type: "number"
    }
  },
  content: "none"
}), nn = (e = {}) => (t) => {
  if (t.tagName === "IMG") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = y(t);
    return {
      ...he(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = $(t, "img");
    if (!n)
      return;
    const { targetElement: o, caption: r } = n, { backgroundColor: a } = y(t);
    return {
      ...he(o),
      backgroundColor: a,
      caption: r
    };
  }
}, on = (e = {}) => (t, n) => {
  const o = document.createElement("div");
  o.innerHTML = e.icon ?? en;
  const r = document.createElement("div");
  r.className = "bn-visual-media-wrapper";
  const a = document.createElement("img");
  return a.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((s) => {
    a.src = s;
  }) : a.src = t.props.url, a.alt = t.props.name || t.props.caption || "BlockNote image", a.contentEditable = "false", a.draggable = !1, r.appendChild(a), Pe(
    t,
    n,
    { dom: r },
    r,
    o.firstElementChild
  );
}, rn = (e = {}) => (t, n) => {
  if (!t.props.url) {
    const r = document.createElement("p");
    return r.textContent = "Add image", {
      dom: r
    };
  }
  let o;
  return t.props.showPreview ? (o = document.createElement("img"), o.src = t.props.url, o.alt = t.props.name || t.props.caption || "BlockNote image", t.props.previewWidth && (o.width = t.props.previewWidth)) : (o = document.createElement("a"), o.href = t.props.url, o.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? J(o, t.props.caption) : U(o, t.props.caption) : {
    dom: o
  };
}, an = v(
  tn,
  (e) => ({
    meta: {
      fileBlockAccept: ["image/*"]
    },
    parse: nn(e),
    render: on(e),
    toExternalHTML: rn(e),
    runsBefore: ["file"]
  })
), So = (e, t, n) => ({
  state: o,
  dispatch: r
}) => r ? Ne(o.tr, e, t, n) : !0, Ne = (e, t, n, o) => {
  const r = tt(e.doc, t), a = G(r);
  if (!a.isBlockContainer)
    return !1;
  const s = O(e), i = [
    {
      type: a.bnBlock.node.type,
      // always keep blockcontainer type
      attrs: o ? { ...a.bnBlock.node.attrs, id: void 0 } : {}
    },
    {
      type: n ? a.blockContent.node.type : s.nodes.paragraph,
      attrs: o ? { ...a.blockContent.node.attrs } : {}
    }
  ];
  return e.split(t, 2, i), !0;
}, q = (e, t) => {
  const { blockInfo: n, selectionEmpty: o } = e.transact((s) => ({
    blockInfo: nt(s),
    selectionEmpty: s.selection.anchor === s.selection.head
  }));
  if (!n.isBlockContainer)
    return !1;
  const { bnBlock: r, blockContent: a } = n;
  return a.node.type.name !== t || !o ? !1 : a.node.childCount === 0 ? (e.transact((s) => {
    K(s, r.beforePos, {
      type: "paragraph",
      props: {}
    });
  }), !0) : a.node.childCount > 0 ? e.transact((s) => (s.deleteSelection(), Ne(s, s.selection.from, !0))) : !1;
};
function Y(e, t, n) {
  var d, p, m;
  const o = Se.fromSchema(t), r = e, a = document.createElement("div");
  a.setAttribute("data-node-type", "blockGroup");
  for (const f of Array.from(r.childNodes))
    a.appendChild(f.cloneNode(!0));
  let s = o.parse(a, {
    topNode: t.nodes.blockGroup.create()
  });
  ((p = (d = s.firstChild) == null ? void 0 : d.firstChild) == null ? void 0 : p.type.name) === "checkListItem" && (s = s.copy(
    s.content.cut(
      s.firstChild.firstChild.nodeSize + 2
    )
  ));
  const i = (m = s.firstChild) == null ? void 0 : m.firstChild;
  if (!(i != null && i.isTextblock))
    return F.from(s);
  const c = t.nodes[n].create(
    {},
    i.content
  ), l = s.content.cut(
    // +2 for the `blockGroup` node's start and end markers
    i.nodeSize + 2
  );
  if (l.size > 0) {
    const f = s.copy(l);
    return c.content.addToEnd(f);
  }
  return c.content;
}
const sn = () => ({
  type: "bulletListItem",
  propSchema: {
    ...h
  },
  content: "inline"
}), cn = v(
  sn,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      var n;
      if (e.tagName !== "LI")
        return;
      const t = e.parentElement;
      if (t !== null && (t.tagName === "UL" || t.tagName === "DIV" && ((n = t.parentElement) == null ? void 0 : n.tagName) === "UL"))
        return y(e);
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Y(e, t, "bulletListItem"),
    render() {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return A(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    k({
      key: "bullet-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => q(e, "bulletListItem"),
        "Mod-Shift-8": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "bulletListItem",
            props: {}
          }), !0);
        }
      },
      inputRules: [
        {
          find: new RegExp("^[-+*]\\s$"),
          replace({ editor: e }) {
            if (Ee(
              e.prosemirrorState
            ).blockNoteType !== "heading")
              return {
                type: "bulletListItem",
                props: {}
              };
          }
        }
      ]
    })
  ]
), ln = () => ({
  type: "checkListItem",
  propSchema: {
    ...h,
    checked: { default: !1, type: "boolean" }
  },
  content: "inline"
}), dn = v(
  ln,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      var n;
      if (e.tagName === "input")
        return e.closest("[data-content-type]") || e.closest("li") ? void 0 : e.type === "checkbox" ? { checked: e.checked } : void 0;
      if (e.tagName !== "LI")
        return;
      const t = e.parentElement;
      if (t !== null && (t.tagName === "UL" || t.tagName === "DIV" && ((n = t.parentElement) == null ? void 0 : n.tagName) === "UL")) {
        const o = e.querySelector("input[type=checkbox]") || null;
        return o === null ? void 0 : { ...y(e), checked: o.checked };
      }
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Y(e, t, "checkListItem"),
    render(e, t) {
      const n = document.createDocumentFragment(), o = document.createElement("input");
      o.type = "checkbox", o.checked = e.props.checked, e.props.checked && o.setAttribute("checked", ""), o.addEventListener("change", () => {
        t.updateBlock(e, { props: { checked: !e.props.checked } });
      });
      const r = document.createElement("p");
      return n.appendChild(o), n.appendChild(r), {
        dom: n,
        contentDOM: r
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("input");
      n.type = "checkbox", n.checked = e.props.checked, e.props.checked && n.setAttribute("checked", "");
      const o = document.createElement("p");
      return A(e.props, t), t.appendChild(n), t.appendChild(o), {
        dom: t,
        contentDOM: o
      };
    },
    runsBefore: ["bulletListItem"]
  },
  [
    k({
      key: "check-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => q(e, "checkListItem"),
        "Mod-Shift-9": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "checkListItem",
            props: {}
          }), !0);
        }
      },
      inputRules: [
        {
          find: new RegExp("^\\[\\s*\\]\\s$"),
          replace() {
            return {
              type: "checkListItem",
              props: {
                checked: !1
              },
              content: []
            };
          }
        },
        {
          find: new RegExp("^\\[[Xx]\\]\\s$"),
          replace() {
            return {
              type: "checkListItem",
              props: {
                checked: !0
              }
            };
          }
        }
      ]
    })
  ]
);
function He(e, t, n, o) {
  let r = e.firstChild.attrs.start || 1, a = !0;
  const s = !!e.firstChild.attrs.start, i = G({
    posBeforeNode: t,
    node: e
  });
  if (!i.isBlockContainer)
    throw new Error("impossible");
  const c = n.doc.resolve(i.bnBlock.beforePos).nodeBefore, l = c ? o.get(c) : void 0;
  return l !== void 0 ? (r = l + 1, a = !1) : c && G({
    posBeforeNode: i.bnBlock.beforePos - c.nodeSize,
    node: c
  }).blockNoteType === "numberedListItem" && (r = He(
    c,
    i.bnBlock.beforePos - c.nodeSize,
    n,
    o
  ).index + 1, a = !1), o.set(e, r), { index: r, isFirst: a, hasStart: s };
}
function me(e, t) {
  const n = /* @__PURE__ */ new Map(), o = t.decorations.map(
    e.mapping,
    e.doc
  ), r = [];
  e.doc.nodesBetween(0, e.doc.nodeSize - 2, (s, i) => {
    if (s.type.name === "blockContainer" && s.firstChild.type.name === "numberedListItem") {
      const { index: c, isFirst: l, hasStart: u } = He(
        s,
        i,
        e,
        n
      );
      if (o.find(
        i,
        i + s.nodeSize,
        (p) => p.index === c && p.isFirst === l && p.hasStart === u
      ).length === 0) {
        const p = e.doc.nodeAt(i + 1);
        r.push(
          // move in by 1 to account for the block container
          ht.node(i + 1, i + 1 + p.nodeSize, {
            "data-index": c.toString()
          })
        );
      }
    }
  });
  const a = r.flatMap(
    (s) => o.find(s.from, s.to)
  );
  return {
    decorations: o.remove(a).add(e.doc, r)
  };
}
const un = () => new pt({
  key: new ft("numbered-list-indexing-decorations"),
  state: {
    init(e, t) {
      return me(t.tr, {
        decorations: ce.empty
      });
    },
    apply(e, t) {
      return !e.docChanged && !e.selectionSet && t.decorations ? t : me(e, t);
    }
  },
  props: {
    decorations(e) {
      var t;
      return ((t = this.getState(e)) == null ? void 0 : t.decorations) ?? ce.empty;
    }
  }
}), pn = () => ({
  type: "numberedListItem",
  propSchema: {
    ...h,
    start: { default: void 0, type: "number" }
  },
  content: "inline"
}), fn = v(
  pn,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      var n;
      if (e.tagName !== "LI")
        return;
      const t = e.parentElement;
      if (t !== null && (t.tagName === "OL" || t.tagName === "DIV" && ((n = t.parentElement) == null ? void 0 : n.tagName) === "OL")) {
        const o = parseInt(t.getAttribute("start") || "1"), r = y(e);
        return e.previousElementSibling || o === 1 ? r : {
          ...r,
          start: o
        };
      }
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Y(e, t, "numberedListItem"),
    render() {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return A(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    k({
      key: "numbered-list-item-shortcuts",
      inputRules: [
        {
          find: new RegExp("^(\\d+)\\.\\s$"),
          replace({ match: e, editor: t }) {
            if (Ee(
              t.prosemirrorState
            ).blockNoteType === "heading")
              return;
            const o = parseInt(e[1]);
            return {
              type: "numberedListItem",
              props: {
                start: o !== 1 ? o : void 0
              }
            };
          }
        }
      ],
      keyboardShortcuts: {
        Enter: ({ editor: e }) => q(e, "numberedListItem"),
        "Mod-Shift-7": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "numberedListItem",
            props: {}
          }), !0);
        }
      },
      prosemirrorPlugins: [un()]
    })
  ]
), hn = () => ({
  type: "toggleListItem",
  propSchema: {
    ...h
  },
  content: "inline"
}), mn = v(
  hn,
  {
    meta: {
      isolating: !1
    },
    render(e, t) {
      const n = document.createElement("p");
      return { ...Be(
        e,
        t,
        n
      ), contentDOM: n };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return A(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    k({
      key: "toggle-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => q(e, "toggleListItem"),
        "Mod-Shift-6": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "toggleListItem",
            props: {}
          }), !0);
        }
      }
    })
  ]
), gn = () => ({
  type: "paragraph",
  propSchema: h,
  content: "inline"
}), bn = v(
  gn,
  {
    meta: {
      isolating: !1
    },
    parse: (e) => {
      var t;
      if (e.tagName === "P" && (t = e.textContent) != null && t.trim())
        return y(e);
    },
    render: () => {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("p");
      return A(e.props, t), {
        dom: t,
        contentDOM: t
      };
    },
    runsBefore: ["default"]
  },
  [
    k({
      key: "paragraph-shortcuts",
      keyboardShortcuts: {
        "Mod-Alt-0": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "paragraph",
            props: {}
          }), !0);
        }
      }
    })
  ]
), Cn = () => ({
  type: "quote",
  propSchema: {
    backgroundColor: h.backgroundColor,
    textColor: h.textColor
  },
  content: "inline"
}), kn = v(
  Cn,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      if (e.tagName === "BLOCKQUOTE") {
        const { backgroundColor: t, textColor: n } = y(e);
        return { backgroundColor: t, textColor: n };
      }
    },
    render() {
      const e = document.createElement("blockquote");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("blockquote");
      return A(e.props, t), {
        dom: t,
        contentDOM: t
      };
    }
  },
  [
    k({
      key: "quote-block-shortcuts",
      keyboardShortcuts: {
        "Mod-Alt-q": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "quote",
            props: {}
          }), !0);
        }
      },
      inputRules: [
        {
          find: new RegExp("^>\\s$"),
          replace() {
            return {
              type: "quote",
              props: {}
            };
          }
        }
      ]
    })
  ]
), yn = 35, Ie = 120, Mo = 31, vn = $e.create({
  name: "BlockNoteTableExtension",
  addProseMirrorPlugins: () => [
    Ve({
      cellMinWidth: yn,
      defaultCellMinWidth: Ie,
      // We set this to null as we implement our own node view in the table
      // block content. This node view is the same as what's used by default,
      // but is wrapped in a `blockContent` HTML element.
      View: null
    }),
    Re()
  ],
  addKeyboardShortcuts() {
    return {
      // Makes enter create a new line within the cell.
      Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === "tableParagraph" ? (this.editor.commands.insertContent({ type: "hardBreak" }), !0) : !1,
      // Ensures that backspace won't delete the table if the text cursor is at
      // the start of a cell and the selection is empty.
      Backspace: () => {
        const e = this.editor.state.selection, t = e.empty, n = e.$head.parentOffset === 0, o = e.$head.node().type.name === "tableParagraph";
        return t && n && o;
      },
      // Enables navigating cells using the tab key.
      Tab: () => this.editor.commands.command(
        ({ state: e, dispatch: t, view: n }) => ne(1)(e, t, n)
      ),
      "Shift-Tab": () => this.editor.commands.command(
        ({ state: e, dispatch: t, view: n }) => ne(-1)(e, t, n)
      )
    };
  },
  extendNodeSchema(e) {
    const t = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      tableRole: Ue(
        qe(e, "tableRole", t)
      )
    };
  }
}), En = {
  textColor: h.textColor
}, xn = N.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  /**
   * We allow table headers and cells to have multiple tableContent nodes because
   * when merging cells, prosemirror-tables will concat the contents of the cells naively.
   * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.
   *
   * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.
   */
  content: "tableContent+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (e) => {
          const t = e.getAttribute("colwidth");
          return t ? t.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      {
        tag: "th",
        // As `th` elements can contain multiple paragraphs, we need to merge their contents
        // into a single one so that ProseMirror can parse everything correctly.
        getContent: (e, t) => De(e, t)
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "th",
      z(this.options.HTMLAttributes, e),
      0
    ];
  }
}), wn = N.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "tableContent+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (e) => {
          const t = e.getAttribute("colwidth");
          return t ? t.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      {
        tag: "td",
        // As `td` elements can contain multiple paragraphs, we need to merge their contents
        // into a single one so that ProseMirror can parse everything correctly.
        getContent: (e, t) => De(e, t)
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "td",
      z(this.options.HTMLAttributes, e),
      0
    ];
  }
}), Sn = N.create({
  name: "table",
  content: "tableRow+",
  group: "blockContent",
  tableRole: "table",
  marks: "deletion insertion modification",
  isolating: !0,
  parseHTML() {
    return [
      {
        tag: "table"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    var r, a, s;
    const n = gt(
      this.name,
      "table",
      {
        ...((r = this.options.domAttributes) == null ? void 0 : r.blockContent) || {},
        ...t
      },
      ((a = this.options.domAttributes) == null ? void 0 : a.inlineContent) || {}
    ), o = document.createElement("colgroup");
    for (const i of e.children[0].children)
      if (i.attrs.colwidth)
        for (const l of i.attrs.colwidth) {
          const u = document.createElement("col");
          l && (u.style = `width: ${l}px`), o.appendChild(u);
        }
      else
        o.appendChild(document.createElement("col"));
    return (s = n.dom.firstChild) == null || s.appendChild(o), n;
  },
  // This node view is needed for the `columnResizing` plugin. By default, the
  // plugin adds its own node view, which overrides how the node is rendered vs
  // `renderHTML`. This means that the wrapping `blockContent` HTML element is
  // no longer rendered. The `columnResizing` plugin uses the `TableView` as its
  // default node view. `BlockNoteTableView` extends it by wrapping it in a
  // `blockContent` element, so the DOM structure is consistent with other block
  // types.
  addNodeView() {
    return ({ node: e, HTMLAttributes: t }) => {
      var o;
      class n extends We {
        constructor(a, s, i) {
          super(a, s), this.node = a, this.cellMinWidth = s, this.blockContentHTMLAttributes = i;
          const c = document.createElement("div");
          c.className = D(
            "bn-block-content",
            i.class
          ), c.setAttribute("data-content-type", "table");
          for (const [p, m] of Object.entries(
            i
          ))
            p !== "class" && c.setAttribute(p, m);
          const l = this.dom, u = document.createElement("div");
          u.className = "tableWrapper-inner", u.appendChild(l.firstChild), l.appendChild(u), c.appendChild(l);
          const d = document.createElement("div");
          d.className = "table-widgets-container", d.style.position = "relative", l.appendChild(d), this.dom = c;
        }
        ignoreMutation(a) {
          return !a.target.closest(".tableWrapper-inner") || super.ignoreMutation(a);
        }
      }
      return new n(e, Ie, {
        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},
        ...t
      });
    };
  }
}), Mn = N.create({
  name: "tableParagraph",
  group: "tableContent",
  content: "inline*",
  parseHTML() {
    return [
      {
        tag: "p",
        getAttrs: (e) => {
          if (typeof e == "string" || !e.textContent || !e.closest("[data-content-type]"))
            return !1;
          const t = e.parentElement;
          return t === null ? !1 : t.tagName === "TD" || t.tagName === "TH" ? {} : !1;
        },
        node: "tableParagraph"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", e, 0];
  }
}), Ln = N.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)+",
  tableRole: "row",
  marks: "deletion insertion modification",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "tr",
      z(this.options.HTMLAttributes, e),
      0
    ];
  }
});
function De(e, t) {
  const o = Se.fromSchema(t).parse(e, {
    topNode: t.nodes.blockGroup.create()
  }), r = [];
  return o.content.descendants((a) => {
    if (a.isInline)
      return r.push(a), !1;
  }), F.fromArray(r);
}
const Tn = () => yt(
  { node: Sn, type: "table", content: "table" },
  En,
  [
    k({
      key: "table-extensions",
      tiptapExtensions: [
        vn,
        Mn,
        xn,
        wn,
        Ln
      ]
    }),
    // Extension for keyboard shortcut which deletes the table if it's empty
    // and all cells are selected. Uses a separate extension as it needs
    // priority over keyboard handlers in the `TableExtension`'s
    // `tableEditing` plugin.
    k({
      key: "table-keyboard-delete",
      keyboardShortcuts: {
        Backspace: ({ editor: e }) => {
          if (!(e.prosemirrorState.selection instanceof Ce))
            return !1;
          const t = e.getTextCursorPosition().block, n = t.content;
          let o = 0;
          for (const a of n.rows)
            for (const s of a.cells) {
              if ("type" in s && s.content.length > 0 || !("type" in s) && s.length > 0)
                return !1;
              o++;
            }
          let r = 0;
          return e.prosemirrorState.selection.forEachCell(() => {
            r++;
          }), r < o ? !1 : (e.transact(() => {
            (e.getPrevBlock(t) || e.getNextBlock(t)) && e.setTextCursorPosition(t), e.removeBlocks([t]);
          }), !0);
        }
      }
    })
  ]
), ge = (e) => {
  const t = e.src || void 0, n = e.width || void 0;
  return { url: t, previewWidth: n };
}, Bn = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z"></path></svg>', An = (e) => ({
  type: "video",
  propSchema: {
    textAlignment: h.textAlignment,
    backgroundColor: h.backgroundColor,
    name: { default: "" },
    url: { default: "" },
    caption: { default: "" },
    showPreview: { default: !0 },
    previewWidth: { default: void 0, type: "number" }
  },
  content: "none"
}), Pn = (e) => (t) => {
  if (t.tagName === "VIDEO") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = y(t);
    return {
      ...ge(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = $(t, "video");
    if (!n)
      return;
    const { targetElement: o, caption: r } = n, { backgroundColor: a } = y(t);
    return {
      ...ge(o),
      backgroundColor: a,
      caption: r
    };
  }
}, Nn = v(
  An,
  (e) => ({
    meta: {
      fileBlockAccept: ["video/*"]
    },
    parse: Pn(),
    render(t, n) {
      const o = document.createElement("div");
      o.innerHTML = e.icon ?? Bn;
      const r = document.createElement("div");
      r.className = "bn-visual-media-wrapper";
      const a = document.createElement("video");
      return a.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((s) => {
        a.src = s;
      }) : a.src = t.props.url, a.controls = !0, a.contentEditable = "false", a.draggable = !1, a.width = t.props.previewWidth, r.appendChild(a), Pe(
        t,
        n,
        { dom: r },
        r,
        o.firstElementChild
      );
    },
    toExternalHTML(t) {
      if (!t.props.url) {
        const o = document.createElement("p");
        return o.textContent = "Add video", {
          dom: o
        };
      }
      let n;
      return t.props.showPreview ? (n = document.createElement("video"), n.src = t.props.url, t.props.previewWidth && (n.width = t.props.previewWidth)) : (n = document.createElement("a"), n.href = t.props.url, n.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? J(n, t.props.caption) : U(n, t.props.caption) : {
        dom: n
      };
    },
    runsBefore: ["file"]
  })
);
function b(e, t, n) {
  if (!(t in e.schema.blockSpecs))
    return !1;
  if (!n)
    return !0;
  for (const [o, r] of Object.entries(n)) {
    if (!(o in e.schema.blockSpecs[t].config.propSchema))
      return !1;
    if (typeof r == "string") {
      if (e.schema.blockSpecs[t].config.propSchema[o].default !== void 0 && typeof e.schema.blockSpecs[t].config.propSchema[o].default !== r || e.schema.blockSpecs[t].config.propSchema[o].type !== void 0 && e.schema.blockSpecs[t].config.propSchema[o].type !== r)
        return !1;
    } else {
      if (e.schema.blockSpecs[t].config.propSchema[o].default !== r.default || e.schema.blockSpecs[t].config.propSchema[o].default === void 0 && r.default === void 0 && e.schema.blockSpecs[t].config.propSchema[o].type !== r.type || typeof e.schema.blockSpecs[t].config.propSchema[o].values != typeof r.values)
        return !1;
      if (typeof e.schema.blockSpecs[t].config.propSchema[o].values == "object" && typeof r.values == "object") {
        for (const a of r.values)
          if (!e.schema.blockSpecs[t].config.propSchema[o].values.includes(a))
            return !1;
      }
    }
  }
  return !0;
}
function Lo(e, t, n, o) {
  return b(t, n, o) && e.type === n;
}
function To(e) {
  return e instanceof Ce;
}
const R = /* @__PURE__ */ new Map();
function Hn(e) {
  if (R.has(e))
    return R.get(e);
  const t = new Xe();
  return e._tiptapEditor.on("transaction", ({ transaction: n }) => {
    t.appendMapping(n.mapping);
  }), e._tiptapEditor.on("destroy", () => {
    R.delete(e);
  }), R.set(e, t), t;
}
function In(e, t, n = "left") {
  const o = ae.getState(e.prosemirrorState);
  if (!o) {
    const a = Hn(e), s = a.maps.length;
    return () => a.slice(s).map(t, n === "left" ? -1 : 1);
  }
  const r = Ke(
    // Track the position after the position if we are on the right side
    t + (n === "right" ? 1 : -1),
    o.binding.type,
    o.binding.mapping
  );
  return () => {
    const a = ae.getState(
      e.prosemirrorState
    ), s = Qe(
      a.doc,
      a.binding.type,
      r,
      a.binding.mapping
    );
    if (s === null)
      throw new Error("Position not found, cannot track positions");
    return s + (n === "right" ? -1 : 1);
  };
}
const Dn = je((e) => e.type.name === "blockContainer");
class On {
  constructor(t, n, o) {
    M(this, "state");
    M(this, "emitUpdate");
    M(this, "rootEl");
    M(this, "pluginState");
    M(this, "handleScroll", () => {
      var t, n;
      if ((t = this.state) != null && t.show) {
        const o = (n = this.rootEl) == null ? void 0 : n.querySelector(
          `[data-decoration-id="${this.pluginState.decorationId}"]`
        );
        if (!o)
          return;
        this.state.referencePos = o.getBoundingClientRect().toJSON(), this.emitUpdate(this.pluginState.triggerCharacter);
      }
    });
    M(this, "closeMenu", () => {
      this.editor.transact((t) => t.setMeta(B, null));
    });
    M(this, "clearQuery", () => {
      this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({
        from: this.pluginState.queryStartPos() - (this.pluginState.deleteTriggerCharacter ? this.pluginState.triggerCharacter.length : 0),
        to: this.editor.transact((t) => t.selection.from)
      }).run();
    });
    var r;
    this.editor = t, this.pluginState = void 0, this.emitUpdate = (a) => {
      var s;
      if (!this.state)
        throw new Error("Attempting to update uninitialized suggestions menu");
      n(a, {
        ...this.state,
        ignoreQueryLength: (s = this.pluginState) == null ? void 0 : s.ignoreQueryLength
      });
    }, this.rootEl = o.root, (r = this.rootEl) == null || r.addEventListener("scroll", this.handleScroll, !0);
  }
  update(t, n) {
    var l;
    const o = B.getState(n), r = B.getState(
      t.state
    ), a = o === void 0 && r !== void 0, s = o !== void 0 && r === void 0;
    if (!a && !(o !== void 0 && r !== void 0) && !s)
      return;
    if (this.pluginState = s ? o : r, s || !this.editor.isEditable) {
      this.state && (this.state.show = !1), this.emitUpdate(this.pluginState.triggerCharacter);
      return;
    }
    const c = (l = this.rootEl) == null ? void 0 : l.querySelector(
      `[data-decoration-id="${this.pluginState.decorationId}"]`
    );
    this.editor.isEditable && c && (this.state = {
      show: !0,
      referencePos: c.getBoundingClientRect().toJSON(),
      query: this.pluginState.query
    }, this.emitUpdate(this.pluginState.triggerCharacter));
  }
  destroy() {
    var t;
    (t = this.rootEl) == null || t.removeEventListener("scroll", this.handleScroll, !0);
  }
}
const B = new Ze("SuggestionMenuPlugin"), _n = k(({ editor: e }) => {
  const t = [];
  let n;
  const o = ye(void 0);
  return {
    key: "suggestionMenu",
    store: o,
    addTriggerCharacter: (r) => {
      t.push(r);
    },
    removeTriggerCharacter: (r) => {
      t.splice(t.indexOf(r), 1);
    },
    closeMenu: () => {
      n == null || n.closeMenu();
    },
    clearQuery: () => {
      n == null || n.clearQuery();
    },
    shown: () => {
      var r;
      return ((r = n == null ? void 0 : n.state) == null ? void 0 : r.show) || !1;
    },
    openSuggestionMenu: (r, a) => {
      e.headless || (e.focus(), e.transact((s) => {
        a != null && a.deleteTriggerCharacter && s.insertText(r), s.scrollIntoView().setMeta(B, {
          triggerCharacter: r,
          deleteTriggerCharacter: (a == null ? void 0 : a.deleteTriggerCharacter) || !1,
          ignoreQueryLength: (a == null ? void 0 : a.ignoreQueryLength) || !1
        });
      }));
    },
    // TODO this whole plugin needs to be refactored (but I've done the minimal)
    prosemirrorPlugins: [
      new Ge({
        key: B,
        view: (r) => (n = new On(
          e,
          (a, s) => {
            o.setState({ ...s, triggerCharacter: a });
          },
          r
        ), n),
        state: {
          // Initialize the plugin's internal state.
          init() {
          },
          // Apply changes to the plugin state from an editor transaction.
          apply: (r, a, s, i) => {
            if (r.selection.$from.parent.type.spec.code)
              return a;
            const c = r.getMeta(B);
            if (typeof c == "object" && c !== null) {
              a && (n == null || n.closeMenu());
              const u = In(
                e,
                i.selection.from - // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.
                c.triggerCharacter.length
              );
              return {
                triggerCharacter: c.triggerCharacter,
                deleteTriggerCharacter: c.deleteTriggerCharacter !== !1,
                // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller
                queryStartPos: () => u() + c.triggerCharacter.length,
                query: "",
                decorationId: `id_${Math.floor(Math.random() * 4294967295)}`,
                ignoreQueryLength: c == null ? void 0 : c.ignoreQueryLength
              };
            }
            if (a === void 0)
              return a;
            if (
              // Highlighting text should hide the menu.
              i.selection.from !== i.selection.to || // Transactions with plugin metadata should hide the menu.
              c === null || // Certain mouse events should hide the menu.
              // TODO: Change to global mousedown listener.
              r.getMeta("focus") || r.getMeta("blur") || r.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
              a.triggerCharacter !== void 0 && i.selection.from < a.queryStartPos() || // Moving the caret to a new block should hide the menu.
              !i.selection.$from.sameParent(
                i.doc.resolve(a.queryStartPos())
              )
            )
              return;
            const l = { ...a };
            return l.query = i.doc.textBetween(
              a.queryStartPos(),
              i.selection.from
            ), l;
          }
        },
        props: {
          handleTextInput(r, a, s, i) {
            if (a === s) {
              const c = r.state.doc;
              for (const l of t) {
                const u = l.length > 1 ? c.textBetween(a - l.length, a) + i : i;
                if (l === u)
                  return r.dispatch(r.state.tr.insertText(i)), r.dispatch(
                    r.state.tr.setMeta(B, {
                      triggerCharacter: u
                    }).scrollIntoView()
                  ), !0;
              }
            }
            return !1;
          },
          // Setup decorator on the currently active suggestion.
          decorations(r) {
            const a = this.getState(r);
            if (a === void 0)
              return null;
            if (!a.deleteTriggerCharacter) {
              const s = Dn(r.selection);
              if (s)
                return oe.create(r.doc, [
                  re.node(
                    s.pos,
                    s.pos + s.node.nodeSize,
                    {
                      nodeName: "span",
                      class: "bn-suggestion-decorator",
                      "data-decoration-id": a.decorationId
                    }
                  )
                ]);
            }
            return oe.create(r.doc, [
              re.inline(
                a.queryStartPos() - a.triggerCharacter.length,
                a.queryStartPos(),
                {
                  nodeName: "span",
                  class: "bn-suggestion-decorator",
                  "data-decoration-id": a.decorationId
                }
              )
            ]);
          }
        }
      })
    ]
  };
});
function Vn(e) {
  let t = e.getTextCursorPosition().block, n = e.schema.blockSchema[t.type].content;
  for (; n === "none"; ) {
    if (t = e.getTextCursorPosition().nextBlock, t === void 0)
      return;
    n = e.schema.blockSchema[t.type].content, e.setTextCursorPosition(t, "end");
  }
}
function C(e, t) {
  const n = e.getTextCursorPosition().block;
  if (n.content === void 0)
    throw new Error("Slash Menu open in a block that doesn't contain content.");
  let o;
  return Array.isArray(n.content) && (n.content.length === 1 && ot(n.content[0]) && n.content[0].type === "text" && n.content[0].text === "/" || n.content.length === 0) ? (o = e.updateBlock(n, t), e.setTextCursorPosition(o)) : (o = e.insertBlocks([t], n, "after")[0], e.setTextCursorPosition(e.getTextCursorPosition().nextBlock)), Vn(e), o;
}
function Bo(e) {
  const t = [];
  return b(e, "heading", { level: "number" }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n <= 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        C(e, {
          type: "heading",
          props: { level: n }
        });
      },
      badge: L(`Mod-Alt-${n}`),
      key: n === 1 ? "heading" : `heading_${n}`,
      ...e.dictionary.slash_menu[n === 1 ? "heading" : `heading_${n}`]
    });
  }), b(e, "quote") && t.push({
    onItemClick: () => {
      C(e, {
        type: "quote"
      });
    },
    key: "quote",
    ...e.dictionary.slash_menu.quote
  }), b(e, "toggleListItem") && t.push({
    onItemClick: () => {
      C(e, {
        type: "toggleListItem"
      });
    },
    badge: L("Mod-Shift-6"),
    key: "toggle_list",
    ...e.dictionary.slash_menu.toggle_list
  }), b(e, "numberedListItem") && t.push({
    onItemClick: () => {
      C(e, {
        type: "numberedListItem"
      });
    },
    badge: L("Mod-Shift-7"),
    key: "numbered_list",
    ...e.dictionary.slash_menu.numbered_list
  }), b(e, "bulletListItem") && t.push({
    onItemClick: () => {
      C(e, {
        type: "bulletListItem"
      });
    },
    badge: L("Mod-Shift-8"),
    key: "bullet_list",
    ...e.dictionary.slash_menu.bullet_list
  }), b(e, "checkListItem") && t.push({
    onItemClick: () => {
      C(e, {
        type: "checkListItem"
      });
    },
    badge: L("Mod-Shift-9"),
    key: "check_list",
    ...e.dictionary.slash_menu.check_list
  }), b(e, "paragraph") && t.push({
    onItemClick: () => {
      C(e, {
        type: "paragraph"
      });
    },
    badge: L("Mod-Alt-0"),
    key: "paragraph",
    ...e.dictionary.slash_menu.paragraph
  }), b(e, "codeBlock") && t.push({
    onItemClick: () => {
      C(e, {
        type: "codeBlock"
      });
    },
    badge: L("Mod-Alt-c"),
    key: "code_block",
    ...e.dictionary.slash_menu.code_block
  }), b(e, "divider") && t.push({
    onItemClick: () => {
      C(e, { type: "divider" });
    },
    key: "divider",
    ...e.dictionary.slash_menu.divider
  }), b(e, "table") && t.push({
    onItemClick: () => {
      C(e, {
        type: "table",
        content: {
          type: "tableContent",
          rows: [
            {
              cells: ["", "", ""]
            },
            {
              cells: ["", "", ""]
            }
          ]
        }
      });
    },
    badge: void 0,
    key: "table",
    ...e.dictionary.slash_menu.table
  }), b(e, "image", { url: "string" }) && t.push({
    onItemClick: () => {
      var o;
      const n = C(e, {
        type: "image"
      });
      (o = e.getExtension(I)) == null || o.showMenu(n.id);
    },
    key: "image",
    ...e.dictionary.slash_menu.image
  }), b(e, "video", { url: "string" }) && t.push({
    onItemClick: () => {
      var o;
      const n = C(e, {
        type: "video"
      });
      (o = e.getExtension(I)) == null || o.showMenu(n.id);
    },
    key: "video",
    ...e.dictionary.slash_menu.video
  }), b(e, "audio", { url: "string" }) && t.push({
    onItemClick: () => {
      var o;
      const n = C(e, {
        type: "audio"
      });
      (o = e.getExtension(I)) == null || o.showMenu(n.id);
    },
    key: "audio",
    ...e.dictionary.slash_menu.audio
  }), b(e, "file", { url: "string" }) && t.push({
    onItemClick: () => {
      var o;
      const n = C(e, {
        type: "file"
      });
      (o = e.getExtension(I)) == null || o.showMenu(n.id);
    },
    key: "file",
    ...e.dictionary.slash_menu.file
  }), b(e, "heading", {
    level: "number",
    isToggleable: "boolean"
  }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n <= 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        C(e, {
          type: "heading",
          props: { level: n, isToggleable: !0 }
        });
      },
      key: n === 1 ? "toggle_heading" : `toggle_heading_${n}`,
      ...e.dictionary.slash_menu[n === 1 ? "toggle_heading" : `toggle_heading_${n}`]
    });
  }), b(e, "heading", { level: "number" }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n > 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        C(e, {
          type: "heading",
          props: { level: n }
        });
      },
      badge: L(`Mod-Alt-${n}`),
      key: `heading_${n}`,
      ...e.dictionary.slash_menu[`heading_${n}`]
    });
  }), t.push({
    onItemClick: () => {
      var n;
      (n = e.getExtension(_n)) == null || n.openSuggestionMenu(":", {
        deleteTriggerCharacter: !0,
        ignoreQueryLength: !0
      });
    },
    key: "emoji",
    ...e.dictionary.slash_menu.emoji
  }), t;
}
function Ao(e, t) {
  return e.filter(
    ({ title: n, aliases: o }) => n.toLowerCase().includes(t.toLowerCase()) || o && o.filter(
      (r) => r.toLowerCase().includes(t.toLowerCase())
    ).length !== 0
  );
}
const Po = {
  audio: Ft(),
  bulletListItem: cn(),
  checkListItem: dn(),
  codeBlock: qt(),
  divider: Gt(),
  file: Xt(),
  heading: Yt(),
  image: an(),
  numberedListItem: fn(),
  paragraph: bn(),
  quote: kn(),
  table: Tn(),
  toggleListItem: mn(),
  video: Nn()
}, Rn = Le(
  {
    type: "textColor",
    propSchema: "string"
  },
  {
    render: () => {
      const e = document.createElement("span");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("span");
      return e !== h.textColor.default && (t.style.color = e in T ? T[e].text : e), {
        dom: t,
        contentDOM: t
      };
    },
    parse: (e) => {
      if (e.tagName === "SPAN" && e.style.color)
        return e.style.color;
    }
  }
), Wn = Le(
  {
    type: "backgroundColor",
    propSchema: "string"
  },
  {
    render: () => {
      const e = document.createElement("span");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("span");
      return e !== h.backgroundColor.default && (t.style.backgroundColor = e in T ? T[e].background : e), {
        dom: t,
        contentDOM: t
      };
    },
    parse: (e) => {
      if (e.tagName === "SPAN" && e.style.backgroundColor)
        return e.style.backgroundColor;
    }
  }
), Fn = {
  bold: H(rt, "boolean"),
  italic: H(st, "boolean"),
  underline: H(ct, "boolean"),
  strike: H(it, "boolean"),
  code: H(at, "boolean"),
  textColor: Rn,
  backgroundColor: Wn
}, No = Mt(Fn), $n = {
  text: { config: "text", implementation: {} },
  link: { config: "link", implementation: {} }
}, Ho = wt(
  $n
);
export {
  b as $,
  dn as A,
  pn as B,
  fn as C,
  hn as D,
  Mo as E,
  Ot as F,
  mn as G,
  gn as H,
  bn as I,
  Cn as J,
  kn as K,
  En as L,
  Tn as M,
  Bn as N,
  An as O,
  Pn as P,
  Nn as Q,
  Kt as R,
  Be as S,
  gt as T,
  le as U,
  bt as V,
  Po as W,
  Fn as X,
  No as Y,
  $n as Z,
  Ho as _,
  Ie as a,
  Lo as a0,
  To as a1,
  h as a2,
  y as a3,
  A as a4,
  Eo as a5,
  xo as a6,
  wo as a7,
  I as a8,
  _n as a9,
  Z as aA,
  yt as aB,
  xt as aC,
  Lt as aD,
  Le as aE,
  St as aF,
  V as aG,
  Me as aH,
  H as aI,
  mt as aJ,
  L as aK,
  uo as aL,
  W as aM,
  po as aN,
  In as aO,
  C as aa,
  Bo as ab,
  Ao as ac,
  ho as ad,
  Mt as ae,
  wt as af,
  mo as ag,
  v as ah,
  Bt as ai,
  Tt as aj,
  go as ak,
  bo as al,
  Ct as am,
  Co as an,
  yo as ao,
  fo as ap,
  So as aq,
  ko as ar,
  D as as,
  K as at,
  Pt as au,
  T as av,
  vo as aw,
  vt as ax,
  Et as ay,
  kt as az,
  Vt as b,
  _t as c,
  Rt as d,
  Wt as e,
  Ft as f,
  Ut as g,
  qt as h,
  Te as i,
  jt as j,
  Gt as k,
  Zt as l,
  zt as m,
  Xt as n,
  Jt as o,
  ue as p,
  Yt as q,
  en as r,
  tn as s,
  nn as t,
  on as u,
  rn as v,
  an as w,
  sn as x,
  cn as y,
  ln as z
};
//# sourceMappingURL=defaultBlocks-DvCGYzqu.js.map
