{"version":3,"file":"BlockNoteSchema-BOW16JHv.js","sources":["../src/util/topo-sort.ts","../src/schema/schema.ts","../src/blocks/PageBreak/block.ts","../src/blocks/File/helpers/uploadToTmpFilesDotOrg_DEV_ONLY.ts","../src/blocks/PageBreak/getPageBreakSlashMenuItems.ts","../src/blocks/BlockNoteSchema.ts"],"sourcesContent":["/**\n * Instead of depending on the NPM package, we vendor this file from https://github.com/n1ru4l/toposort/blob/main/src/toposort.ts (MIT)\n *\n * There was a recent publish, despite not having been updated in 2 years, which is suspicious.\n *\n * This file is also simple enough that we can maintain it ourselves.\n */\n\nexport type DirectedAcyclicGraph = Map<string, Iterable<string>>;\nexport type DependencyGraph = DirectedAcyclicGraph;\n\nexport type TaskList = Array<Set<string>>;\n\n// Add more specific types for better type safety\nexport type NodeId = string;\nexport type DependencyMap = Map<NodeId, Set<NodeId>>;\n\nexport function toposort(dag: DirectedAcyclicGraph): TaskList {\n  const inDegrees = countInDegrees(dag);\n\n  let { roots, nonRoots } = getRootsAndNonRoots(inDegrees);\n\n  const sorted: TaskList = [];\n\n  while (roots.size) {\n    sorted.push(roots);\n\n    const newRoots = new Set<NodeId>();\n    for (const root of roots) {\n      const dependents = dag.get(root);\n      if (!dependents) {\n        // Handle case where node has no dependents\n        continue;\n      }\n\n      for (const dependent of dependents) {\n        const currentDegree = inDegrees.get(dependent);\n        if (currentDegree === undefined) {\n          // Handle case where dependent node is not in inDegrees\n          continue;\n        }\n\n        const newDegree = currentDegree - 1;\n        inDegrees.set(dependent, newDegree);\n\n        if (newDegree === 0) {\n          newRoots.add(dependent);\n        }\n      }\n    }\n\n    roots = newRoots;\n  }\n  nonRoots = getRootsAndNonRoots(inDegrees).nonRoots;\n\n  if (nonRoots.size) {\n    throw new Error(\n      `Cycle(s) detected; toposort only works on acyclic graphs. Cyclic nodes: ${Array.from(nonRoots).join(\", \")}`,\n    );\n  }\n\n  return sorted;\n}\n\nexport function toposortReverse(deps: DependencyGraph): TaskList {\n  const dag = reverse(deps);\n  return toposort(dag);\n}\n\ntype InDegrees = Map<NodeId, number>;\n\nfunction countInDegrees(dag: DirectedAcyclicGraph): InDegrees {\n  const counts: InDegrees = new Map();\n\n  for (const [vx, dependents] of dag.entries()) {\n    // Initialize count for current node if not present\n    if (!counts.has(vx)) {\n      counts.set(vx, 0);\n    }\n\n    for (const dependent of dependents) {\n      const currentCount = counts.get(dependent) ?? 0;\n      counts.set(dependent, currentCount + 1);\n    }\n  }\n\n  return counts;\n}\n\nfunction getRootsAndNonRoots(counts: InDegrees) {\n  const roots = new Set<NodeId>();\n  const nonRoots = new Set<NodeId>();\n\n  for (const [id, deg] of counts.entries()) {\n    if (deg === 0) {\n      roots.add(id);\n    } else {\n      nonRoots.add(id);\n    }\n  }\n\n  return { roots, nonRoots };\n}\n\nfunction reverse(deps: DirectedAcyclicGraph): DependencyGraph {\n  const reversedDeps: DependencyMap = new Map();\n\n  for (const [name, dependsOn] of deps.entries()) {\n    // Ensure the source node exists in the reversed map\n    if (!reversedDeps.has(name)) {\n      reversedDeps.set(name, new Set());\n    }\n\n    for (const dependsOnName of dependsOn) {\n      if (!reversedDeps.has(dependsOnName)) {\n        reversedDeps.set(dependsOnName, new Set());\n      }\n      reversedDeps.get(dependsOnName)!.add(name);\n    }\n  }\n\n  return reversedDeps;\n}\n\nexport function createDependencyGraph(): DependencyMap {\n  return new Map();\n}\n\nexport function addDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): DependencyMap {\n  if (!graph.has(from)) {\n    graph.set(from, new Set());\n  }\n  graph.get(from)!.add(to);\n  return graph;\n}\n\nexport function removeDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): boolean {\n  const dependents = graph.get(from);\n  if (!dependents) {\n    return false;\n  }\n  return dependents.delete(to);\n}\n\nexport function hasDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): boolean {\n  const dependents = graph.get(from);\n  return dependents ? dependents.has(to) : false;\n}\n\n/**\n * Sorts a list of items by their dependencies\n * @returns A function which can retrieve the priority of an item\n */\nexport function sortByDependencies(\n  items: { key: string; runsBefore?: ReadonlyArray<string> }[],\n) {\n  const dag = createDependencyGraph();\n\n  for (const item of items) {\n    if (Array.isArray(item.runsBefore) && item.runsBefore.length > 0) {\n      item.runsBefore.forEach((runBefore) => {\n        addDependency(dag, item.key, runBefore);\n      });\n    } else {\n      addDependency(dag, \"default\", item.key);\n    }\n  }\n  const sortedSpecs = toposortReverse(dag);\n  const defaultIndex = sortedSpecs.findIndex((set) => set.has(\"default\"));\n\n  /**\n   * The priority of an item is described relative to the \"default\" (an arbitrary string which can be used as the reference)\n   *\n   * Since items are topologically sorted, we can see what their relative position is to the \"default\"\n   * Each layer away from the default is 10 priority points (arbitrarily chosen)\n   * The default is fixed at 101 (1 point higher than any tiptap extension, giving priority to custom blocks than any defaults)\n   *\n   * This is a bit of a hack, but it's a simple way to ensure that custom items are always rendered with higher priority than default items\n   * and that custom items are rendered in the order they are defined in the list\n   */\n\n  /**\n   * Retrieves the priority of an item based on its position in the topologically sorted list\n   * @param key - The key of the item to get the priority of\n   * @returns The priority of the item\n   */\n  return (key: string) => {\n    const index = sortedSpecs.findIndex((set) => set.has(key));\n    // the default index should map to 101\n    // one before the default index is 91\n    // one after is 111\n    return 91 + (index + defaultIndex) * 10;\n  };\n}\n","import { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { sortByDependencies } from \"../util/topo-sort.js\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentConfig,\n  InlineContentSchema,\n  InlineContentSpec,\n  InlineContentSpecs,\n  LooseBlockSpec,\n  PartialBlockNoDefaults,\n  StyleSchema,\n  StyleSpecs,\n  addNodeAndExtensionsToSpec,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"./index.js\";\n\nfunction removeUndefined<T extends Record<string, any> | undefined>(obj: T): T {\n  if (!obj) {\n    return obj;\n  }\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, value]) => value !== undefined),\n  ) as T;\n}\n\nexport class CustomBlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> {\n  // Helper so that you can use typeof schema.BlockNoteEditor\n  public readonly BlockNoteEditor: BlockNoteEditor<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly Block: BlockNoDefaults<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly PartialBlock: PartialBlockNoDefaults<\n    BSchema,\n    ISchema,\n    SSchema\n  > = \"only for types\" as any;\n\n  public inlineContentSpecs: InlineContentSpecs;\n  public styleSpecs: StyleSpecs;\n  public blockSpecs: {\n    [K in keyof BSchema]: K extends string\n      ? LooseBlockSpec<K, BSchema[K][\"propSchema\"], BSchema[K][\"content\"]>\n      : never;\n  };\n\n  public blockSchema: BSchema;\n  public inlineContentSchema: ISchema;\n  public styleSchema: SSchema;\n\n  constructor(\n    private opts: {\n      blockSpecs: BlockSpecs;\n      inlineContentSpecs: InlineContentSpecs;\n      styleSpecs: StyleSpecs;\n    },\n  ) {\n    const {\n      blockSpecs,\n      inlineContentSpecs,\n      styleSpecs,\n      blockSchema,\n      inlineContentSchema,\n      styleSchema,\n    } = this.init();\n    this.blockSpecs = blockSpecs;\n    this.styleSpecs = styleSpecs;\n    this.styleSchema = styleSchema;\n    this.inlineContentSpecs = inlineContentSpecs;\n    this.blockSchema = blockSchema;\n    this.inlineContentSchema = inlineContentSchema;\n  }\n\n  private init() {\n    const getPriority = sortByDependencies(\n      Object.entries({\n        ...this.opts.blockSpecs,\n        ...this.opts.inlineContentSpecs,\n        ...this.opts.styleSpecs,\n      }).map(([key, val]) => ({\n        key: key,\n        runsBefore: val.implementation?.runsBefore ?? [],\n      })),\n    );\n\n    const blockSpecs = Object.fromEntries(\n      Object.entries(this.opts.blockSpecs).map(([key, blockSpec]) => {\n        return [\n          key,\n          addNodeAndExtensionsToSpec(\n            blockSpec.config,\n            blockSpec.implementation,\n            blockSpec.extensions,\n            getPriority(key),\n          ),\n        ];\n      }),\n    ) as {\n      [K in keyof BSchema]: K extends string\n        ? LooseBlockSpec<K, BSchema[K][\"propSchema\"], BSchema[K][\"content\"]>\n        : never;\n    };\n\n    const inlineContentSpecs = Object.fromEntries(\n      Object.entries(this.opts.inlineContentSpecs).map(\n        ([key, inlineContentSpec]) => {\n          // Case for text and links.\n          if (typeof inlineContentSpec.config !== \"object\") {\n            return [key, inlineContentSpec];\n          }\n\n          return [\n            key,\n            {\n              ...inlineContentSpec,\n              implementation: {\n                ...inlineContentSpec.implementation,\n                node: inlineContentSpec.implementation?.node.extend({\n                  priority: getPriority(key),\n                }),\n              },\n            },\n          ];\n        },\n      ),\n    ) as InlineContentSpecs;\n\n    const styleSpecs = Object.fromEntries(\n      Object.entries(this.opts.styleSpecs).map(([key, styleSpec]) => [\n        key,\n        {\n          ...styleSpec,\n          implementation: {\n            ...styleSpec.implementation,\n            mark: styleSpec.implementation?.mark.extend({\n              priority: getPriority(key),\n            }),\n          },\n        },\n      ]),\n    ) as StyleSpecs;\n\n    return {\n      blockSpecs,\n      blockSchema: Object.fromEntries(\n        Object.entries(blockSpecs).map(([key, blockDef]) => {\n          return [key, blockDef.config];\n        }),\n      ) as any,\n      inlineContentSpecs: removeUndefined(inlineContentSpecs),\n      styleSpecs: removeUndefined(styleSpecs),\n      inlineContentSchema: getInlineContentSchemaFromSpecs(\n        inlineContentSpecs,\n      ) as any,\n      styleSchema: getStyleSchemaFromSpecs(styleSpecs) as any,\n    };\n  }\n\n  /**\n   * Adds additional block specs to the current schema in a builder pattern.\n   * This method allows extending the schema after it has been created.\n   *\n   * @param additionalBlockSpecs - Additional block specs to add to the schema\n   * @returns The current schema instance for chaining\n   */\n  public extend<\n    AdditionalBlockSpecs extends BlockSpecs = Record<string, never>,\n    AdditionalInlineContentSpecs extends Record<\n      string,\n      InlineContentSpec<InlineContentConfig>\n    > = Record<string, never>,\n    AdditionalStyleSpecs extends StyleSpecs = Record<string, never>,\n  >(opts: {\n    blockSpecs?: AdditionalBlockSpecs;\n    inlineContentSpecs?: AdditionalInlineContentSpecs;\n    styleSpecs?: AdditionalStyleSpecs;\n  }): CustomBlockNoteSchema<\n    AdditionalBlockSpecs extends undefined | Record<string, never>\n      ? BSchema\n      : BSchema & {\n          [K in keyof AdditionalBlockSpecs]: K extends string\n            ? AdditionalBlockSpecs[K][\"config\"]\n            : never;\n        },\n    AdditionalInlineContentSpecs extends undefined | Record<string, never>\n      ? ISchema\n      : ISchema & {\n          [K in keyof AdditionalInlineContentSpecs]: AdditionalInlineContentSpecs[K][\"config\"];\n        },\n    AdditionalStyleSpecs extends undefined | Record<string, never>\n      ? SSchema\n      : SSchema & {\n          [K in keyof AdditionalStyleSpecs]: AdditionalStyleSpecs[K][\"config\"];\n        }\n  > {\n    // Merge the new specs with existing ones\n    Object.assign(this.opts.blockSpecs, opts.blockSpecs);\n    Object.assign(this.opts.inlineContentSpecs, opts.inlineContentSpecs);\n    Object.assign(this.opts.styleSpecs, opts.styleSpecs);\n\n    // Reinitialize the block specs with the merged specs\n    const {\n      blockSpecs,\n      inlineContentSpecs,\n      styleSpecs,\n      blockSchema,\n      inlineContentSchema,\n      styleSchema,\n    } = this.init();\n    this.blockSpecs = blockSpecs;\n    this.styleSpecs = styleSpecs;\n    this.styleSchema = styleSchema;\n    this.inlineContentSpecs = inlineContentSpecs;\n    this.blockSchema = blockSchema;\n    this.inlineContentSchema = inlineContentSchema;\n\n    return this as any;\n  }\n}\n","import {\n  BlockSchema,\n  createBlockConfig,\n  createBlockSpec,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteSchema } from \"../BlockNoteSchema.js\";\n\nexport type PageBreakBlockConfig = ReturnType<\n  typeof createPageBreakBlockConfig\n>;\n\nexport const createPageBreakBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"pageBreak\" as const,\n      propSchema: {},\n      content: \"none\",\n    }) as const,\n);\n\nexport const createPageBreakBlockSpec = createBlockSpec(\n  createPageBreakBlockConfig,\n  {\n    parse(element) {\n      if (\n        element.tagName === \"DIV\" &&\n        element.hasAttribute(\"data-page-break\")\n      ) {\n        return {};\n      }\n\n      return undefined;\n    },\n    render() {\n      const pageBreak = document.createElement(\"div\");\n\n      pageBreak.setAttribute(\"data-page-break\", \"\");\n\n      return {\n        dom: pageBreak,\n      };\n    },\n    toExternalHTML() {\n      const pageBreak = document.createElement(\"div\");\n\n      pageBreak.setAttribute(\"data-page-break\", \"\");\n\n      return {\n        dom: pageBreak,\n      };\n    },\n  },\n);\n\n/**\n * Adds page break support to the given schema.\n */\nexport const withPageBreak = <\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: BlockNoteSchema<B, I, S>,\n) => {\n  return schema.extend({\n    blockSpecs: {\n      pageBreak: createPageBreakBlockSpec(),\n    },\n  });\n};\n","/**\n * Uploads a file to tmpfiles.org and returns the URL to the uploaded file.\n *\n * @warning This function should only be used for development purposes, replace with your own backend!\n */\nexport const uploadToTmpFilesDotOrg_DEV_ONLY = async (\n  file: File,\n): Promise<string> => {\n  const body = new FormData();\n  body.append(\"file\", file);\n\n  const ret = await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: body,\n  });\n  return (await ret.json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\",\n  );\n};\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { DefaultSuggestionItem } from \"../../extensions/SuggestionMenu/DefaultSuggestionItem.js\";\nimport { insertOrUpdateBlockForSlashMenu } from \"../../extensions/SuggestionMenu/getDefaultSlashMenuItems.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { createPageBreakBlockConfig } from \"./block.js\";\n\nexport function checkPageBreakBlocksInSchema<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n): editor is BlockNoteEditor<\n  {\n    pageBreak: ReturnType<typeof createPageBreakBlockConfig>;\n  },\n  I,\n  S\n> {\n  return \"pageBreak\" in editor.schema.blockSchema;\n}\n\nexport function getPageBreakSlashMenuItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  const items: (Omit<DefaultSuggestionItem, \"key\"> & { key: \"page_break\" })[] =\n    [];\n\n  if (checkPageBreakBlocksInSchema(editor)) {\n    items.push({\n      ...editor.dictionary.slash_menu.page_break,\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"pageBreak\",\n        });\n      },\n      key: \"page_break\",\n    });\n  }\n\n  return items;\n}\n","import {\n  BlockSchema,\n  BlockSchemaFromSpecs,\n  BlockSpecs,\n  CustomBlockNoteSchema,\n  InlineContentSchema,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpecs,\n  StyleSchema,\n  StyleSchemaFromSpecs,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport {\n  defaultBlockSpecs,\n  defaultInlineContentSpecs,\n  defaultStyleSpecs,\n} from \"./defaultBlocks.js\";\n\nexport class BlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> extends CustomBlockNoteSchema<BSchema, ISchema, SSchema> {\n  public static create<\n    BSpecs extends BlockSpecs | undefined = undefined,\n    ISpecs extends InlineContentSpecs | undefined = undefined,\n    SSpecs extends StyleSpecs | undefined = undefined,\n  >(options?: {\n    /**\n     * A list of custom block types that should be available in the editor.\n     */\n    blockSpecs?: BSpecs;\n    /**\n     * A list of custom InlineContent types that should be available in the editor.\n     */\n    inlineContentSpecs?: ISpecs;\n    /**\n     * A list of custom Styles that should be available in the editor.\n     */\n    styleSpecs?: SSpecs;\n  }): BlockNoteSchema<\n    BSpecs extends undefined\n      ? BlockSchemaFromSpecs<typeof defaultBlockSpecs>\n      : BlockSchemaFromSpecs<NonNullable<BSpecs>>,\n    ISpecs extends undefined\n      ? InlineContentSchemaFromSpecs<typeof defaultInlineContentSpecs>\n      : InlineContentSchemaFromSpecs<NonNullable<ISpecs>>,\n    SSpecs extends undefined\n      ? StyleSchemaFromSpecs<typeof defaultStyleSpecs>\n      : StyleSchemaFromSpecs<NonNullable<SSpecs>>\n  > {\n    return new BlockNoteSchema<any, any, any>({\n      blockSpecs: options?.blockSpecs ?? defaultBlockSpecs,\n      inlineContentSpecs:\n        options?.inlineContentSpecs ?? defaultInlineContentSpecs,\n      styleSpecs: options?.styleSpecs ?? defaultStyleSpecs,\n    });\n  }\n}\n"],"names":["toposort","dag","inDegrees","countInDegrees","roots","nonRoots","getRootsAndNonRoots","sorted","newRoots","root","dependents","dependent","currentDegree","newDegree","toposortReverse","deps","reverse","counts","vx","currentCount","id","deg","reversedDeps","name","dependsOn","dependsOnName","createDependencyGraph","addDependency","graph","from","to","sortByDependencies","items","item","runBefore","sortedSpecs","defaultIndex","set","key","removeUndefined","obj","value","CustomBlockNoteSchema","opts","__publicField","blockSpecs","inlineContentSpecs","styleSpecs","blockSchema","inlineContentSchema","styleSchema","getPriority","val","_a","blockSpec","addNodeAndExtensionsToSpec","inlineContentSpec","styleSpec","blockDef","getInlineContentSchemaFromSpecs","getStyleSchemaFromSpecs","createPageBreakBlockConfig","createBlockConfig","createPageBreakBlockSpec","createBlockSpec","element","pageBreak","withPageBreak","schema","uploadToTmpFilesDotOrg_DEV_ONLY","file","body","checkPageBreakBlocksInSchema","editor","getPageBreakSlashMenuItems","insertOrUpdateBlockForSlashMenu","BlockNoteSchema","options","defaultBlockSpecs","defaultInlineContentSpecs","defaultStyleSpecs"],"mappings":"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"}