import { Extension as ot, combineTransactionSteps as rt, getChangedRanges as st, findChildrenInRange as it } from "@tiptap/core";
import { Slice as lt, Fragment as at } from "prosemirror-model";
import { Plugin as ct, PluginKey as ft } from "prosemirror-state";
import { v4 as ut } from "uuid";
function pt(t, o = JSON.stringify) {
  const r = {};
  return t.filter((n) => {
    const e = o(n);
    return Object.prototype.hasOwnProperty.call(r, e) ? !1 : r[e] = !0;
  });
}
function dt(t) {
  const o = t.filter(
    (n, e) => t.indexOf(n) !== e
  );
  return pt(o);
}
const Q = ot.create({
  name: "uniqueID",
  // we’ll set a very high priority to make sure this runs first
  // and is compatible with `appendTransaction` hooks of other extensions
  priority: 1e4,
  addOptions() {
    return {
      attributeName: "id",
      types: [],
      setIdAttribute: !1,
      generateID: () => {
        if (typeof window < "u" && window.__TEST_OPTIONS) {
          const t = window.__TEST_OPTIONS;
          return t.mockID === void 0 ? t.mockID = 0 : t.mockID++, t.mockID.toString();
        }
        return ut();
      },
      filterTransaction: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          [this.options.attributeName]: {
            default: null,
            parseHTML: (t) => t.getAttribute(`data-${this.options.attributeName}`),
            renderHTML: (t) => {
              const o = {
                [`data-${this.options.attributeName}`]: t[this.options.attributeName]
              };
              return this.options.setIdAttribute ? {
                ...o,
                id: t[this.options.attributeName]
              } : o;
            }
          }
        }
      }
    ];
  },
  // check initial content for missing ids
  // onCreate() {
  //   // Don’t do this when the collaboration extension is active
  //   // because this may update the content, so Y.js tries to merge these changes.
  //   // This leads to empty block nodes.
  //   // See: https://github.com/ueberdosis/tiptap/issues/2400
  //   if (
  //     this.editor.extensionManager.extensions.find(
  //       (extension) => extension.name === "collaboration"
  //     )
  //   ) {
  //     return;
  //   }
  //   const { view, state } = this.editor;
  //   const { tr, doc } = state;
  //   const { types, attributeName, generateID } = this.options;
  //   const nodesWithoutId = findChildren(doc, (node) => {
  //     return (
  //       types.includes(node.type.name) && node.attrs[attributeName] === null
  //     );
  //   });
  //   nodesWithoutId.forEach(({ node, pos }) => {
  //     tr.setNodeMarkup(pos, undefined, {
  //       ...node.attrs,
  //       [attributeName]: generateID(),
  //     });
  //   });
  //   tr.setMeta("addToHistory", false);
  //   view.dispatch(tr);
  // },
  addProseMirrorPlugins() {
    let t = null, o = !1;
    return [
      new ct({
        key: new ft("uniqueID"),
        appendTransaction: (r, n, e) => {
          const s = r.some((g) => g.docChanged) && !n.doc.eq(e.doc), i = this.options.filterTransaction && r.some((g) => {
            var C, d;
            return !((d = (C = this.options).filterTransaction) != null && d.call(C, g));
          });
          if (!s || i)
            return;
          const { tr: l } = e, { types: a, attributeName: c, generateID: h } = this.options, f = rt(
            n.doc,
            r
          ), { mapping: p } = f;
          if (st(f).forEach(({ newRange: g }) => {
            const C = it(
              e.doc,
              g,
              (y) => a.includes(y.type.name)
            ), d = C.map(({ node: y }) => y.attrs[c]).filter((y) => y !== null), w = dt(d);
            C.forEach(({ node: y, pos: m }) => {
              var z;
              const b = (z = l.doc.nodeAt(m)) == null ? void 0 : z.attrs[c];
              if (b === null) {
                const U = n.doc.type.createAndFill().content;
                if (n.doc.content.findDiffStart(U) === null) {
                  const q = JSON.parse(
                    JSON.stringify(e.doc.toJSON())
                  );
                  if (q.content[0].content[0].attrs.id = "initialBlockId", JSON.stringify(q.content) === JSON.stringify(U.toJSON())) {
                    l.setNodeMarkup(m, void 0, {
                      ...y.attrs,
                      [c]: "initialBlockId"
                    });
                    return;
                  }
                }
                l.setNodeMarkup(m, void 0, {
                  ...y.attrs,
                  [c]: h()
                });
                return;
              }
              const { deleted: k } = p.invert().mapResult(m);
              k && w.includes(b) && l.setNodeMarkup(m, void 0, {
                ...y.attrs,
                [c]: h()
              });
            });
          }), !!l.steps.length)
            return l.setMeta("uniqueID", !0), l;
        },
        // we register a global drag handler to track the current drag source element
        view(r) {
          const n = (e) => {
            let s;
            t = !((s = r.dom.parentElement) === null || s === void 0) && s.contains(e.target) ? r.dom.parentElement : null;
          };
          return window.addEventListener("dragstart", n), {
            destroy() {
              window.removeEventListener("dragstart", n);
            }
          };
        },
        props: {
          // `handleDOMEvents` is called before `transformPasted` so we can do
          // some checks before. However, `transformPasted` only runs when
          // editor content is pasted - not external content.
          handleDOMEvents: {
            // only create new ids for dropped content while holding `alt`
            // or content is dragged from another editor
            drop: (r, n) => {
              let e;
              return t !== r.dom.parentElement || ((e = n.dataTransfer) === null || e === void 0 ? void 0 : e.effectAllowed) === "copy" ? o = !0 : o = !1, t = null, !1;
            },
            // always create new ids on pasted content
            paste: () => (o = !0, !1)
          },
          // we’ll remove ids for every pasted node
          // so we can create a new one within `appendTransaction`
          transformPasted: (r) => {
            if (!o)
              return r;
            const { types: n, attributeName: e } = this.options, s = (i) => {
              const l = [];
              return i.forEach((a) => {
                if (a.isText) {
                  l.push(a);
                  return;
                }
                if (!n.includes(a.type.name)) {
                  l.push(a.copy(s(a.content)));
                  return;
                }
                const c = a.type.create(
                  {
                    ...a.attrs,
                    [e]: null
                  },
                  s(a.content),
                  a.marks
                );
                l.push(c);
              }), at.from(l);
            };
            return o = !1, new lt(
              s(r.content),
              r.openStart,
              r.openEnd
            );
          }
        }
      })
    ];
  }
});
function K(t) {
  return t.type === "link";
}
function X(t) {
  return typeof t != "string" && t.type === "link";
}
function B(t) {
  return typeof t != "string" && t.type === "text";
}
function S(t) {
  var o, r, n, e, s;
  return R(t) ? { ...t } : v(t) ? {
    type: "tableCell",
    content: [].concat(t.content),
    props: {
      backgroundColor: ((o = t.props) == null ? void 0 : o.backgroundColor) ?? "default",
      textColor: ((r = t.props) == null ? void 0 : r.textColor) ?? "default",
      textAlignment: ((n = t.props) == null ? void 0 : n.textAlignment) ?? "left",
      colspan: ((e = t.props) == null ? void 0 : e.colspan) ?? 1,
      rowspan: ((s = t.props) == null ? void 0 : s.rowspan) ?? 1
    }
  } : {
    type: "tableCell",
    content: [].concat(t),
    props: {
      backgroundColor: "default",
      textColor: "default",
      textAlignment: "left",
      colspan: 1,
      rowspan: 1
    }
  };
}
function v(t) {
  return t != null && typeof t != "string" && !Array.isArray(t) && t.type === "tableCell";
}
function R(t) {
  return v(t) && t.props !== void 0 && t.content !== void 0;
}
function A(t) {
  return R(t) ? t.props.colspan ?? 1 : 1;
}
function D(t) {
  return R(t) ? t.props.rowspan ?? 1 : 1;
}
class O extends Error {
  constructor(o) {
    super(`Unreachable case: ${o}`);
  }
}
function At(t, o = !0) {
  const { "data-test": r, ...n } = t;
  if (Object.keys(n).length > 0 && o)
    throw new Error("Object must be empty " + JSON.stringify(t));
}
function Y(t, o) {
  const r = t.resolve(o);
  if (r.nodeAfter && r.nodeAfter.type.isInGroup("bnBlock"))
    return {
      posBeforeNode: r.pos,
      node: r.nodeAfter
    };
  let n = r.depth, e = r.node(n);
  for (; n > 0; ) {
    if (e.type.isInGroup("bnBlock"))
      return {
        posBeforeNode: r.before(n),
        node: e
      };
    n--, e = r.node(n);
  }
  const s = [];
  t.descendants((l, a) => {
    l.type.isInGroup("bnBlock") && s.push(a);
  }), console.warn(`Position ${o} is not within a blockContainer node.`);
  const i = t.resolve(
    s.find((l) => l >= o) || s[s.length - 1]
  );
  return {
    posBeforeNode: i.pos,
    node: i.nodeAfter
  };
}
function $(t, o) {
  if (!t.type.isInGroup("bnBlock"))
    throw new Error(
      `Attempted to get bnBlock node at position but found node of different type ${t.type.name}`
    );
  const r = t, n = o, e = n + r.nodeSize, s = {
    node: r,
    beforePos: n,
    afterPos: e
  };
  if (r.type.name === "blockContainer") {
    let i, l;
    if (r.forEach((a, c) => {
      if (a.type.spec.group === "blockContent") {
        const h = a, f = n + c + 1, p = f + a.nodeSize;
        i = {
          node: h,
          beforePos: f,
          afterPos: p
        };
      } else if (a.type.name === "blockGroup") {
        const h = a, f = n + c + 1, p = f + a.nodeSize;
        l = {
          node: h,
          beforePos: f,
          afterPos: p
        };
      }
    }), !i)
      throw new Error(
        `blockContainer node does not contain a blockContent node in its children: ${r}`
      );
    return {
      isBlockContainer: !0,
      bnBlock: s,
      blockContent: i,
      childContainer: l,
      blockNoteType: i.node.type.name
    };
  } else {
    if (!s.node.type.isInGroup("childContainer"))
      throw new Error(
        `bnBlock node is not in the childContainer group: ${s.node}`
      );
    return {
      isBlockContainer: !1,
      bnBlock: s,
      childContainer: s,
      blockNoteType: s.node.type.name
    };
  }
}
function Z(t) {
  return $(t.node, t.posBeforeNode);
}
function It(t) {
  if (!t.nodeAfter)
    throw new Error(
      `Attempted to get blockContainer node at position ${t.pos} but a node at this position does not exist`
    );
  return $(t.nodeAfter, t.pos);
}
function Tt(t) {
  const o = Y(t.doc, t.selection.anchor);
  return Z(o);
}
function Ot(t) {
  const o = Y(t.doc, t.selection.anchor);
  return Z(o);
}
function ht(t) {
  return "doc" in t ? t.doc.type.schema : t.type.schema;
}
function G(t) {
  return t.cached.blockNoteEditor;
}
function J(t) {
  return G(t).schema;
}
function _(t) {
  return J(t).blockSchema;
}
function H(t) {
  return J(t).inlineContentSchema;
}
function N(t) {
  return J(t).styleSchema;
}
function j(t) {
  return G(t).blockCache;
}
function gt(t, o, r) {
  var s, i;
  const n = {
    type: "tableContent",
    columnWidths: [],
    headerRows: void 0,
    headerCols: void 0,
    rows: []
  }, e = [];
  t.content.forEach((l, a, c) => {
    const h = {
      cells: []
    };
    c === 0 && l.content.forEach((f) => {
      let p = f.attrs.colwidth;
      p == null && (p = new Array(f.attrs.colspan ?? 1).fill(void 0)), n.columnWidths.push(...p);
    }), h.cells = l.content.content.map((f, p) => (e[c] || (e[c] = []), e[c][p] = f.type.name === "tableHeader", {
      type: "tableCell",
      content: f.content.content.map(
        (g) => F(g, o, r)
      ).reduce(
        (g, C) => {
          if (!g.length)
            return C;
          const d = g[g.length - 1], w = C[0];
          return w && B(d) && B(w) && JSON.stringify(d.styles) === JSON.stringify(w.styles) ? (d.text += `
` + w.text, g.push(...C.slice(1)), g) : (g.push(...C), g);
        },
        []
      ),
      props: {
        colspan: f.attrs.colspan,
        rowspan: f.attrs.rowspan,
        backgroundColor: f.attrs.backgroundColor,
        textColor: f.attrs.textColor,
        textAlignment: f.attrs.textAlignment
      }
    })), n.rows.push(h);
  });
  for (let l = 0; l < e.length; l++)
    (s = e[l]) != null && s.every((a) => a) && (n.headerRows = (n.headerRows ?? 0) + 1);
  for (let l = 0; l < ((i = e[0]) == null ? void 0 : i.length); l++)
    e != null && e.every((a) => a[l]) && (n.headerCols = (n.headerCols ?? 0) + 1);
  return n;
}
function F(t, o, r) {
  const n = [];
  let e;
  return t.content.forEach((s) => {
    if (s.type.name === "hardBreak") {
      if (e)
        if (B(e))
          e.text += `
`;
        else if (K(e))
          e.content[e.content.length - 1].text += `
`;
        else
          throw new Error("unexpected");
      else
        e = {
          type: "text",
          text: `
`,
          styles: {}
        };
      return;
    }
    if (s.type.name !== "link" && s.type.name !== "text") {
      if (!o[s.type.name]) {
        console.warn("unrecognized inline content type", s.type.name);
        return;
      }
      e && (n.push(e), e = void 0), n.push(
        wt(s, o, r)
      );
      return;
    }
    const i = {};
    let l;
    for (const a of s.marks)
      if (a.type.name === "link")
        l = a;
      else {
        const c = r[a.type.name];
        if (!c) {
          if (a.type.spec.blocknoteIgnore)
            continue;
          throw new Error(`style ${a.type.name} not found in styleSchema`);
        }
        if (c.propSchema === "boolean")
          i[c.type] = !0;
        else if (c.propSchema === "string")
          i[c.type] = a.attrs.stringValue;
        else
          throw new O(c.propSchema);
      }
    e ? B(e) ? l ? (n.push(e), e = {
      type: "link",
      href: l.attrs.href,
      content: [
        {
          type: "text",
          text: s.textContent,
          styles: i
        }
      ]
    }) : JSON.stringify(e.styles) === JSON.stringify(i) ? e.text += s.textContent : (n.push(e), e = {
      type: "text",
      text: s.textContent,
      styles: i
    }) : K(e) && (l ? e.href === l.attrs.href ? JSON.stringify(
      e.content[e.content.length - 1].styles
    ) === JSON.stringify(i) ? e.content[e.content.length - 1].text += s.textContent : e.content.push({
      type: "text",
      text: s.textContent,
      styles: i
    }) : (n.push(e), e = {
      type: "link",
      href: l.attrs.href,
      content: [
        {
          type: "text",
          text: s.textContent,
          styles: i
        }
      ]
    }) : (n.push(e), e = {
      type: "text",
      text: s.textContent,
      styles: i
    })) : l ? e = {
      type: "link",
      href: l.attrs.href,
      content: [
        {
          type: "text",
          text: s.textContent,
          styles: i
        }
      ]
    } : e = {
      type: "text",
      text: s.textContent,
      styles: i
    };
  }), e && n.push(e), n;
}
function wt(t, o, r) {
  if (t.type.name === "text" || t.type.name === "link")
    throw new Error("unexpected");
  const n = {}, e = o[t.type.name];
  for (const [l, a] of Object.entries(t.attrs)) {
    if (!e)
      throw Error("ic node is of an unrecognized type: " + t.type.name);
    const c = e.propSchema;
    l in c && (n[l] = a);
  }
  let s;
  return e.content === "styled" ? s = F(
    t,
    o,
    r
  ) : s = void 0, {
    type: t.type.name,
    props: n,
    content: s
  };
}
function L(t, o, r = _(o), n = H(o), e = N(o), s = j(o)) {
  var C;
  if (!t.type.isInGroup("bnBlock"))
    throw Error("Node should be a bnBlock, but is instead: " + t.type.name);
  const i = s == null ? void 0 : s.get(t);
  if (i)
    return i;
  const l = $(t, 0);
  let a = l.bnBlock.node.attrs.id;
  a === null && (a = Q.options.generateID());
  const c = r[l.blockNoteType];
  if (!c)
    throw Error("Block is of an unrecognized type: " + l.blockNoteType);
  const h = {};
  for (const [d, w] of Object.entries({
    ...t.attrs,
    ...l.isBlockContainer ? l.blockContent.node.attrs : {}
  })) {
    const y = c.propSchema;
    d in y && !(y[d].default === void 0 && w === void 0) && (h[d] = w);
  }
  const f = r[l.blockNoteType], p = [];
  (C = l.childContainer) == null || C.node.forEach((d) => {
    p.push(
      L(
        d,
        o,
        r,
        n,
        e,
        s
      )
    );
  });
  let u;
  if (f.content === "inline") {
    if (!l.isBlockContainer)
      throw new Error("impossible");
    u = F(
      l.blockContent.node,
      n,
      e
    );
  } else if (f.content === "table") {
    if (!l.isBlockContainer)
      throw new Error("impossible");
    u = gt(
      l.blockContent.node,
      n,
      e
    );
  } else if (f.content === "none")
    u = void 0;
  else
    throw new O(f.content);
  const g = {
    id: a,
    type: f.type,
    props: h,
    content: u,
    children: p
  };
  return s == null || s.set(t, g), g;
}
function St(t, o = ht(t), r = _(o), n = H(o), e = N(o), s = j(o)) {
  const i = [];
  return t.firstChild && t.firstChild.descendants((l) => (i.push(
    L(
      l,
      o,
      r,
      n,
      e,
      s
    )
  ), !1)), i;
}
function Dt(t, o, r = _(o), n = H(o), e = N(o), s = j(o)) {
  function i(l, a, c) {
    if (l.type.name !== "blockGroup")
      throw new Error("unexpected");
    const h = [];
    let f, p;
    return l.forEach((u, g, C) => {
      if (u.type.name !== "blockContainer")
        throw new Error("unexpected");
      if (u.childCount === 0)
        return;
      if (u.childCount === 0 || u.childCount > 2)
        throw new Error(
          "unexpected, blockContainer.childCount: " + u.childCount
        );
      const d = C === 0, w = C === l.childCount - 1;
      if (u.firstChild.type.name === "blockGroup") {
        if (!d)
          throw new Error("unexpected");
        const k = i(
          u.firstChild,
          Math.max(0, a - 1),
          w ? Math.max(0, c - 1) : 0
        );
        f = k.blockCutAtStart, w && (p = k.blockCutAtEnd), h.push(...k.blocks);
        return;
      }
      const y = L(
        u,
        o,
        r,
        n,
        e,
        s
      ), m = u.childCount > 1 ? u.child(1) : void 0;
      let b = [];
      if (m) {
        const k = i(
          m,
          0,
          // TODO: can this be anything other than 0?
          w ? Math.max(0, c - 1) : 0
        );
        b = k.blocks, w && (p = k.blockCutAtEnd);
      }
      w && !m && c > 1 && (p = y.id), d && a > 1 && (f = y.id), h.push({
        ...y,
        children: b
      });
    }), { blocks: h, blockCutAtStart: f, blockCutAtEnd: p };
  }
  if (t.content.childCount === 0)
    return {
      blocks: [],
      blockCutAtStart: void 0,
      blockCutAtEnd: void 0
    };
  if (t.content.childCount !== 1)
    throw new Error(
      "slice must be a single block, did you forget includeParents=true?"
    );
  return i(
    t.content.firstChild,
    Math.max(t.openStart - 1, 0),
    Math.max(t.openEnd - 1, 0)
  );
}
function x(t) {
  const { height: o, width: r } = tt(t), n = new Array(o).fill(!1).map(() => new Array(r).fill(null)), e = (s, i) => {
    for (let l = s; l < o; l++)
      for (let a = i; a < r; a++)
        if (!n[l][a])
          return { row: l, col: a };
    throw new Error(
      "Unable to create occupancy grid for table, no more available cells"
    );
  };
  for (let s = 0; s < t.content.rows.length; s++)
    for (let i = 0; i < t.content.rows[s].cells.length; i++) {
      const l = S(t.content.rows[s].cells[i]), a = D(l), c = A(l), { row: h, col: f } = e(s, i);
      for (let p = h; p < h + a; p++)
        for (let u = f; u < f + c; u++) {
          if (n[p][u])
            throw new Error(
              `Unable to create occupancy grid for table, cell at ${p},${u} is already occupied`
            );
          n[p][u] = {
            row: s,
            col: i,
            rowspan: a,
            colspan: c,
            cell: l
          };
        }
    }
  return n;
}
function I(t) {
  const o = /* @__PURE__ */ new Set();
  return t.map((r) => ({
    cells: r.map((n) => o.has(n.row + ":" + n.col) ? !1 : (o.add(n.row + ":" + n.col), n.cell)).filter((n) => n !== !1)
  }));
}
function E(t, o, r = x(o)) {
  for (let n = 0; n < r.length; n++)
    for (let e = 0; e < r[n].length; e++) {
      const s = r[n][e];
      if (s && s.row === t.row && s.col === t.col)
        return { row: n, col: e, cell: s.cell };
    }
  throw new Error(
    `Unable to resolve relative table cell indices for table, cell at ${t.row},${t.col} is not occupied`
  );
}
function tt(t) {
  const o = t.content.rows.length;
  let r = 0;
  return t.content.rows.forEach((n) => {
    let e = 0;
    n.cells.forEach((s) => {
      e += A(s);
    }), r = Math.max(r, e);
  }), { height: o, width: r };
}
function et(t, o, r = x(o)) {
  var e;
  const n = (e = r[t.row]) == null ? void 0 : e[t.col];
  if (n)
    return {
      row: n.row,
      col: n.col,
      cell: n.cell
    };
}
function yt(t, o) {
  var s;
  const r = x(t);
  if (o < 0 || o >= r.length)
    return [];
  let n = 0;
  for (let i = 0; i < o; i++) {
    const l = (s = r[n]) == null ? void 0 : s[0];
    if (!l)
      return [];
    n += l.rowspan;
  }
  const e = new Array(r[0].length).fill(!1).map((i, l) => et(
    { row: n, col: l },
    t,
    r
  )).filter(
    (i) => i !== void 0
  );
  return e.filter((i, l) => e.findIndex((a) => a.row === i.row && a.col === i.col) === l);
}
function Ct(t, o) {
  var s;
  const r = x(t);
  if (o < 0 || o >= r[0].length)
    return [];
  let n = 0;
  for (let i = 0; i < o; i++) {
    const l = (s = r[0]) == null ? void 0 : s[n];
    if (!l)
      return [];
    n += l.colspan;
  }
  const e = new Array(r.length).fill(!1).map((i, l) => et(
    { row: l, col: n },
    t,
    r
  )).filter(
    (i) => i !== void 0
  );
  return e.filter((i, l) => e.findIndex((a) => a.row === i.row && a.col === i.col) === l);
}
function Mt(t, o, r, n = x(t)) {
  const { col: e } = E(
    {
      row: 0,
      col: o
    },
    t,
    n
  ), { col: s } = E(
    {
      row: 0,
      col: r
    },
    t,
    n
  );
  return n.forEach((i) => {
    const [l] = i.splice(e, 1);
    i.splice(s, 0, l);
  }), I(n);
}
function Pt(t, o, r, n = x(t)) {
  const { row: e } = E(
    {
      row: o,
      col: 0
    },
    t,
    n
  ), { row: s } = E(
    {
      row: r,
      col: 0
    },
    t,
    n
  ), [i] = n.splice(e, 1);
  return n.splice(s, 0, i), I(n);
}
function M(t) {
  return t ? v(t) ? M(t.content) : typeof t == "string" ? t.length === 0 : Array.isArray(t) ? t.every(
    (o) => typeof o == "string" ? o.length === 0 : B(o) ? o.text.length === 0 : X(o) ? typeof o.content == "string" ? o.content.length === 0 : o.content.every((r) => r.text.length === 0) : !1
  ) : !1 : !0;
}
function Rt(t, o, r = x(t)) {
  if (o === "columns") {
    let s = 0;
    for (let i = r[0].length - 1; i >= 0 && r.every(
      (a) => M(a[i].cell) && a[i].colspan === 1
    ); i--)
      s++;
    for (let i = r.length - 1; i >= 0; i--) {
      const l = Math.max(
        r[i].length - s,
        1
      );
      r[i] = r[i].slice(0, l);
    }
    return I(r);
  }
  let n = 0;
  for (let s = r.length - 1; s >= 0 && r[s].every(
    (l) => M(l.cell) && l.rowspan === 1
  ); s--)
    n++;
  const e = Math.min(n, r.length - 1);
  return r.splice(r.length - e, e), I(r);
}
function $t(t, o, r, n = x(t)) {
  const { width: e, height: s } = tt(t);
  if (o === "columns")
    n.forEach((i, l) => {
      if (r >= 0)
        for (let a = 0; a < r; a++)
          i.push({
            row: l,
            col: Math.max(...i.map((c) => c.col)) + 1,
            rowspan: 1,
            colspan: 1,
            cell: S("")
          });
      else
        i.splice(e + r, -1 * r);
    });
  else if (r > 0)
    for (let i = 0; i < r; i++) {
      const l = new Array(e).fill(null).map((a, c) => ({
        row: s + i,
        col: c,
        rowspan: 1,
        colspan: 1,
        cell: S("")
      }));
      n.push(l);
    }
  else r < 0 && n.splice(s + r, -1 * r);
  return I(n);
}
function Jt(t, o, r) {
  const n = yt(t, r);
  if (!n.some((a) => D(a.cell) > 1))
    return !0;
  let s = r, i = r;
  return n.forEach((a) => {
    const c = D(a.cell);
    s = Math.max(s, a.row + c - 1), i = Math.min(i, a.row);
  }), o < r ? r === s : r === i;
}
function _t(t, o, r) {
  const n = Ct(t, r);
  if (!n.some((a) => A(a.cell) > 1))
    return !0;
  let s = r, i = r;
  return n.forEach((a) => {
    const c = A(a.cell);
    s = Math.max(s, a.col + c - 1), i = Math.min(i, a.col);
  }), o < r ? r === s : r === i;
}
function Ht(t, o, r) {
  const n = E(t, r), e = E(o, r);
  return n.col === e.col;
}
function V(t, o, r, n) {
  const e = [];
  for (const [i, l] of Object.entries(t.styles || {})) {
    const a = r[i];
    if (!a)
      throw new Error(`style ${i} not found in styleSchema`);
    if (a.propSchema === "boolean")
      l && e.push(o.mark(i));
    else if (a.propSchema === "string")
      l && e.push(o.mark(i, { stringValue: l }));
    else
      throw new O(a.propSchema);
  }
  return !n || !o.nodes[n].spec.code ? t.text.split(/(\n)/g).filter((i) => i.length > 0).map((i) => i === `
` ? o.nodes.hardBreak.createChecked() : o.text(i, e)) : t.text.length > 0 ? [o.text(t.text, e)] : [];
}
function mt(t, o, r) {
  const n = o.marks.link.create({
    href: t.href
  });
  return P(t.content, o, r).map(
    (e) => {
      if (e.type.name === "text")
        return e.mark([...e.marks, n]);
      if (e.type.name === "hardBreak")
        return e;
      throw new Error("unexpected node type");
    }
  );
}
function P(t, o, r, n) {
  const e = [];
  if (typeof t == "string")
    return e.push(
      ...V(
        { text: t, styles: {} },
        o,
        r,
        n
      )
    ), e;
  for (const s of t)
    e.push(
      ...V(s, o, r, n)
    );
  return e;
}
function T(t, o, r, n = N(o)) {
  const e = [];
  for (const s of t)
    typeof s == "string" ? e.push(
      ...P(s, o, n, r)
    ) : X(s) ? e.push(...mt(s, o, n)) : B(s) ? e.push(
      ...P([s], o, n, r)
    ) : e.push(
      nt(s, o, n)
    );
  return e;
}
function kt(t, o, r = N(o)) {
  const n = [], e = new Array(t.headerRows ?? 0).fill(!0), s = new Array(t.headerCols ?? 0).fill(!0), i = t.columnWidths ?? [];
  for (let l = 0; l < t.rows.length; l++) {
    const a = t.rows[l], c = [], h = e[l];
    for (let p = 0; p < a.cells.length; p++) {
      const u = a.cells[p], g = s[p], C = void 0;
      let d = null;
      const w = E(
        {
          row: l,
          col: p
        },
        { content: t }
      );
      let y = i[w.col] ? [i[w.col]] : null;
      if (u) if (typeof u == "string")
        d = o.text(u);
      else if (v(u)) {
        u.content && (d = T(
          u.content,
          o,
          "tableParagraph",
          r
        ));
        const b = A(u);
        b > 1 && (y = new Array(b).fill(!1).map((k, W) => i[w.col + W] ?? void 0));
      } else
        d = T(
          u,
          o,
          "tableParagraph",
          r
        );
      const m = o.nodes[g || h ? "tableHeader" : "tableCell"].createChecked(
        {
          ...v(u) ? u.props : {},
          colwidth: y
        },
        o.nodes.tableParagraph.createChecked(C, d)
      );
      c.push(m);
    }
    const f = o.nodes.tableRow.createChecked({}, c);
    n.push(f);
  }
  return n;
}
function nt(t, o, r) {
  let n, e = t.type;
  if (e === void 0 && (e = "paragraph"), !o.nodes[e])
    throw new Error(`node type ${e} not found in schema`);
  if (!t.content)
    n = o.nodes[e].createChecked(t.props);
  else if (typeof t.content == "string") {
    const s = T(
      [t.content],
      o,
      e,
      r
    );
    n = o.nodes[e].createChecked(t.props, s);
  } else if (Array.isArray(t.content)) {
    const s = T(
      t.content,
      o,
      e,
      r
    );
    n = o.nodes[e].createChecked(t.props, s);
  } else if (t.content.type === "tableContent") {
    const s = kt(t.content, o, r);
    n = o.nodes[e].createChecked(t.props, s);
  } else
    throw new O(t.content.type);
  return n;
}
function bt(t, o, r = N(o)) {
  let n = t.id;
  n === void 0 && (n = Q.options.generateID());
  const e = [];
  if (t.children)
    for (const i of t.children)
      e.push(bt(i, o, r));
  if (!t.type || // can happen if block.type is not defined (this should create the default node)
  o.nodes[t.type].isInGroup("blockContent")) {
    const i = nt(
      t,
      o,
      r
    ), l = e.length > 0 ? o.nodes.blockGroup.createChecked({}, e) : void 0;
    return o.nodes.blockContainer.createChecked(
      {
        id: n,
        ...t.props
      },
      l ? [i, l] : i
    );
  } else {
    if (o.nodes[t.type].isInGroup("bnBlock"))
      return o.nodes[t.type].createChecked(
        {
          id: n,
          ...t.props
        },
        e
      );
    throw new Error(
      `block type ${t.type} doesn't match blockContent or bnBlock group`
    );
  }
}
export {
  Z as A,
  At as B,
  $ as C,
  _ as D,
  H as E,
  N as F,
  j as G,
  K as H,
  X as I,
  B as J,
  S as K,
  v as L,
  R as M,
  A as N,
  D as O,
  O as U,
  L as a,
  bt as b,
  Jt as c,
  St as d,
  _t as e,
  Mt as f,
  ht as g,
  tt as h,
  T as i,
  $t as j,
  Rt as k,
  Ht as l,
  Pt as m,
  wt as n,
  Ct as o,
  yt as p,
  Y as q,
  Ot as r,
  gt as s,
  kt as t,
  F as u,
  It as v,
  Tt as w,
  Q as x,
  Dt as y,
  J as z
};
//# sourceMappingURL=blockToNode-BNoNIXU7.js.map
