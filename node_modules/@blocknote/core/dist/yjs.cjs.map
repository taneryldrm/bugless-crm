{"version":3,"file":"yjs.cjs","sources":["../src/yjs/utils.ts"],"sourcesContent":["import {\n  prosemirrorToYDoc,\n  prosemirrorToYXmlFragment,\n  yXmlFragmentToProseMirrorRootNode,\n} from \"y-prosemirror\";\nimport * as Y from \"yjs\";\n\nimport {\n  type Block,\n  type BlockNoteEditor,\n  type BlockSchema,\n  type InlineContentSchema,\n  type PartialBlock,\n  type StyleSchema,\n  blockToNode,\n  docToBlocks,\n} from \"../index.js\";\n\n/**\n * Turn Prosemirror JSON to BlockNote style JSON\n * @param editor BlockNote editor\n * @param json Prosemirror JSON\n * @returns BlockNote style JSON\n */\nexport function _prosemirrorJSONToBlocks<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, ISchema, SSchema>, json: any) {\n  // note: theoretically this should also be possible without creating prosemirror nodes,\n  // but this is definitely the easiest way\n  const doc = editor.pmSchema.nodeFromJSON(json);\n  return docToBlocks<BSchema, ISchema, SSchema>(doc);\n}\n\n/**\n * Turn BlockNote JSON to Prosemirror node / state\n * @param editor BlockNote editor\n * @param blocks BlockNote blocks\n * @returns Prosemirror root node\n */\nexport function _blocksToProsemirrorNode<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  blocks: PartialBlock<BSchema, ISchema, SSchema>[],\n) {\n  const pmNodes = blocks.map((b) => blockToNode(b, editor.pmSchema));\n\n  const doc = editor.pmSchema.topNodeType.create(\n    null,\n    editor.pmSchema.nodes[\"blockGroup\"].create(null, pmNodes),\n  );\n  return doc;\n}\n\n/** YJS / BLOCKNOTE conversions */\n\n/**\n * Turn a Y.XmlFragment collaborative doc into a BlockNote document (BlockNote style JSON of all blocks)\n * @param editor BlockNote editor\n * @param xmlFragment Y.XmlFragment\n * @returns BlockNote document (BlockNote style JSON of all blocks)\n */\nexport function yXmlFragmentToBlocks<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  xmlFragment: Y.XmlFragment,\n) {\n  const pmNode = yXmlFragmentToProseMirrorRootNode(\n    xmlFragment,\n    editor.pmSchema,\n  );\n  return docToBlocks<BSchema, ISchema, SSchema>(pmNode);\n}\n\n/**\n * Convert blocks to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param editor BlockNote editor\n * @param blocks the blocks to convert\n * @param xmlFragment XML fragment name\n * @returns Y.XmlFragment\n */\nexport function blocksToYXmlFragment<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  blocks: Block<BSchema, ISchema, SSchema>[],\n  xmlFragment?: Y.XmlFragment,\n) {\n  return prosemirrorToYXmlFragment(\n    _blocksToProsemirrorNode(editor, blocks),\n    xmlFragment,\n  );\n}\n\n/**\n * Turn a Y.Doc collaborative doc into a BlockNote document (BlockNote style JSON of all blocks)\n * @param editor BlockNote editor\n * @param ydoc Y.Doc\n * @param xmlFragment XML fragment name\n * @returns BlockNote document (BlockNote style JSON of all blocks)\n */\nexport function yDocToBlocks<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  ydoc: Y.Doc,\n  xmlFragment = \"prosemirror\",\n) {\n  return yXmlFragmentToBlocks(editor, ydoc.getXmlFragment(xmlFragment));\n}\n\n/**\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param editor BlockNote editor\n * @param blocks the blocks to convert\n * @param xmlFragment XML fragment name\n */\nexport function blocksToYDoc<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n  blocks: PartialBlock<BSchema, ISchema, SSchema>[],\n  xmlFragment = \"prosemirror\",\n) {\n  return prosemirrorToYDoc(\n    _blocksToProsemirrorNode(editor, blocks),\n    xmlFragment,\n  );\n}\n"],"names":["_prosemirrorJSONToBlocks","editor","json","doc","docToBlocks","_blocksToProsemirrorNode","blocks","pmNodes","b","blockToNode","yXmlFragmentToBlocks","xmlFragment","pmNode","yXmlFragmentToProseMirrorRootNode","blocksToYXmlFragment","prosemirrorToYXmlFragment","yDocToBlocks","ydoc","blocksToYDoc","prosemirrorToYDoc"],"mappings":"yJAwBO,SAASA,EAIdC,EAAoDC,EAAW,CAG/D,MAAMC,EAAMF,EAAO,SAAS,aAAaC,CAAI,EAC7C,OAAOE,EAAAA,YAAuCD,CAAG,CACnD,CAQO,SAASE,EAKdJ,EACAK,EACA,CACA,MAAMC,EAAUD,EAAO,IAAKE,GAAMC,EAAAA,YAAYD,EAAGP,EAAO,QAAQ,CAAC,EAMjE,OAJYA,EAAO,SAAS,YAAY,OACtC,KACAA,EAAO,SAAS,MAAM,WAAc,OAAO,KAAMM,CAAO,CAAA,CAG5D,CAUO,SAASG,EAKdT,EACAU,EACA,CACA,MAAMC,EAASC,EAAAA,kCACbF,EACAV,EAAO,QAAA,EAET,OAAOG,EAAAA,YAAuCQ,CAAM,CACtD,CAcO,SAASE,EAKdb,EACAK,EACAK,EACA,CACA,OAAOI,EAAAA,0BACLV,EAAyBJ,EAAQK,CAAM,EACvCK,CAAA,CAEJ,CASO,SAASK,EAKdf,EACAgB,EACAN,EAAc,cACd,CACA,OAAOD,EAAqBT,EAAQgB,EAAK,eAAeN,CAAW,CAAC,CACtE,CAWO,SAASO,EAKdjB,EACAK,EACAK,EAAc,cACd,CACA,OAAOQ,EAAAA,kBACLd,EAAyBJ,EAAQK,CAAM,EACvCK,CAAA,CAEJ"}