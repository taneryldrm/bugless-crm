var u = Object.defineProperty;
var k = (t, e, n) => e in t ? u(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var i = (t, e, n) => k(t, typeof e != "symbol" ? e + "" : e, n);
import { ad as g, ae as y, af as b, ag as B, ah as C, aa as w, X as O, Z as j, W as x } from "./defaultBlocks-DvCGYzqu.js";
function E(t) {
  const e = v(t);
  let { roots: n, nonRoots: r } = f(e);
  const s = [];
  for (; n.size; ) {
    s.push(n);
    const o = /* @__PURE__ */ new Set();
    for (const c of n) {
      const a = t.get(c);
      if (a)
        for (const l of a) {
          const p = e.get(l);
          if (p === void 0)
            continue;
          const d = p - 1;
          e.set(l, d), d === 0 && o.add(l);
        }
    }
    n = o;
  }
  if (r = f(e).nonRoots, r.size)
    throw new Error(
      `Cycle(s) detected; toposort only works on acyclic graphs. Cyclic nodes: ${Array.from(r).join(", ")}`
    );
  return s;
}
function D(t) {
  const e = I(t);
  return E(e);
}
function v(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [n, r] of t.entries()) {
    e.has(n) || e.set(n, 0);
    for (const s of r) {
      const o = e.get(s) ?? 0;
      e.set(s, o + 1);
    }
  }
  return e;
}
function f(t) {
  const e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (const [r, s] of t.entries())
    s === 0 ? e.add(r) : n.add(r);
  return { roots: e, nonRoots: n };
}
function I(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [n, r] of t.entries()) {
    e.has(n) || e.set(n, /* @__PURE__ */ new Set());
    for (const s of r)
      e.has(s) || e.set(s, /* @__PURE__ */ new Set()), e.get(s).add(n);
  }
  return e;
}
function A() {
  return /* @__PURE__ */ new Map();
}
function m(t, e, n) {
  return t.has(e) || t.set(e, /* @__PURE__ */ new Set()), t.get(e).add(n), t;
}
function P(t) {
  const e = A();
  for (const s of t)
    Array.isArray(s.runsBefore) && s.runsBefore.length > 0 ? s.runsBefore.forEach((o) => {
      m(e, s.key, o);
    }) : m(e, "default", s.key);
  const n = D(e), r = n.findIndex((s) => s.has("default"));
  return (s) => 91 + (n.findIndex((c) => c.has(s)) + r) * 10;
}
function S(t) {
  return t && Object.fromEntries(
    Object.entries(t).filter(([, e]) => e !== void 0)
  );
}
class N {
  constructor(e) {
    // Helper so that you can use typeof schema.BlockNoteEditor
    i(this, "BlockNoteEditor", "only for types");
    i(this, "Block", "only for types");
    i(this, "PartialBlock", "only for types");
    i(this, "inlineContentSpecs");
    i(this, "styleSpecs");
    i(this, "blockSpecs");
    i(this, "blockSchema");
    i(this, "inlineContentSchema");
    i(this, "styleSchema");
    this.opts = e;
    const {
      blockSpecs: n,
      inlineContentSpecs: r,
      styleSpecs: s,
      blockSchema: o,
      inlineContentSchema: c,
      styleSchema: a
    } = this.init();
    this.blockSpecs = n, this.styleSpecs = s, this.styleSchema = a, this.inlineContentSpecs = r, this.blockSchema = o, this.inlineContentSchema = c;
  }
  init() {
    const e = P(
      Object.entries({
        ...this.opts.blockSpecs,
        ...this.opts.inlineContentSpecs,
        ...this.opts.styleSpecs
      }).map(([o, c]) => {
        var a;
        return {
          key: o,
          runsBefore: ((a = c.implementation) == null ? void 0 : a.runsBefore) ?? []
        };
      })
    ), n = Object.fromEntries(
      Object.entries(this.opts.blockSpecs).map(([o, c]) => [
        o,
        g(
          c.config,
          c.implementation,
          c.extensions,
          e(o)
        )
      ])
    ), r = Object.fromEntries(
      Object.entries(this.opts.inlineContentSpecs).map(
        ([o, c]) => {
          var a;
          return typeof c.config != "object" ? [o, c] : [
            o,
            {
              ...c,
              implementation: {
                ...c.implementation,
                node: (a = c.implementation) == null ? void 0 : a.node.extend({
                  priority: e(o)
                })
              }
            }
          ];
        }
      )
    ), s = Object.fromEntries(
      Object.entries(this.opts.styleSpecs).map(([o, c]) => {
        var a;
        return [
          o,
          {
            ...c,
            implementation: {
              ...c.implementation,
              mark: (a = c.implementation) == null ? void 0 : a.mark.extend({
                priority: e(o)
              })
            }
          }
        ];
      })
    );
    return {
      blockSpecs: n,
      blockSchema: Object.fromEntries(
        Object.entries(n).map(([o, c]) => [o, c.config])
      ),
      inlineContentSpecs: S(r),
      styleSpecs: S(s),
      inlineContentSchema: b(
        r
      ),
      styleSchema: y(s)
    };
  }
  /**
   * Adds additional block specs to the current schema in a builder pattern.
   * This method allows extending the schema after it has been created.
   *
   * @param additionalBlockSpecs - Additional block specs to add to the schema
   * @returns The current schema instance for chaining
   */
  extend(e) {
    Object.assign(this.opts.blockSpecs, e.blockSpecs), Object.assign(this.opts.inlineContentSpecs, e.inlineContentSpecs), Object.assign(this.opts.styleSpecs, e.styleSpecs);
    const {
      blockSpecs: n,
      inlineContentSpecs: r,
      styleSpecs: s,
      blockSchema: o,
      inlineContentSchema: c,
      styleSchema: a
    } = this.init();
    return this.blockSpecs = n, this.styleSpecs = s, this.styleSchema = a, this.inlineContentSpecs = r, this.blockSchema = o, this.inlineContentSchema = c, this;
  }
}
const R = B(
  () => ({
    type: "pageBreak",
    propSchema: {},
    content: "none"
  })
), M = C(
  R,
  {
    parse(t) {
      if (t.tagName === "DIV" && t.hasAttribute("data-page-break"))
        return {};
    },
    render() {
      const t = document.createElement("div");
      return t.setAttribute("data-page-break", ""), {
        dom: t
      };
    },
    toExternalHTML() {
      const t = document.createElement("div");
      return t.setAttribute("data-page-break", ""), {
        dom: t
      };
    }
  }
), z = (t) => t.extend({
  blockSpecs: {
    pageBreak: M()
  }
}), L = async (t) => {
  const e = new FormData();
  return e.append("file", t), (await (await fetch("https://tmpfiles.org/api/v1/upload", {
    method: "POST",
    body: e
  })).json()).data.url.replace(
    "tmpfiles.org/",
    "tmpfiles.org/dl/"
  );
};
function F(t) {
  return "pageBreak" in t.schema.blockSchema;
}
function U(t) {
  const e = [];
  return F(t) && e.push({
    ...t.dictionary.slash_menu.page_break,
    onItemClick: () => {
      w(t, {
        type: "pageBreak"
      });
    },
    key: "page_break"
  }), e;
}
class h extends N {
  static create(e) {
    return new h({
      blockSpecs: (e == null ? void 0 : e.blockSpecs) ?? x,
      inlineContentSpecs: (e == null ? void 0 : e.inlineContentSpecs) ?? j,
      styleSpecs: (e == null ? void 0 : e.styleSpecs) ?? O
    });
  }
}
export {
  h as B,
  N as C,
  M as a,
  F as b,
  R as c,
  U as g,
  P as s,
  L as u,
  z as w
};
//# sourceMappingURL=BlockNoteSchema-BOW16JHv.js.map
