{"version":3,"file":"blocknote.js","sources":["../src/schema/inlineContent/createSpec.ts","../src/api/blockManipulation/commands/insertBlocks/insertBlocks.ts","../src/api/blockManipulation/commands/replaceBlocks/util/fixColumnList.ts","../src/api/blockManipulation/commands/replaceBlocks/replaceBlocks.ts","../src/api/exporters/html/util/serializeBlocksInternalHTML.ts","../src/api/exporters/html/internalHTMLSerializer.ts","../src/api/blockManipulation/commands/moveBlocks/moveBlocks.ts","../src/api/blockManipulation/commands/nestBlock/nestBlock.ts","../src/api/blockManipulation/getBlock/getBlock.ts","../src/editor/managers/BlockManager.ts","../src/editor/managers/EventManager.ts","../src/api/parsers/html/util/nestedLists.ts","../src/api/parsers/html/parseHTML.ts","../src/api/parsers/markdown/parseMarkdown.ts","../src/editor/managers/ExportManager.ts","../src/api/clipboard/fromClipboard/acceptedMIMETypes.ts","../src/api/clipboard/fromClipboard/handleFileInsertion.ts","../src/api/clipboard/fromClipboard/fileDropExtension.ts","../src/api/parsers/markdown/detectMarkdown.ts","../src/api/clipboard/fromClipboard/handleVSCodePaste.ts","../src/api/clipboard/fromClipboard/pasteExtension.ts","../src/api/clipboard/toClipboard/copyExtension.ts","../src/extensions/tiptap-extensions/BackgroundColor/BackgroundColorExtension.ts","../src/extensions/tiptap-extensions/HardBreak/HardBreak.ts","../src/api/blockManipulation/commands/mergeBlocks/mergeBlocks.ts","../src/extensions/tiptap-extensions/KeyboardShortcuts/KeyboardShortcutsExtension.ts","../src/extensions/tiptap-extensions/Suggestions/SuggestionMarks.ts","../src/extensions/tiptap-extensions/TextAlignment/TextAlignmentExtension.ts","../src/extensions/tiptap-extensions/TextColor/TextColorExtension.ts","../src/pm-nodes/BlockContainer.ts","../src/pm-nodes/BlockGroup.ts","../src/pm-nodes/Doc.ts","../src/extensions/Collaboration/Collaboration.ts","../src/editor/managers/ExtensionManager/extensions.ts","../src/editor/managers/ExtensionManager/index.ts","../src/util/expandToWords.ts","../src/api/blockManipulation/selections/selection.ts","../src/api/blockManipulation/selections/textCursorPosition.ts","../src/editor/managers/SelectionManager.ts","../src/editor/managers/StateManager.ts","../src/api/blockManipulation/insertContentAt.ts","../src/editor/managers/StyleManager.ts","../src/editor/transformPasted.ts","../src/editor/BlockNoteEditor.ts","../src/exporter/Exporter.ts","../src/exporter/mapping.ts","../src/util/combineByGroup.ts"],"sourcesContent":["import { Node } from \"@tiptap/core\";\n\nimport { TagParseRule } from \"@tiptap/pm/model\";\nimport { inlineContentToNodes } from \"../../api/nodeConversions/blockToNode.js\";\nimport { nodeToCustomInlineContent } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { propsToAttributes } from \"../blocks/internal.js\";\nimport { Props } from \"../propTypes.js\";\nimport { StyleSchema } from \"../styles/types.js\";\nimport {\n  addInlineContentAttributes,\n  addInlineContentKeyboardShortcuts,\n  createInlineContentSpecFromTipTapNode,\n} from \"./internal.js\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentFromConfig,\n  InlineContentSpec,\n  PartialCustomInlineContentFromConfig,\n} from \"./types.js\";\n\nexport type CustomInlineContentImplementation<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  meta?: {\n    draggable?: boolean;\n  };\n\n  /**\n   * Parses an external HTML element into a inline content of this type when it returns the block props object, otherwise undefined\n   */\n  parse?: (el: HTMLElement) => Partial<Props<T[\"propSchema\"]>> | undefined;\n\n  /**\n   * Renders an inline content to DOM elements\n   */\n  render: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>,\n    /**\n     * A callback that allows overriding the inline content element\n     */\n    updateInlineContent: (\n      update: PartialCustomInlineContentFromConfig<T, S>,\n    ) => void,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<any, any, S>,\n    // (note) if we want to fix the manual cast, we need to prevent circular references and separate block definition and render implementations\n    // or allow manually passing <BSchema>, but that's not possible without passing the other generics because Typescript doesn't support partial inferred generics\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  };\n\n  /**\n   * Renders an inline content to external HTML elements for use outside the editor\n   * If not provided, falls back to the render method\n   */\n  toExternalHTML?: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<any, any, S>,\n  ) =>\n    | {\n        dom: HTMLElement | DocumentFragment;\n        contentDOM?: HTMLElement;\n      }\n    | undefined;\n\n  runsBefore?: string[];\n};\n\nexport function getInlineContentParseRules<C extends CustomInlineContentConfig>(\n  config: C,\n  customParseFunction?: CustomInlineContentImplementation<C, any>[\"parse\"],\n) {\n  const rules: TagParseRule[] = [\n    {\n      tag: `[data-inline-content-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n\n  if (customParseFunction) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const props = customParseFunction?.(node);\n\n        if (props === undefined) {\n          return false;\n        }\n\n        return props;\n      },\n    });\n  }\n  return rules;\n}\n\nexport function createInlineContentSpec<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema,\n>(\n  inlineContentConfig: T,\n  inlineContentImplementation: CustomInlineContentImplementation<T, S>,\n): InlineContentSpec<T> {\n  const node = Node.create({\n    name: inlineContentConfig.type,\n    inline: true,\n    group: \"inline\",\n    draggable: inlineContentImplementation.meta?.draggable,\n    selectable: inlineContentConfig.content === \"styled\",\n    atom: inlineContentConfig.content === \"none\",\n    content: inlineContentConfig.content === \"styled\" ? \"inline*\" : \"\",\n\n    addAttributes() {\n      return propsToAttributes(inlineContentConfig.propSchema);\n    },\n\n    addKeyboardShortcuts() {\n      return addInlineContentKeyboardShortcuts(inlineContentConfig);\n    },\n\n    parseHTML() {\n      return getInlineContentParseRules(\n        inlineContentConfig,\n        inlineContentImplementation.parse,\n      );\n    },\n\n    renderHTML({ node }) {\n      const editor = this.options.editor;\n\n      const output = inlineContentImplementation.render.call(\n        { renderType: \"dom\", props: undefined },\n        nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        ) as any as InlineContentFromConfig<T, S>, // TODO: fix cast\n        () => {\n          // No-op\n        },\n        editor,\n      );\n\n      return addInlineContentAttributes(\n        output,\n        inlineContentConfig.type,\n        node.attrs as Props<T[\"propSchema\"]>,\n        inlineContentConfig.propSchema,\n      );\n    },\n\n    addNodeView() {\n      return (props) => {\n        const { node, getPos } = props;\n        const editor = this.options.editor as BlockNoteEditor<any, any, S>;\n\n        const output = inlineContentImplementation.render.call(\n          { renderType: \"nodeView\", props },\n          nodeToCustomInlineContent(\n            node,\n            editor.schema.inlineContentSchema,\n            editor.schema.styleSchema,\n          ) as any as InlineContentFromConfig<T, S>, // TODO: fix cast\n          (update) => {\n            const content = inlineContentToNodes([update], editor.pmSchema);\n\n            const pos = getPos();\n\n            if (!pos) {\n              return;\n            }\n\n            editor.transact((tr) =>\n              tr.replaceWith(pos, pos + node.nodeSize, content),\n            );\n          },\n          editor,\n        );\n\n        return addInlineContentAttributes(\n          output,\n          inlineContentConfig.type,\n          node.attrs as Props<T[\"propSchema\"]>,\n          inlineContentConfig.propSchema,\n        );\n      };\n    },\n  });\n\n  return createInlineContentSpecFromTipTapNode(\n    node,\n    inlineContentConfig.propSchema,\n    {\n      ...inlineContentImplementation,\n      toExternalHTML: inlineContentImplementation.toExternalHTML,\n      render(inlineContent, updateInlineContent, editor) {\n        const output = inlineContentImplementation.render(\n          inlineContent,\n          updateInlineContent,\n          editor,\n        );\n\n        return addInlineContentAttributes(\n          output,\n          inlineContentConfig.type,\n          inlineContent.props,\n          inlineContentConfig.propSchema,\n        );\n      },\n    },\n  ) as InlineContentSpec<T>;\n}\n","import { Fragment, Slice } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport { ReplaceStep } from \"prosemirror-transform\";\nimport { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { blockToNode } from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\nexport function insertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transaction,\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\" = \"before\",\n): Block<BSchema, I, S>[] {\n  const id =\n    typeof referenceBlock === \"string\" ? referenceBlock : referenceBlock.id;\n  const pmSchema = getPmSchema(tr);\n  const nodesToInsert = blocksToInsert.map((block) =>\n    blockToNode(block, pmSchema),\n  );\n\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  let pos = posInfo.posBeforeNode;\n  if (placement === \"after\") {\n    pos += posInfo.node.nodeSize;\n  }\n\n  tr.step(\n    new ReplaceStep(pos, pos, new Slice(Fragment.from(nodesToInsert), 0, 0)),\n  );\n\n  // Now that the `PartialBlock`s have been converted to nodes, we can\n  // re-convert them into full `Block`s.\n  const insertedBlocks = nodesToInsert.map((node) =>\n    nodeToBlock(node, pmSchema),\n  ) as Block<BSchema, I, S>[];\n\n  return insertedBlocks;\n}\n","import { Slice, type Node } from \"prosemirror-model\";\nimport { type Transaction } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\n\n/**\n * Checks if a `column` node is empty, i.e. if it has only a single empty\n * paragraph.\n * @param column The column to check.\n * @returns Whether the column is empty.\n */\nexport function isEmptyColumn(column: Node) {\n  if (!column || column.type.name !== \"column\") {\n    throw new Error(\"Invalid columnPos: does not point to column node.\");\n  }\n\n  const blockContainer = column.firstChild;\n  if (!blockContainer) {\n    throw new Error(\"Invalid column: does not have child node.\");\n  }\n\n  const blockContent = blockContainer.firstChild;\n  if (!blockContent) {\n    throw new Error(\"Invalid blockContainer: does not have child node.\");\n  }\n\n  return (\n    column.childCount === 1 &&\n    blockContainer.childCount === 1 &&\n    blockContent.type.name === \"paragraph\" &&\n    blockContent.content.content.length === 0\n  );\n}\n\n/**\n * Removes all empty `column` nodes in a `columnList`. A `column` node is empty\n * if it has only a single empty block. If, however, removing the `column`s\n * leaves the `columnList` that has fewer than two, ProseMirror will re-add\n * empty columns.\n * @param tr The `Transaction` to add the changes to.\n * @param columnListPos The position just before the `columnList` node.\n */\nexport function removeEmptyColumns(tr: Transaction, columnListPos: number) {\n  const $columnListPos = tr.doc.resolve(columnListPos);\n  const columnList = $columnListPos.nodeAfter;\n  if (!columnList || columnList.type.name !== \"columnList\") {\n    throw new Error(\n      \"Invalid columnListPos: does not point to columnList node.\",\n    );\n  }\n\n  for (\n    let columnIndex = columnList.childCount - 1;\n    columnIndex >= 0;\n    columnIndex--\n  ) {\n    const columnPos = tr.doc\n      .resolve($columnListPos.pos + 1)\n      .posAtIndex(columnIndex);\n    const $columnPos = tr.doc.resolve(columnPos);\n    const column = $columnPos.nodeAfter;\n    if (!column || column.type.name !== \"column\") {\n      throw new Error(\"Invalid columnPos: does not point to column node.\");\n    }\n\n    if (isEmptyColumn(column)) {\n      tr.delete(columnPos, columnPos + column.nodeSize);\n    }\n  }\n}\n\n/**\n * Fixes potential issues in a `columnList` node after a\n * `blockContainer`/`column` node is (re)moved from it:\n *\n * - Removes all empty `column` nodes. A `column` node is empty if it has only\n * a single empty block.\n * - If all but one `column` nodes are empty, replaces the `columnList` with\n * the content of the non-empty `column`.\n * - If all `column` nodes are empty, removes the `columnList` entirely.\n * @param tr The `Transaction` to add the changes to.\n * @param columnListPos\n * @returns The position just before the `columnList` node.\n */\nexport function fixColumnList(tr: Transaction, columnListPos: number) {\n  removeEmptyColumns(tr, columnListPos);\n\n  const $columnListPos = tr.doc.resolve(columnListPos);\n  const columnList = $columnListPos.nodeAfter;\n  if (!columnList || columnList.type.name !== \"columnList\") {\n    throw new Error(\n      \"Invalid columnListPos: does not point to columnList node.\",\n    );\n  }\n\n  if (columnList.childCount > 2) {\n    // Do nothing if the `columnList` has more than two non-empty `column`s. In\n    // the case that the `columnList` has exactly two columns, we may need to\n    // still remove it, as it's possible that one or both columns are empty.\n    // This is because after `removeEmptyColumns` is called, if the\n    // `columnList` has fewer than two `column`s, ProseMirror will re-add empty\n    // `column`s until there are two total, in order to fit the schema.\n    return;\n  }\n\n  if (columnList.childCount < 2) {\n    // Throw an error if the `columnList` has fewer than two columns. After\n    // `removeEmptyColumns` is called, if the `columnList` has fewer than two\n    // `column`s, ProseMirror will re-add empty `column`s until there are two\n    // total, in order to fit the schema. So if there are fewer than two here,\n    // either the schema, or ProseMirror's internals, must have changed.\n    throw new Error(\"Invalid columnList: contains fewer than two children.\");\n  }\n\n  const firstColumnBeforePos = columnListPos + 1;\n  const $firstColumnBeforePos = tr.doc.resolve(firstColumnBeforePos);\n  const firstColumn = $firstColumnBeforePos.nodeAfter;\n\n  const lastColumnAfterPos = columnListPos + columnList.nodeSize - 1;\n  const $lastColumnAfterPos = tr.doc.resolve(lastColumnAfterPos);\n  const lastColumn = $lastColumnAfterPos.nodeBefore;\n\n  if (!firstColumn || !lastColumn) {\n    throw new Error(\"Invalid columnList: does not contain children.\");\n  }\n\n  const firstColumnEmpty = isEmptyColumn(firstColumn);\n  const lastColumnEmpty = isEmptyColumn(lastColumn);\n\n  if (firstColumnEmpty && lastColumnEmpty) {\n    // Removes `columnList`\n    tr.delete(columnListPos, columnListPos + columnList.nodeSize);\n\n    return;\n  }\n\n  if (firstColumnEmpty) {\n    tr.step(\n      new ReplaceAroundStep(\n        // Replaces `columnList`.\n        columnListPos,\n        columnListPos + columnList.nodeSize,\n        // Replaces with content of last `column`.\n        lastColumnAfterPos - lastColumn.nodeSize + 1,\n        lastColumnAfterPos - 1,\n        // Doesn't append anything.\n        Slice.empty,\n        0,\n        false,\n      ),\n    );\n\n    return;\n  }\n\n  if (lastColumnEmpty) {\n    tr.step(\n      new ReplaceAroundStep(\n        // Replaces `columnList`.\n        columnListPos,\n        columnListPos + columnList.nodeSize,\n        // Replaces with content of first `column`.\n        firstColumnBeforePos + 1,\n        firstColumnBeforePos + firstColumn.nodeSize - 1,\n        // Doesn't append anything.\n        Slice.empty,\n        0,\n        false,\n      ),\n    );\n\n    return;\n  }\n}\n","import { type Node } from \"prosemirror-model\";\nimport { type Transaction } from \"prosemirror-state\";\nimport type { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { blockToNode } from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\nimport { fixColumnList } from \"./util/fixColumnList.js\";\n\nexport function removeAndInsertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transaction,\n  blocksToRemove: BlockIdentifier[],\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n): {\n  insertedBlocks: Block<BSchema, I, S>[];\n  removedBlocks: Block<BSchema, I, S>[];\n} {\n  const pmSchema = getPmSchema(tr);\n  // Converts the `PartialBlock`s to ProseMirror nodes to insert them into the\n  // document.\n  const nodesToInsert: Node[] = blocksToInsert.map((block) =>\n    blockToNode(block, pmSchema),\n  );\n\n  const idsOfBlocksToRemove = new Set<string>(\n    blocksToRemove.map((block) =>\n      typeof block === \"string\" ? block : block.id,\n    ),\n  );\n  const removedBlocks: Block<BSchema, I, S>[] = [];\n  const columnListPositions = new Set<number>();\n\n  const idOfFirstBlock =\n    typeof blocksToRemove[0] === \"string\"\n      ? blocksToRemove[0]\n      : blocksToRemove[0].id;\n  let removedSize = 0;\n\n  tr.doc.descendants((node, pos) => {\n    // Skips traversing nodes after all target blocks have been removed.\n    if (idsOfBlocksToRemove.size === 0) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (\n      !node.type.isInGroup(\"bnBlock\") ||\n      !idsOfBlocksToRemove.has(node.attrs.id)\n    ) {\n      return true;\n    }\n\n    // Saves the block that is being deleted.\n    removedBlocks.push(nodeToBlock(node, pmSchema));\n    idsOfBlocksToRemove.delete(node.attrs.id);\n\n    if (blocksToInsert.length > 0 && node.attrs.id === idOfFirstBlock) {\n      const oldDocSize = tr.doc.nodeSize;\n      tr.insert(pos, nodesToInsert);\n      const newDocSize = tr.doc.nodeSize;\n\n      removedSize += oldDocSize - newDocSize;\n    }\n\n    const oldDocSize = tr.doc.nodeSize;\n\n    const $pos = tr.doc.resolve(pos - removedSize);\n\n    if ($pos.node().type.name === \"column\") {\n      columnListPositions.add($pos.before(-1));\n    } else if ($pos.node().type.name === \"columnList\") {\n      columnListPositions.add($pos.before());\n    }\n\n    if (\n      $pos.node().type.name === \"blockGroup\" &&\n      $pos.node($pos.depth - 1).type.name !== \"doc\" &&\n      $pos.node().childCount === 1\n    ) {\n      // Checks if the block is the only child of a parent `blockGroup` node.\n      // In this case, we need to delete the parent `blockGroup` node instead\n      // of just the `blockContainer`.\n      tr.delete($pos.before(), $pos.after());\n    } else {\n      tr.delete(pos - removedSize, pos - removedSize + node.nodeSize);\n    }\n\n    const newDocSize = tr.doc.nodeSize;\n    removedSize += oldDocSize - newDocSize;\n\n    return false;\n  });\n\n  // Throws an error if not all blocks could be found.\n  if (idsOfBlocksToRemove.size > 0) {\n    const notFoundIds = [...idsOfBlocksToRemove].join(\"\\n\");\n\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" +\n        notFoundIds,\n    );\n  }\n\n  columnListPositions.forEach((pos) => fixColumnList(tr, pos));\n\n  // Converts the nodes created from `blocksToInsert` into full `Block`s.\n  const insertedBlocks = nodesToInsert.map((node) =>\n    nodeToBlock(node, pmSchema),\n  ) as Block<BSchema, I, S>[];\n\n  return { insertedBlocks, removedBlocks };\n}\n","import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\n\nimport { nodeToCustomInlineContent } from \"../../../nodeConversions/nodeToBlock.js\";\nexport function serializeInlineContentInternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n  blockContent: PartialBlock<BSchema, I, S>[\"content\"],\n  serializer: DOMSerializer,\n  blockType?: string,\n  options?: { document?: Document },\n) {\n  let nodes: Node[];\n\n  // TODO: reuse function from nodeconversions?\n  if (!blockContent) {\n    throw new Error(\"blockContent is required\");\n  } else if (typeof blockContent === \"string\") {\n    nodes = inlineContentToNodes([blockContent], editor.pmSchema, blockType);\n  } else if (Array.isArray(blockContent)) {\n    nodes = inlineContentToNodes(blockContent, editor.pmSchema, blockType);\n  } else if (blockContent.type === \"tableContent\") {\n    nodes = tableContentToNodes(blockContent, editor.pmSchema);\n  } else {\n    throw new UnreachableCaseError(blockContent.type);\n  }\n\n  // Check if any of the nodes are custom inline content with toExternalHTML\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const node of nodes) {\n    // Check if this is a custom inline content node with toExternalHTML\n    if (\n      node.type.name !== \"text\" &&\n      editor.schema.inlineContentSchema[node.type.name]\n    ) {\n      const inlineContentImplementation =\n        editor.schema.inlineContentSpecs[node.type.name].implementation;\n\n      if (inlineContentImplementation) {\n        // Convert the node to inline content format\n        const inlineContent = nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        );\n\n        // Use the custom toExternalHTML method\n        const output = inlineContentImplementation.render.call(\n          {\n            renderType: \"dom\",\n            props: undefined,\n          },\n          inlineContent as any,\n          () => {\n            // No-op\n          },\n          editor as any,\n        );\n\n        if (output) {\n          fragment.appendChild(output.dom);\n\n          // If contentDOM exists, render the inline content into it\n          if (output.contentDOM) {\n            const contentFragment = serializer.serializeFragment(\n              node.content,\n              options,\n            );\n            output.contentDOM.dataset.editable = \"\";\n            output.contentDOM.appendChild(contentFragment);\n          }\n          continue;\n        }\n      }\n    } else if (node.type.name === \"text\") {\n      // We serialize text nodes manually as we need to serialize the styles/\n      // marks using `styleSpec.implementation.render`. When left up to\n      // ProseMirror, it'll use `toDOM` which is incorrect.\n      let dom: globalThis.Node | Text = document.createTextNode(\n        node.textContent,\n      );\n      // Reverse the order of marks to maintain the correct priority.\n      for (const mark of node.marks.toReversed()) {\n        if (mark.type.name in editor.schema.styleSpecs) {\n          const newDom = editor.schema.styleSpecs[\n            mark.type.name\n          ].implementation.render(mark.attrs[\"stringValue\"], editor);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        } else {\n          const domOutputSpec = mark.type.spec.toDOM!(mark, true);\n          const newDom = DOMSerializer.renderSpec(document, domOutputSpec);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        }\n      }\n\n      fragment.appendChild(dom);\n    } else {\n      // Fall back to default serialization for this node\n      const nodeFragment = serializer.serializeFragment(\n        Fragment.from([node]),\n        options,\n      );\n      fragment.appendChild(nodeFragment);\n    }\n  }\n\n  return fragment;\n}\n\nfunction serializeBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  const BC_NODE = editor.pmSchema.nodes[\"blockContainer\"];\n\n  // set default props in case we were passed a partial block\n  const props = block.props || {};\n  for (const [name, spec] of Object.entries(\n    editor.schema.blockSchema[block.type as any].propSchema,\n  )) {\n    if (!(name in props) && spec.default !== undefined) {\n      (props as any)[name] = spec.default;\n    }\n  }\n  const children = block.children || [];\n\n  const impl = editor.blockImplementations[block.type as any].implementation;\n  const ret = impl.render.call(\n    {\n      renderType: \"dom\",\n      props: undefined,\n    },\n    { ...block, props, children } as any,\n    editor as any,\n  );\n\n  if (ret.contentDOM && block.content) {\n    const ic = serializeInlineContentInternalHTML(\n      editor,\n      block.content as any, // TODO\n      serializer,\n      block.type,\n      options,\n    );\n    ret.contentDOM.appendChild(ic);\n  }\n\n  const pmType = editor.pmSchema.nodes[block.type as any];\n\n  if (pmType.isInGroup(\"bnBlock\")) {\n    if (block.children && block.children.length > 0) {\n      const fragment = serializeBlocks(\n        editor,\n        block.children,\n        serializer,\n        options,\n      );\n\n      ret.contentDOM?.append(fragment);\n    }\n    return ret.dom;\n  }\n\n  // wrap the block in a blockContainer\n  const bc = BC_NODE.spec?.toDOM?.(\n    BC_NODE.create({\n      id: block.id,\n      ...props,\n    }),\n  ) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  bc.contentDOM?.appendChild(ret.dom);\n\n  if (block.children && block.children.length > 0) {\n    bc.contentDOM?.appendChild(\n      serializeBlocksInternalHTML(editor, block.children, serializer, options),\n    );\n  }\n  return bc.dom;\n}\n\nfunction serializeBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const block of blocks) {\n    const blockDOM = serializeBlock(editor, block, serializer, options);\n    fragment.appendChild(blockDOM);\n  }\n\n  return fragment;\n}\n\nexport const serializeBlocksInternalHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) => {\n  const BG_NODE = editor.pmSchema.nodes[\"blockGroup\"];\n\n  const bg = BG_NODE.spec!.toDOM!(BG_NODE.create({})) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  const fragment = serializeBlocks(editor, blocks, serializer, options);\n\n  bg.contentDOM?.appendChild(fragment);\n\n  return bg.dom;\n};\n","import { DOMSerializer, Schema } from \"prosemirror-model\";\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { serializeBlocksInternalHTML } from \"./util/serializeBlocksInternalHTML.js\";\n// Used to serialize BlockNote blocks and ProseMirror nodes to HTML without\n// losing data. Blocks are exported using the `toInternalHTML` method in their\n// `blockSpec`.\n//\n// The HTML created by this serializer is the same as what's rendered by the\n// editor to the DOM. This means that it retains the same structure as the\n// editor, including the `blockGroup` and `blockContainer` wrappers. This also\n// means that it can be converted back to the original blocks without any data\n// loss.\nexport const createInternalHTMLSerializer = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) => {\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  return {\n    serializeBlocks: (\n      blocks: PartialBlock<BSchema, I, S>[],\n      options: { document?: Document },\n    ) => {\n      return serializeBlocksInternalHTML(editor, blocks, serializer, options)\n        .outerHTML;\n    },\n  };\n};\n","import {\n  NodeSelection,\n  Selection,\n  TextSelection,\n  Transaction,\n} from \"prosemirror-state\";\nimport { CellSelection } from \"prosemirror-tables\";\n\nimport { Block } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor\";\nimport { BlockIdentifier } from \"../../../../schema/index.js\";\nimport { getNearestBlockPos } from \"../../../getBlockInfoFromPos.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\n\ntype BlockSelectionData = (\n  | {\n      type: \"text\";\n      headBlockId: string;\n      anchorOffset: number;\n      headOffset: number;\n    }\n  | {\n      type: \"node\";\n    }\n  | {\n      type: \"cell\";\n      anchorCellOffset: number;\n      headCellOffset: number;\n    }\n) & {\n  anchorBlockId: string;\n};\n\n/**\n * `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save\n * and restore the selection within a block, when the block is moved. This is\n * done by first saving the offsets of the anchor and head from the before\n * positions of their surrounding blocks, as well as the IDs of those blocks. We\n * can then recreate the selection by finding the blocks with those IDs, getting\n * their before positions, and adding the offsets to those positions.\n * @param editor The BlockNote editor instance to get the selection data from.\n */\nfunction getBlockSelectionData(\n  editor: BlockNoteEditor<any, any, any>,\n): BlockSelectionData {\n  return editor.transact((tr) => {\n    const anchorBlockPosInfo = getNearestBlockPos(tr.doc, tr.selection.anchor);\n\n    if (tr.selection instanceof CellSelection) {\n      return {\n        type: \"cell\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n        anchorCellOffset:\n          tr.selection.$anchorCell.pos - anchorBlockPosInfo.posBeforeNode,\n        headCellOffset:\n          tr.selection.$headCell.pos - anchorBlockPosInfo.posBeforeNode,\n      };\n    } else if (tr.selection instanceof NodeSelection) {\n      return {\n        type: \"node\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n      };\n    } else {\n      const headBlockPosInfo = getNearestBlockPos(tr.doc, tr.selection.head);\n\n      return {\n        type: \"text\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n        headBlockId: headBlockPosInfo.node.attrs.id,\n        anchorOffset: tr.selection.anchor - anchorBlockPosInfo.posBeforeNode,\n        headOffset: tr.selection.head - headBlockPosInfo.posBeforeNode,\n      };\n    }\n  });\n}\n\n/**\n * `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save\n * and restore the selection within a block, when the block is moved. This is\n * done by first saving the offsets of the anchor and head from the before\n * positions of their surrounding blocks, as well as the IDs of those blocks. We\n * can then recreate the selection by finding the blocks with those IDs, getting\n * their before positions, and adding the offsets to those positions.\n * @param tr The transaction to update the selection in.\n * @param data The selection data to update the selection with (generated by\n * `getBlockSelectionData`).\n */\nfunction updateBlockSelectionFromData(\n  tr: Transaction,\n  data: BlockSelectionData,\n) {\n  const anchorBlockPos = getNodeById(data.anchorBlockId, tr.doc)?.posBeforeNode;\n  if (anchorBlockPos === undefined) {\n    throw new Error(\n      `Could not find block with ID ${data.anchorBlockId} to update selection`,\n    );\n  }\n\n  let selection: Selection;\n  if (data.type === \"cell\") {\n    selection = CellSelection.create(\n      tr.doc,\n      anchorBlockPos + data.anchorCellOffset,\n      anchorBlockPos + data.headCellOffset,\n    );\n  } else if (data.type === \"node\") {\n    selection = NodeSelection.create(tr.doc, anchorBlockPos + 1);\n  } else {\n    const headBlockPos = getNodeById(data.headBlockId, tr.doc)?.posBeforeNode;\n    if (headBlockPos === undefined) {\n      throw new Error(\n        `Could not find block with ID ${data.headBlockId} to update selection`,\n      );\n    }\n\n    selection = TextSelection.create(\n      tr.doc,\n      anchorBlockPos + data.anchorOffset,\n      headBlockPos + data.headOffset,\n    );\n  }\n\n  tr.setSelection(selection);\n}\n\n/**\n * Replaces any `columnList` blocks with the children of their columns. This is\n * done here instead of in `getSelection` as we still need to remove the entire\n * `columnList` node but only insert the `blockContainer` nodes inside it.\n * @param blocks The blocks to flatten.\n */\nfunction flattenColumns(\n  blocks: Block<any, any, any>[],\n): Block<any, any, any>[] {\n  return blocks\n    .map((block) => {\n      if (block.type === \"columnList\") {\n        return block.children\n          .map((column) => flattenColumns(column.children))\n          .flat();\n      }\n\n      return {\n        ...block,\n        children: flattenColumns(block.children),\n      };\n    })\n    .flat();\n}\n\n/**\n * Removes the selected blocks from the editor, then inserts them before/after a\n * reference block. Also updates the selection to match the original selection\n * using `getBlockSelectionData` and `updateBlockSelectionFromData`.\n * @param editor The BlockNote editor instance to move the blocks in.\n * @param referenceBlock The reference block to insert the selected blocks\n * before/after.\n * @param placement Whether to insert the selected blocks before or after the\n * reference block.\n */\nexport function moveSelectedBlocksAndSelection(\n  editor: BlockNoteEditor<any, any, any>,\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\",\n) {\n  // We want this to be a single step in the undo history\n  editor.transact((tr) => {\n    const blocks = editor.getSelection()?.blocks || [\n      editor.getTextCursorPosition().block,\n    ];\n    const selectionData = getBlockSelectionData(editor);\n\n    editor.removeBlocks(blocks);\n    editor.insertBlocks(flattenColumns(blocks), referenceBlock, placement);\n\n    updateBlockSelectionFromData(tr, selectionData);\n  });\n}\n\n// Checks if a block is in a valid place after being moved. This check is\n// primitive at the moment and only returns false if the block's parent is a\n// `columnList` block. This is because regular blocks cannot be direct children\n// of `columnList` blocks.\nfunction checkPlacementIsValid(parentBlock?: Block<any, any, any>): boolean {\n  return !parentBlock || parentBlock.type !== \"columnList\";\n}\n\n// Gets the placement for moving a block up. This has 3 cases:\n// 1. If the block has a previous sibling without children, the placement is\n// before it.\n// 2. If the block has a previous sibling with children, the placement is after\n// the last child.\n// 3. If the block has no previous sibling, but is nested, the placement is\n// before its parent.\n// If the placement is invalid, the function is called recursively until a valid\n// placement is found. Returns undefined if no valid placement is found, meaning\n// the block is already at the top of the document.\nfunction getMoveUpPlacement(\n  editor: BlockNoteEditor<any, any, any>,\n  prevBlock?: Block<any, any, any>,\n  parentBlock?: Block<any, any, any>,\n):\n  | { referenceBlock: BlockIdentifier; placement: \"before\" | \"after\" }\n  | undefined {\n  let referenceBlock: Block<any, any, any> | undefined;\n  let placement: \"before\" | \"after\" | undefined;\n\n  if (!prevBlock) {\n    if (parentBlock) {\n      referenceBlock = parentBlock;\n      placement = \"before\";\n    }\n  } else if (prevBlock.children.length > 0) {\n    referenceBlock = prevBlock.children[prevBlock.children.length - 1];\n    placement = \"after\";\n  } else {\n    referenceBlock = prevBlock;\n    placement = \"before\";\n  }\n\n  // Case when the block is already at the top of the document.\n  if (!referenceBlock || !placement) {\n    return undefined;\n  }\n\n  const referenceBlockParent = editor.getParentBlock(referenceBlock);\n  if (!checkPlacementIsValid(referenceBlockParent)) {\n    return getMoveUpPlacement(\n      editor,\n      placement === \"after\"\n        ? referenceBlock\n        : editor.getPrevBlock(referenceBlock),\n      referenceBlockParent,\n    );\n  }\n\n  return { referenceBlock, placement };\n}\n\n// Gets the placement for moving a block down. This has 3 cases:\n// 1. If the block has a next sibling without children, the placement is  after\n// it.\n// 2. If the block has a next sibling with children, the placement is before the\n// first child.\n// 3. If the block has no next sibling, but is nested, the placement is\n// after its parent.\n// If the placement is invalid, the function is called recursively until a valid\n// placement is found. Returns undefined if no valid placement is found, meaning\n// the block is already at the bottom of the document.\nfunction getMoveDownPlacement(\n  editor: BlockNoteEditor<any, any, any>,\n  nextBlock?: Block<any, any, any>,\n  parentBlock?: Block<any, any, any>,\n):\n  | { referenceBlock: BlockIdentifier; placement: \"before\" | \"after\" }\n  | undefined {\n  let referenceBlock: Block<any, any, any> | undefined;\n  let placement: \"before\" | \"after\" | undefined;\n\n  if (!nextBlock) {\n    if (parentBlock) {\n      referenceBlock = parentBlock;\n      placement = \"after\";\n    }\n  } else if (nextBlock.children.length > 0) {\n    referenceBlock = nextBlock.children[0];\n    placement = \"before\";\n  } else {\n    referenceBlock = nextBlock;\n    placement = \"after\";\n  }\n\n  // Case when the block is already at the bottom of the document.\n  if (!referenceBlock || !placement) {\n    return undefined;\n  }\n\n  const referenceBlockParent = editor.getParentBlock(referenceBlock);\n  if (!checkPlacementIsValid(referenceBlockParent)) {\n    return getMoveDownPlacement(\n      editor,\n      placement === \"before\"\n        ? referenceBlock\n        : editor.getNextBlock(referenceBlock),\n      referenceBlockParent,\n    );\n  }\n\n  return { referenceBlock, placement };\n}\n\nexport function moveBlocksUp(editor: BlockNoteEditor<any, any, any>) {\n  editor.transact(() => {\n    const selection = editor.getSelection();\n    const block = selection?.blocks[0] || editor.getTextCursorPosition().block;\n\n    const moveUpPlacement = getMoveUpPlacement(\n      editor,\n      editor.getPrevBlock(block),\n      editor.getParentBlock(block),\n    );\n\n    if (!moveUpPlacement) {\n      return;\n    }\n\n    moveSelectedBlocksAndSelection(\n      editor,\n      moveUpPlacement.referenceBlock,\n      moveUpPlacement.placement,\n    );\n  });\n}\n\nexport function moveBlocksDown(editor: BlockNoteEditor<any, any, any>) {\n  editor.transact(() => {\n    const selection = editor.getSelection();\n    const block =\n      selection?.blocks[selection?.blocks.length - 1] ||\n      editor.getTextCursorPosition().block;\n\n    const moveDownPlacement = getMoveDownPlacement(\n      editor,\n      editor.getNextBlock(block),\n      editor.getParentBlock(block),\n    );\n\n    if (!moveDownPlacement) {\n      return;\n    }\n\n    moveSelectedBlocksAndSelection(\n      editor,\n      moveDownPlacement.referenceBlock,\n      moveDownPlacement.placement,\n    );\n  });\n}\n","import { Fragment, NodeType, Slice } from \"prosemirror-model\";\nimport { Transaction } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\n\nimport { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport { getBlockInfoFromTransaction } from \"../../../getBlockInfoFromPos.js\";\n\n// TODO: Unit tests\n/**\n * This is a modified version of https://github.com/ProseMirror/prosemirror-schema-list/blob/569c2770cbb8092d8f11ea53ecf78cb7a4e8f15a/src/schema-list.ts#L232\n *\n * The original function derives too many information from the parentnode and itemtype\n */\nfunction sinkListItem(\n  tr: Transaction,\n  itemType: NodeType,\n  groupType: NodeType,\n) {\n  const { $from, $to } = tr.selection;\n  const range = $from.blockRange(\n    $to,\n    (node) =>\n      node.childCount > 0 &&\n      (node.type.name === \"blockGroup\" || node.type.name === \"column\"), // change necessary to not look at first item child type\n  );\n  if (!range) {\n    return false;\n  }\n  const startIndex = range.startIndex;\n  if (startIndex === 0) {\n    return false;\n  }\n  const parent = range.parent;\n  const nodeBefore = parent.child(startIndex - 1);\n  if (nodeBefore.type !== itemType) {\n    return false;\n  }\n  const nestedBefore =\n    nodeBefore.lastChild && nodeBefore.lastChild.type === groupType; // change necessary to check groupType instead of parent.type\n  const inner = Fragment.from(nestedBefore ? itemType.create() : null);\n  const slice = new Slice(\n    Fragment.from(\n      itemType.create(null, Fragment.from(groupType.create(null, inner))), // change necessary to create \"groupType\" instead of parent.type\n    ),\n    nestedBefore ? 3 : 1,\n    0,\n  );\n\n  const before = range.start;\n  const after = range.end;\n\n  tr.step(\n    new ReplaceAroundStep(\n      before - (nestedBefore ? 3 : 1),\n      after,\n      before,\n      after,\n      slice,\n      1,\n      true,\n    ),\n  ).scrollIntoView();\n\n  return true;\n}\n\nexport function nestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    return sinkListItem(\n      tr,\n      editor.pmSchema.nodes[\"blockContainer\"],\n      editor.pmSchema.nodes[\"blockGroup\"],\n    );\n  });\n}\n\nexport function unnestBlock(editor: BlockNoteEditor<any, any, any>) {\n  editor._tiptapEditor.commands.liftListItem(\"blockContainer\");\n}\n\nexport function canNestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    const { bnBlock: blockContainer } = getBlockInfoFromTransaction(tr);\n\n    return tr.doc.resolve(blockContainer.beforePos).nodeBefore !== null;\n  });\n}\n\nexport function canUnnestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    const { bnBlock: blockContainer } = getBlockInfoFromTransaction(tr);\n\n    return tr.doc.resolve(blockContainer.beforePos).depth > 1;\n  });\n}\n","import type { Node } from \"prosemirror-model\";\nimport type { Block } from \"../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getPmSchema } from \"../../pmUtil.js\";\n\nexport function getBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const pmSchema = getPmSchema(doc);\n\n  const posInfo = getNodeById(id, doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  return nodeToBlock(posInfo.node, pmSchema);\n}\n\nexport function getPrevBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n\n  const posInfo = getNodeById(id, doc);\n  const pmSchema = getPmSchema(doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posBeforeNode = doc.resolve(posInfo.posBeforeNode);\n  const nodeToConvert = $posBeforeNode.nodeBefore;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n\nexport function getNextBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const posInfo = getNodeById(id, doc);\n  const pmSchema = getPmSchema(doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posAfterNode = doc.resolve(\n    posInfo.posBeforeNode + posInfo.node.nodeSize,\n  );\n  const nodeToConvert = $posAfterNode.nodeAfter;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n\nexport function getParentBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const pmSchema = getPmSchema(doc);\n  const posInfo = getNodeById(id, doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posBeforeNode = doc.resolve(posInfo.posBeforeNode);\n  const parentNode = $posBeforeNode.node();\n  const grandparentNode = $posBeforeNode.node(-1);\n  const nodeToConvert =\n    grandparentNode.type.name !== \"doc\"\n      ? parentNode.type.name === \"blockGroup\"\n        ? grandparentNode\n        : parentNode\n      : undefined;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n","import { insertBlocks } from \"../../api/blockManipulation/commands/insertBlocks/insertBlocks.js\";\nimport {\n  moveBlocksDown,\n  moveBlocksUp,\n} from \"../../api/blockManipulation/commands/moveBlocks/moveBlocks.js\";\nimport {\n  canNestBlock,\n  canUnnestBlock,\n  nestBlock,\n  unnestBlock,\n} from \"../../api/blockManipulation/commands/nestBlock/nestBlock.js\";\nimport { removeAndInsertBlocks } from \"../../api/blockManipulation/commands/replaceBlocks/replaceBlocks.js\";\nimport { updateBlock } from \"../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport {\n  getBlock,\n  getNextBlock,\n  getParentBlock,\n  getPrevBlock,\n} from \"../../api/blockManipulation/getBlock/getBlock.js\";\nimport { docToBlocks } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class BlockManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    return this.editor.transact((tr) => {\n      return docToBlocks(tr.doc, this.editor.pmSchema);\n    });\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  public getPrevBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getPrevBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  public getNextBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getNextBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  public getParentBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) =>\n      getParentBlock(tr.doc, blockIdentifier),\n    );\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false,\n  ): void {\n    const blocks = this.document.slice();\n\n    if (reverse) {\n      blocks.reverse();\n    }\n\n    function traverseBlockArray(\n      blockArray: Block<BSchema, ISchema, SSchema>[],\n    ): boolean {\n      for (const block of blockArray) {\n        if (callback(block) === false) {\n          return false;\n        }\n\n        const children = reverse\n          ? block.children.slice().reverse()\n          : block.children;\n\n        if (!traverseBlockArray(children)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    traverseBlockArray(blocks);\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" = \"before\",\n  ) {\n    return this.editor.transact((tr) =>\n      insertBlocks(tr, blocksToInsert, referenceBlock, placement),\n    );\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>,\n  ) {\n    return this.editor.transact((tr) => updateBlock(tr, blockToUpdate, update));\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return this.editor.transact(\n      (tr) => removeAndInsertBlocks(tr, blocksToRemove, []).removedBlocks,\n    );\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n  ) {\n    return this.editor.transact((tr) =>\n      removeAndInsertBlocks(tr, blocksToRemove, blocksToInsert),\n    );\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    return canNestBlock(this.editor);\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    nestBlock(this.editor);\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    return canUnnestBlock(this.editor);\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    unnestBlock(this.editor);\n  }\n\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  public moveBlocksUp() {\n    return moveBlocksUp(this.editor);\n  }\n\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  public moveBlocksDown() {\n    return moveBlocksDown(this.editor);\n  }\n}\n","import type { BlockNoteEditor } from \"../BlockNoteEditor.js\";\nimport {\n  getBlocksChangedByTransaction,\n  type BlocksChanged,\n} from \"../../api/getBlocksChangedByTransaction.js\";\nimport { Transaction } from \"prosemirror-state\";\nimport { EventEmitter } from \"../../util/EventEmitter.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\n\n/**\n * A function that can be used to unsubscribe from an event.\n */\nexport type Unsubscribe = () => void;\n\n/**\n * EventManager is a class which manages the events of the editor\n */\nexport class EventManager<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends EventEmitter<{\n  onChange: [\n    ctx: {\n      editor: BlockNoteEditor<BSchema, I, S>;\n      transaction: Transaction;\n      appendedTransactions: Transaction[];\n    },\n  ];\n  onSelectionChange: [\n    ctx: { editor: BlockNoteEditor<BSchema, I, S>; transaction: Transaction },\n  ];\n  onMount: [ctx: { editor: BlockNoteEditor<BSchema, I, S> }];\n  onUnmount: [ctx: { editor: BlockNoteEditor<BSchema, I, S> }];\n}> {\n  constructor(private editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    // We register tiptap events only once the editor is finished initializing\n    // otherwise we would be trying to register events on a tiptap editor which does not exist yet\n    editor.on(\"create\", () => {\n      editor._tiptapEditor.on(\n        \"update\",\n        ({ transaction, appendedTransactions }) => {\n          this.emit(\"onChange\", { editor, transaction, appendedTransactions });\n        },\n      );\n      editor._tiptapEditor.on(\"selectionUpdate\", ({ transaction }) => {\n        this.emit(\"onSelectionChange\", { editor, transaction });\n      });\n      editor._tiptapEditor.on(\"mount\", () => {\n        this.emit(\"onMount\", { editor });\n      });\n      editor._tiptapEditor.on(\"unmount\", () => {\n        this.emit(\"onUnmount\", { editor });\n      });\n    });\n  }\n\n  /**\n   * Register a callback that will be called when the editor changes.\n   */\n  public onChange(\n    callback: (\n      editor: BlockNoteEditor<BSchema, I, S>,\n      ctx: {\n        getChanges(): BlocksChanged<BSchema, I, S>;\n      },\n    ) => void,\n    /**\n     * If true, the callback will be triggered when the changes are caused by a remote user\n     * @default true\n     */\n    includeUpdatesFromRemote = true,\n  ): Unsubscribe {\n    const cb = ({\n      transaction,\n      appendedTransactions,\n    }: {\n      transaction: Transaction;\n      appendedTransactions: Transaction[];\n    }) => {\n      if (!includeUpdatesFromRemote && isRemoteTransaction(transaction)) {\n        // don't trigger the callback if the changes are caused by a remote user\n        return;\n      }\n      callback(this.editor, {\n        getChanges() {\n          return getBlocksChangedByTransaction<BSchema, I, S>(\n            transaction,\n            appendedTransactions,\n          );\n        },\n      });\n    };\n    this.on(\"onChange\", cb);\n\n    return () => {\n      this.off(\"onChange\", cb);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the selection changes.\n   */\n  public onSelectionChange(\n    callback: (editor: BlockNoteEditor<BSchema, I, S>) => void,\n    /**\n     * If true, the callback will be triggered when the selection changes due to a yjs sync (i.e.: other user was typing)\n     */\n    includeSelectionChangedByRemote = false,\n  ): Unsubscribe {\n    const cb = (e: { transaction: Transaction }) => {\n      if (\n        !includeSelectionChangedByRemote &&\n        isRemoteTransaction(e.transaction)\n      ) {\n        // don't trigger the callback if the selection changed because of a remote user\n        return;\n      }\n      callback(this.editor);\n    };\n\n    this.on(\"onSelectionChange\", cb);\n\n    return () => {\n      this.off(\"onSelectionChange\", cb);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the editor is mounted.\n   */\n  public onMount(\n    callback: (ctx: { editor: BlockNoteEditor<BSchema, I, S> }) => void,\n  ): Unsubscribe {\n    this.on(\"onMount\", callback);\n\n    return () => {\n      this.off(\"onMount\", callback);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the editor is unmounted.\n   */\n  public onUnmount(\n    callback: (ctx: { editor: BlockNoteEditor<BSchema, I, S> }) => void,\n  ): Unsubscribe {\n    this.on(\"onUnmount\", callback);\n\n    return () => {\n      this.off(\"onUnmount\", callback);\n    };\n  }\n}\n\nfunction isRemoteTransaction(transaction: Transaction): boolean {\n  return !!transaction.getMeta(\"y-sync$\");\n}\n","function getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\nfunction isWhitespaceNode(node: Node) {\n  return node.nodeType === 3 && !/\\S/.test(node.nodeValue || \"\");\n}\n\n/**\n * Step 1, Turns:\n *\n * <ul>\n *  <li>item</li>\n *  <li>\n *   <ul>\n *      <li>...</li>\n *      <li>...</li>\n *   </ul>\n * </li>\n *\n * Into:\n * <ul>\n *  <li>item</li>\n *  <ul>\n *      <li>...</li>\n *      <li>...</li>\n *  </ul>\n * </ul>\n *\n */\nfunction liftNestedListsToParent(element: HTMLElement) {\n  element.querySelectorAll(\"li > ul, li > ol\").forEach((list) => {\n    const index = getChildIndex(list);\n    const parentListItem = list.parentElement!;\n    const siblingsAfter = Array.from(parentListItem.childNodes).slice(\n      index + 1,\n    );\n    list.remove();\n    siblingsAfter.forEach((sibling) => {\n      sibling.remove();\n    });\n\n    parentListItem.insertAdjacentElement(\"afterend\", list);\n\n    siblingsAfter.reverse().forEach((sibling) => {\n      if (isWhitespaceNode(sibling)) {\n        return;\n      }\n      const siblingContainer = document.createElement(\"li\");\n      siblingContainer.append(sibling);\n      list.insertAdjacentElement(\"afterend\", siblingContainer);\n    });\n    if (parentListItem.childNodes.length === 0) {\n      parentListItem.remove();\n    }\n  });\n}\n\n/**\n * Step 2, Turns (output of liftNestedListsToParent):\n *\n * <li>item</li>\n * <ul>\n *   <li>...</li>\n *   <li>...</li>\n * </ul>\n *\n * Into:\n * <div>\n *  <li>item</li>\n *  <div data-node-type=\"blockGroup\">\n *      <ul>\n *          <li>...</li>\n *          <li>...</li>\n *      </ul>\n *  </div>\n * </div>\n *\n * This resulting format is parsed\n */\nfunction createGroups(element: HTMLElement) {\n  element.querySelectorAll(\"li + ul, li + ol\").forEach((list) => {\n    const listItem = list.previousElementSibling as HTMLElement;\n    const blockContainer = document.createElement(\"div\");\n\n    listItem.insertAdjacentElement(\"afterend\", blockContainer);\n    blockContainer.append(listItem);\n\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    blockContainer.append(blockGroup);\n\n    while (\n      blockContainer.nextElementSibling?.nodeName === \"UL\" ||\n      blockContainer.nextElementSibling?.nodeName === \"OL\"\n    ) {\n      blockGroup.append(blockContainer.nextElementSibling);\n    }\n  });\n}\n\n// prevent XSS, similar to https://github.com/ProseMirror/prosemirror-view/blob/1251b2b412656a2a06263e4187574beb43651273/src/clipboard.ts#L204\n// https://github.com/TypeCellOS/BlockNote/issues/601\nlet _detachedDoc: Document | null = null;\nfunction detachedDoc() {\n  return (\n    _detachedDoc ||\n    (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n  );\n}\n\nexport function nestedListsToBlockNoteStructure(\n  elementOrHTML: HTMLElement | string,\n) {\n  if (typeof elementOrHTML === \"string\") {\n    const element = detachedDoc().createElement(\"div\");\n    element.innerHTML = elementOrHTML;\n    elementOrHTML = element;\n  }\n  liftNestedListsToParent(elementOrHTML);\n  createGroups(elementOrHTML);\n  return elementOrHTML;\n}\n","import { DOMParser, Schema } from \"prosemirror-model\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { nestedListsToBlockNoteStructure } from \"./util/nestedLists.js\";\n\nexport function HTMLToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(html: string, pmSchema: Schema): Block<BSchema, I, S>[] {\n  const htmlNode = nestedListsToBlockNoteStructure(html);\n  const parser = DOMParser.fromSchema(pmSchema);\n\n  // Other approach might be to use\n  // const doc = pmSchema.nodes[\"doc\"].createAndFill()!;\n  // and context: doc.resolve(3),\n\n  const parentNode = parser.parse(htmlNode, {\n    topNode: pmSchema.nodes[\"blockGroup\"].create(),\n  });\n\n  const blocks: Block<BSchema, I, S>[] = [];\n\n  for (let i = 0; i < parentNode.childCount; i++) {\n    blocks.push(nodeToBlock(parentNode.child(i), pmSchema));\n  }\n\n  return blocks;\n}\n","import { Schema } from \"prosemirror-model\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype, {\n  defaultHandlers as remarkRehypeDefaultHandlers,\n} from \"remark-rehype\";\nimport rehypeStringify from \"rehype-stringify\";\nimport { unified } from \"unified\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { HTMLToBlocks } from \"../html/parseHTML.js\";\nimport { isVideoUrl } from \"../../../util/string.js\";\n\n// modified version of https://github.com/syntax-tree/mdast-util-to-hast/blob/main/lib/handlers/code.js\n// that outputs a data-language attribute instead of a CSS class (e.g.: language-typescript)\nfunction code(state: any, node: any) {\n  const value = node.value ? node.value : \"\";\n  /** @type {Properties} */\n  const properties: any = {};\n\n  if (node.lang) {\n    // changed line\n    properties[\"data-language\"] = node.lang;\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result: any = {\n    type: \"element\",\n    tagName: \"code\",\n    properties,\n    children: [{ type: \"text\", value }],\n  };\n\n  if (node.meta) {\n    result.data = { meta: node.meta };\n  }\n\n  state.patch(node, result);\n  result = state.applyData(node, result);\n\n  // Create `<pre>`.\n  result = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [result],\n  };\n  state.patch(node, result);\n  return result;\n}\n\nfunction video(state: any, node: any) {\n  const url = String(node?.url || \"\");\n  const title = node?.title ? String(node.title) : undefined;\n\n  let result: any = {\n    type: \"element\",\n    tagName: \"video\",\n    properties: {\n      src: url,\n      \"data-name\": title,\n      \"data-url\": url,\n      controls: true,\n    },\n    children: [],\n  };\n  state.patch?.(node, result);\n  result = state.applyData ? state.applyData(node, result) : result;\n\n  return result;\n}\n\nexport function markdownToHTML(markdown: string): string {\n  const htmlString = unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype, {\n      handlers: {\n        ...(remarkRehypeDefaultHandlers as any),\n        image: (state: any, node: any) => {\n          const url = String(node?.url || \"\");\n\n          if (isVideoUrl(url)) {\n            return video(state, node);\n          } else {\n            return remarkRehypeDefaultHandlers.image(state, node);\n          }\n        },\n        code,\n        blockquote: (state: any, node: any) => {\n          const result = {\n            type: \"element\",\n            tagName: \"blockquote\",\n            properties: {},\n            // The only difference from the original is that we don't wrap the children with line endings\n            children: state.wrap(state.all(node), false),\n          };\n          state.patch(node, result);\n          return state.applyData(node, result);\n        },\n      },\n    })\n    .use(rehypeStringify)\n    .processSync(markdown);\n\n  return htmlString.value as string;\n}\n\nexport function markdownToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(markdown: string, pmSchema: Schema): Block<BSchema, I, S>[] {\n  const htmlString = markdownToHTML(markdown);\n\n  return HTMLToBlocks(htmlString, pmSchema);\n}\n","import { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter.js\";\nimport { createInternalHTMLSerializer } from \"../../api/exporters/html/internalHTMLSerializer.js\";\nimport { blocksToMarkdown } from \"../../api/exporters/markdown/markdownExporter.js\";\nimport { HTMLToBlocks } from \"../../api/parsers/html/parseHTML.js\";\nimport {\n  markdownToBlocks,\n  markdownToHTML,\n} from \"../../api/parsers/markdown/parseMarkdown.js\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class ExportManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToHTMLLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    const exporter = createExternalHTMLExporter(\n      this.editor.pmSchema,\n      this.editor,\n    );\n    return exporter.exportBlocks(blocks, {});\n  }\n\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToFullHTML(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    const exporter = createInternalHTMLSerializer(\n      this.editor.pmSchema,\n      this.editor,\n    );\n    return exporter.serializeBlocks(blocks, {});\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public tryParseHTMLToBlocks(\n    html: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return HTMLToBlocks(html, this.editor.pmSchema);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public blocksToMarkdownLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    return blocksToMarkdown(blocks, this.editor.pmSchema, this.editor, {});\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public tryParseMarkdownToBlocks(\n    markdown: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return markdownToBlocks(markdown, this.editor.pmSchema);\n  }\n\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  public pasteHTML(html: string, raw = false) {\n    let htmlToPaste = html;\n    if (!raw) {\n      const blocks = this.tryParseHTMLToBlocks(html);\n      htmlToPaste = this.blocksToFullHTML(blocks);\n    }\n    if (!htmlToPaste) {\n      return;\n    }\n    this.editor.prosemirrorView?.pasteHTML(htmlToPaste);\n  }\n\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  public pasteText(text: string) {\n    return this.editor.prosemirrorView?.pasteText(text);\n  }\n\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  public pasteMarkdown(markdown: string) {\n    const html = markdownToHTML(markdown);\n    return this.pasteHTML(html);\n  }\n}\n","export const acceptedMIMETypes = [\n  \"vscode-editor-data\",\n  \"blocknote/html\",\n  \"text/markdown\",\n  \"text/html\",\n  \"text/plain\",\n  \"Files\",\n] as const;\n","import { Block, PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { getNearestBlockPos } from \"../../getBlockInfoFromPos.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\n\nfunction checkFileExtensionsMatch(\n  fileExtension1: string,\n  fileExtension2: string,\n) {\n  if (!fileExtension1.startsWith(\".\") || !fileExtension2.startsWith(\".\")) {\n    throw new Error(`The strings provided are not valid file extensions.`);\n  }\n\n  return fileExtension1 === fileExtension2;\n}\n\nfunction checkMIMETypesMatch(mimeType1: string, mimeType2: string) {\n  const types1 = mimeType1.split(\"/\");\n  const types2 = mimeType2.split(\"/\");\n\n  if (types1.length !== 2) {\n    throw new Error(`The string ${mimeType1} is not a valid MIME type.`);\n  }\n  if (types2.length !== 2) {\n    throw new Error(`The string ${mimeType2} is not a valid MIME type.`);\n  }\n\n  if (types1[1] === \"*\" || types2[1] === \"*\") {\n    return types1[0] === types2[0];\n  }\n  if (types1[0] === \"*\" || types2[0] === \"*\") {\n    return types1[1] === types2[1];\n  }\n\n  return types1[0] === types2[0] && types1[1] === types2[1];\n}\n\nfunction insertOrUpdateBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  referenceBlock: Block<BSchema, I, S>,\n  newBlock: PartialBlock<BSchema, I, S>,\n  placement: \"before\" | \"after\" = \"after\",\n) {\n  let insertedBlockId: string | undefined;\n\n  if (\n    Array.isArray(referenceBlock.content) &&\n    referenceBlock.content.length === 0\n  ) {\n    insertedBlockId = editor.updateBlock(referenceBlock, newBlock).id;\n  } else {\n    insertedBlockId = editor.insertBlocks(\n      [newBlock],\n      referenceBlock,\n      placement,\n    )[0].id;\n  }\n\n  return insertedBlockId;\n}\n\nexport async function handleFileInsertion<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(event: DragEvent | ClipboardEvent, editor: BlockNoteEditor<BSchema, I, S>) {\n  if (!editor.uploadFile) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"Attempted ot insert file, but uploadFile is not set in the BlockNote editor options\",\n    );\n    return;\n  }\n\n  const dataTransfer =\n    \"dataTransfer\" in event ? event.dataTransfer : event.clipboardData;\n  if (dataTransfer === null) {\n    return;\n  }\n\n  let format: (typeof acceptedMIMETypes)[number] | null = null;\n  for (const mimeType of acceptedMIMETypes) {\n    if (dataTransfer.types.includes(mimeType)) {\n      format = mimeType;\n      break;\n    }\n  }\n  if (format !== \"Files\") {\n    return;\n  }\n\n  const items = dataTransfer.items;\n  if (!items) {\n    return;\n  }\n\n  event.preventDefault();\n\n  for (let i = 0; i < items.length; i++) {\n    // Gets file block corresponding to MIME type.\n    let fileBlockType = \"file\";\n    for (const blockSpec of Object.values(editor.schema.blockSpecs)) {\n      for (const mimeType of blockSpec.implementation.meta?.fileBlockAccept ||\n        []) {\n        const isFileExtension = mimeType.startsWith(\".\");\n        const file = items[i].getAsFile();\n\n        if (file) {\n          if (\n            (!isFileExtension &&\n              file.type &&\n              checkMIMETypesMatch(items[i].type, mimeType)) ||\n            (isFileExtension &&\n              checkFileExtensionsMatch(\n                \".\" + file.name.split(\".\").pop(),\n                mimeType,\n              ))\n          ) {\n            fileBlockType = blockSpec.config.type;\n            break;\n          }\n        }\n      }\n    }\n\n    const file = items[i].getAsFile();\n    if (file) {\n      const fileBlock = {\n        type: fileBlockType,\n        props: {\n          name: file.name,\n        },\n      } as PartialBlock<BSchema, I, S>;\n\n      let insertedBlockId: string | undefined = undefined;\n\n      if (event.type === \"paste\") {\n        const currentBlock = editor.getTextCursorPosition().block;\n        insertedBlockId = insertOrUpdateBlock(editor, currentBlock, fileBlock);\n      } else if (event.type === \"drop\") {\n        const coords = {\n          left: (event as DragEvent).clientX,\n          top: (event as DragEvent).clientY,\n        };\n\n        const pos = editor.prosemirrorView.posAtCoords(coords);\n\n        if (!pos) {\n          return;\n        }\n\n        insertedBlockId = editor.transact((tr) => {\n          const posInfo = getNearestBlockPos(tr.doc, pos.pos);\n          const blockElement = editor.domElement?.querySelector(\n            `[data-id=\"${posInfo.node.attrs.id}\"]`,\n          );\n\n          const blockRect = blockElement?.getBoundingClientRect();\n\n          return insertOrUpdateBlock(\n            editor,\n            editor.getBlock(posInfo.node.attrs.id)!,\n            fileBlock,\n            blockRect && (blockRect.top + blockRect.bottom) / 2 > coords.top\n              ? \"before\"\n              : \"after\",\n          );\n        });\n      } else {\n        return;\n      }\n\n      const updateData = await editor.uploadFile(file, insertedBlockId);\n\n      const updatedFileBlock =\n        typeof updateData === \"string\"\n          ? ({\n              props: {\n                url: updateData,\n              },\n            } as PartialBlock<BSchema, I, S>)\n          : { ...updateData };\n\n      editor.updateBlock(insertedBlockId, updatedFileBlock);\n    }\n  }\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\nimport { handleFileInsertion } from \"./handleFileInsertion.js\";\n\nexport const createDropFileExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"dropFile\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              drop(_view, event) {\n                if (!editor.isEditable) {\n                  return;\n                }\n\n                let format: (typeof acceptedMIMETypes)[number] | null = null;\n                for (const mimeType of acceptedMIMETypes) {\n                  if (event.dataTransfer!.types.includes(mimeType)) {\n                    format = mimeType;\n                    break;\n                  }\n                }\n                if (format === null) {\n                  return true;\n                }\n\n                if (format === \"Files\") {\n                  handleFileInsertion(event, editor);\n                  return true;\n                }\n\n                return false;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","// Headings H1-H6.\nconst h1 = /(^|\\n) {0,3}#{1,6} {1,8}[^\\n]{1,64}\\r?\\n\\r?\\n\\s{0,32}\\S/;\n\n// Bold, italic, underline, strikethrough, highlight.\nconst bold =\n  /(_|__|\\*|\\*\\*|~~|==|\\+\\+)(?!\\s)(?:[^\\s](?:.{0,62}[^\\s])?|\\S)(?=\\1)/;\n\n// Basic inline link (also captures images).\nconst link = /\\[[^\\]]{1,128}\\]\\(https?:\\/\\/\\S{1,999}\\)/;\n\n// Inline code.\nconst code = /(?:\\s|^)`(?!\\s)(?:[^\\s`](?:[^`]{0,46}[^\\s`])?|[^\\s`])`([^\\w]|$)/;\n\n// Unordered list.\nconst ul = /(?:^|\\n)\\s{0,5}-\\s{1}[^\\n]+\\n\\s{0,15}-\\s/;\n\n// Ordered list.\nconst ol = /(?:^|\\n)\\s{0,5}\\d+\\.\\s{1}[^\\n]+\\n\\s{0,15}\\d+\\.\\s/;\n\n// Horizontal rule.\nconst hr = /\\n{2} {0,3}-{2,48}\\n{2}/;\n\n// Fenced code block.\nconst fences =\n  /(?:\\n|^)(```|~~~|\\$\\$)(?!`|~)[^\\s]{0,64} {0,64}[^\\n]{0,64}\\n[\\s\\S]{0,9999}?\\s*\\1 {0,64}(?:\\n+|$)/;\n\n// Classical underlined H1 and H2 headings.\nconst title = /(?:\\n|^)(?!\\s)\\w[^\\n]{0,64}\\r?\\n(-|=)\\1{0,64}\\n\\n\\s{0,64}(\\w|$)/;\n\n// Blockquote.\nconst blockquote =\n  /(?:^|(\\r?\\n\\r?\\n))( {0,3}>[^\\n]{1,333}\\n){1,999}($|(\\r?\\n))/;\n\n// Table Header\nconst tableHeader = /^\\s*\\|(.+\\|)+\\s*$/m;\n\n// Table Divider\nconst tableDivider = /^\\s*\\|(\\s*[-:]+[-:]\\s*\\|)+\\s*$/m;\n\n// Table Row\nconst tableRow = /^\\s*\\|(.+\\|)+\\s*$/m;\n\n/**\n * Returns `true` if the source text might be a markdown document.\n *\n * @param src Source text to analyze.\n */\nexport const isMarkdown = (src: string): boolean =>\n  h1.test(src) ||\n  bold.test(src) ||\n  link.test(src) ||\n  code.test(src) ||\n  ul.test(src) ||\n  ol.test(src) ||\n  hr.test(src) ||\n  fences.test(src) ||\n  title.test(src) ||\n  blockquote.test(src) ||\n  tableHeader.test(src) ||\n  tableDivider.test(src) ||\n  tableRow.test(src);\n","import { EditorView } from \"prosemirror-view\";\n\nexport async function handleVSCodePaste(\n  event: ClipboardEvent,\n  view: EditorView,\n) {\n  const { schema } = view.state;\n\n  if (!event.clipboardData) {\n    return false;\n  }\n\n  const text = event.clipboardData!.getData(\"text/plain\");\n\n  if (!text) {\n    return false;\n  }\n\n  if (!schema.nodes.codeBlock) {\n    view.pasteText(text);\n    return true;\n  }\n\n  const vscode = event.clipboardData!.getData(\"vscode-editor-data\");\n  const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n  const language = vscodeData?.mode;\n\n  if (!language) {\n    return false;\n  }\n\n  // strip carriage return chars from text pasted as code\n  // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n  view.pasteHTML(\n    `<pre><code class=\"language-${language}\">${text.replace(\n      /\\r\\n?/g,\n      \"\\n\",\n    )}</code></pre>`,\n  );\n\n  return true;\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../../editor/BlockNoteEditor\";\nimport { isMarkdown } from \"../../parsers/markdown/detectMarkdown.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\nimport { handleFileInsertion } from \"./handleFileInsertion.js\";\nimport { handleVSCodePaste } from \"./handleVSCodePaste.js\";\n\nfunction defaultPasteHandler({\n  event,\n  editor,\n  prioritizeMarkdownOverHTML,\n  plainTextAsMarkdown,\n}: {\n  event: ClipboardEvent;\n  editor: BlockNoteEditor<any, any, any>;\n  prioritizeMarkdownOverHTML: boolean;\n  plainTextAsMarkdown: boolean;\n}) {\n  // Special case for code blocks, as they do not support any rich text\n  // formatting, so we force pasting plain text.\n  const isInCodeBlock = editor.transact(\n    (tr) =>\n      tr.selection.$from.parent.type.spec.code &&\n      tr.selection.$to.parent.type.spec.code,\n  );\n\n  if (isInCodeBlock) {\n    const data = event.clipboardData?.getData(\"text/plain\");\n\n    if (data) {\n      editor.pasteText(data);\n\n      return true;\n    }\n  }\n\n  let format: (typeof acceptedMIMETypes)[number] | undefined;\n  for (const mimeType of acceptedMIMETypes) {\n    if (event.clipboardData!.types.includes(mimeType)) {\n      format = mimeType;\n      break;\n    }\n  }\n\n  if (!format) {\n    return true;\n  }\n\n  if (format === \"vscode-editor-data\") {\n    handleVSCodePaste(event, editor.prosemirrorView);\n    return true;\n  }\n\n  if (format === \"Files\") {\n    handleFileInsertion(event, editor);\n    return true;\n  }\n\n  const data = event.clipboardData!.getData(format);\n\n  if (format === \"blocknote/html\") {\n    // Is blocknote/html, so no need to convert it\n    editor.pasteHTML(data, true);\n    return true;\n  }\n\n  if (format === \"text/markdown\") {\n    editor.pasteMarkdown(data);\n    return true;\n  }\n\n  if (prioritizeMarkdownOverHTML) {\n    // Use plain text instead of HTML if it looks like Markdown\n    const plainText = event.clipboardData!.getData(\"text/plain\");\n\n    if (isMarkdown(plainText)) {\n      editor.pasteMarkdown(plainText);\n      return true;\n    }\n  }\n\n  if (format === \"text/html\") {\n    editor.pasteHTML(data);\n    return true;\n  }\n\n  if (plainTextAsMarkdown) {\n    editor.pasteMarkdown(data);\n    return true;\n  }\n\n  editor.pasteText(data);\n  return true;\n}\n\nexport const createPasteFromClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  pasteHandler: Exclude<\n    BlockNoteEditorOptions<any, any, any>[\"pasteHandler\"],\n    undefined\n  >,\n) =>\n  Extension.create({\n    name: \"pasteFromClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              paste(_view, event) {\n                event.preventDefault();\n\n                if (!editor.isEditable) {\n                  return;\n                }\n\n                return pasteHandler({\n                  event,\n                  editor,\n                  defaultPasteHandler: ({\n                    prioritizeMarkdownOverHTML = true,\n                    plainTextAsMarkdown = true,\n                  } = {}) => {\n                    return defaultPasteHandler({\n                      event,\n                      editor,\n                      prioritizeMarkdownOverHTML,\n                      plainTextAsMarkdown,\n                    });\n                  },\n                });\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { Fragment, Node } from \"prosemirror-model\";\nimport { NodeSelection, Plugin } from \"prosemirror-state\";\nimport { CellSelection } from \"prosemirror-tables\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { createExternalHTMLExporter } from \"../../exporters/html/externalHTMLExporter.js\";\nimport { cleanHTMLToMarkdown } from \"../../exporters/markdown/markdownExporter.js\";\nimport { fragmentToBlocks } from \"../../nodeConversions/fragmentToBlocks.js\";\nimport {\n  contentNodeToInlineContent,\n  contentNodeToTableContent,\n} from \"../../nodeConversions/nodeToBlock.js\";\n\nfunction fragmentToExternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  view: EditorView,\n  selectedFragment: Fragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) {\n  let isWithinBlockContent = false;\n  const isWithinTable = view.state.selection instanceof CellSelection;\n\n  if (!isWithinTable) {\n    // Checks whether block ancestry should be included when creating external\n    // HTML. If the selection is within a block content node, the block ancestry\n    // is excluded as we only care about the inline content.\n    const fragmentWithoutParents = view.state.doc.slice(\n      view.state.selection.from,\n      view.state.selection.to,\n      false,\n    ).content;\n\n    const children = [];\n    for (let i = 0; i < fragmentWithoutParents.childCount; i++) {\n      children.push(fragmentWithoutParents.child(i));\n    }\n\n    isWithinBlockContent =\n      children.find(\n        (child) =>\n          child.type.isInGroup(\"bnBlock\") ||\n          child.type.name === \"blockGroup\" ||\n          child.type.spec.group === \"blockContent\",\n      ) === undefined;\n    if (isWithinBlockContent) {\n      selectedFragment = fragmentWithoutParents;\n    }\n  }\n\n  let externalHTML: string;\n\n  const externalHTMLExporter = createExternalHTMLExporter(\n    view.state.schema,\n    editor,\n  );\n\n  if (isWithinTable) {\n    if (selectedFragment.firstChild?.type.name === \"table\") {\n      // contentNodeToTableContent expects the fragment of the content of a table, not the table node itself\n      // but cellselection.content() returns the table node itself if all cells and columns are selected\n      selectedFragment = selectedFragment.firstChild.content;\n    }\n\n    // first convert selection to blocknote-style table content, and then\n    // pass this to the exporter\n    const ic = contentNodeToTableContent(\n      selectedFragment as any,\n      editor.schema.inlineContentSchema,\n      editor.schema.styleSchema,\n    );\n\n    // Wrap in table to ensure correct parsing by spreadsheet applications\n    externalHTML = `<table>${externalHTMLExporter.exportInlineContent(\n      ic as any,\n      {},\n    )}</table>`;\n  } else if (isWithinBlockContent) {\n    // first convert selection to blocknote-style inline content, and then\n    // pass this to the exporter\n    const ic = contentNodeToInlineContent(\n      selectedFragment as any,\n      editor.schema.inlineContentSchema,\n      editor.schema.styleSchema,\n    );\n    externalHTML = externalHTMLExporter.exportInlineContent(ic, {});\n  } else {\n    const blocks = fragmentToBlocks<BSchema, I, S>(selectedFragment);\n    externalHTML = externalHTMLExporter.exportBlocks(blocks, {});\n  }\n  return externalHTML;\n}\n\nexport function selectedFragmentToHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  view: EditorView,\n  editor: BlockNoteEditor<BSchema, I, S>,\n): {\n  clipboardHTML: string;\n  externalHTML: string;\n  markdown: string;\n} {\n  // Checks if a `blockContent` node is being copied and expands\n  // the selection to the parent `blockContainer` node. This is\n  // for the use-case in which only a block without content is\n  // selected, e.g. an image block.\n  if (\n    \"node\" in view.state.selection &&\n    (view.state.selection.node as Node).type.spec.group === \"blockContent\"\n  ) {\n    editor.transact((tr) =>\n      tr.setSelection(\n        new NodeSelection(tr.doc.resolve(view.state.selection.from - 1)),\n      ),\n    );\n  }\n\n  // Uses default ProseMirror clipboard serialization.\n  const clipboardHTML: string = view.serializeForClipboard(\n    view.state.selection.content(),\n  ).dom.innerHTML;\n\n  const selectedFragment = view.state.selection.content().content;\n\n  const externalHTML = fragmentToExternalHTML<BSchema, I, S>(\n    view,\n    selectedFragment,\n    editor,\n  );\n\n  const markdown = cleanHTMLToMarkdown(externalHTML);\n\n  return { clipboardHTML, externalHTML, markdown };\n}\n\nconst checkIfSelectionInNonEditableBlock = () => {\n  // Let browser handle event if selection is empty (nothing\n  // happens).\n  const selection = window.getSelection();\n  if (!selection || selection.isCollapsed) {\n    return true;\n  }\n\n  // Let browser handle event if it's within a non-editable\n  // \"island\". This means it's in selectable content within a\n  // non-editable block. We only need to check one node as it's\n  // not possible for the browser selection to start in an\n  // editable block and end in a non-editable one.\n  let node = selection.focusNode;\n  while (node) {\n    if (\n      node instanceof HTMLElement &&\n      node.getAttribute(\"contenteditable\") === \"false\"\n    ) {\n      return true;\n    }\n\n    node = node.parentElement;\n  }\n\n  return false;\n};\n\nconst copyToClipboard = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  view: EditorView,\n  event: ClipboardEvent,\n) => {\n  // Stops the default browser copy behaviour.\n  event.preventDefault();\n  event.clipboardData!.clearData();\n\n  const { clipboardHTML, externalHTML, markdown } = selectedFragmentToHTML(\n    view,\n    editor,\n  );\n\n  // TODO: Writing to other MIME types not working in Safari for\n  //  some reason.\n  event.clipboardData!.setData(\"blocknote/html\", clipboardHTML);\n  event.clipboardData!.setData(\"text/html\", externalHTML);\n  event.clipboardData!.setData(\"text/plain\", markdown);\n};\n\nexport const createCopyToClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"copyToClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              copy(view, event) {\n                if (checkIfSelectionInNonEditableBlock()) {\n                  return true;\n                }\n\n                copyToClipboard(editor, view, event);\n                // Prevent default PM handler to be called\n                return true;\n              },\n              cut(view, event) {\n                if (checkIfSelectionInNonEditableBlock()) {\n                  return true;\n                }\n\n                copyToClipboard(editor, view, event);\n                if (view.editable) {\n                  view.dispatch(view.state.tr.deleteSelection());\n                }\n                // Prevent default PM handler to be called\n                return true;\n              },\n              // This is for the use-case in which only a block without content\n              // is selected, e.g. an image block, and dragged (not using the\n              // drag handle).\n              dragstart(view, event) {\n                // Checks if a `NodeSelection` is active.\n                if (!(\"node\" in view.state.selection)) {\n                  return;\n                }\n\n                // Checks if a `blockContent` node is being dragged.\n                if (\n                  (view.state.selection.node as Node).type.spec.group !==\n                  \"blockContent\"\n                ) {\n                  return;\n                }\n\n                // Expands the selection to the parent `blockContainer` node.\n                editor.transact((tr) =>\n                  tr.setSelection(\n                    new NodeSelection(\n                      tr.doc.resolve(view.state.selection.from - 1),\n                    ),\n                  ),\n                );\n\n                // Stops the default browser drag start behaviour.\n                event.preventDefault();\n                event.dataTransfer!.clearData();\n\n                const { clipboardHTML, externalHTML, markdown } =\n                  selectedFragmentToHTML(view, editor);\n\n                // TODO: Writing to other MIME types not working in Safari for\n                //  some reason.\n                event.dataTransfer!.setData(\"blocknote/html\", clipboardHTML);\n                event.dataTransfer!.setData(\"text/html\", externalHTML);\n                event.dataTransfer!.setData(\"text/plain\", markdown);\n\n                // Prevent default PM handler to be called\n                return true;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { getBackgroundColorAttribute } from \"../../../blocks/defaultProps.js\";\n\nexport const BackgroundColorExtension = Extension.create({\n  name: \"blockBackgroundColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"tableCell\", \"tableHeader\"],\n        attributes: {\n          backgroundColor: getBackgroundColorAttribute(),\n        },\n      },\n    ];\n  },\n});\n","// Stripped down version of the TipTap HardBreak extension:\n// https://github.com/ueberdosis/tiptap/blob/f3258d9ee5fb7979102fe63434f6ea4120507311/packages/extension-hard-break/src/hard-break.ts#L80\n// Changes:\n// - Removed options\n// - Removed keyboard shortcuts & moved them to the `KeyboardShortcutsExtension`\n// - Removed `setHardBreak` command (added a simpler version in the Shift+Enter\n// handler in `KeyboardShortcutsExtension`).\n// - Added priority\nimport { mergeAttributes, Node } from \"@tiptap/core\";\n\nexport const HardBreak = Node.create({\n  name: \"hardBreak\",\n\n  inline: true,\n\n  group: \"inline\",\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  priority: 10,\n\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  renderText() {\n    return \"\\n\";\n  },\n});\n","import { Node } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport {\n  BlockInfo,\n  getBlockInfoFromResolvedPos,\n} from \"../../../getBlockInfoFromPos.js\";\n\n/**\n * Returns the block info from the parent block\n * or undefined if we're at the root\n */\nexport const getParentBlockInfo = (doc: Node, beforePos: number) => {\n  const $pos = doc.resolve(beforePos);\n\n  if ($pos.depth <= 1) {\n    return undefined;\n  }\n\n  // get start pos of parent\n  const parentBeforePos = $pos.posAtIndex(\n    $pos.index($pos.depth - 1),\n    $pos.depth - 1,\n  );\n\n  const parentBlockInfo = getBlockInfoFromResolvedPos(\n    doc.resolve(parentBeforePos),\n  );\n  return parentBlockInfo;\n};\n\n/**\n * Returns the block info from the sibling block before (above) the given block,\n * or undefined if the given block is the first sibling.\n */\nexport const getPrevBlockInfo = (doc: Node, beforePos: number) => {\n  const $pos = doc.resolve(beforePos);\n\n  const indexInParent = $pos.index();\n\n  if (indexInParent === 0) {\n    return undefined;\n  }\n\n  const prevBlockBeforePos = $pos.posAtIndex(indexInParent - 1);\n\n  const prevBlockInfo = getBlockInfoFromResolvedPos(\n    doc.resolve(prevBlockBeforePos),\n  );\n  return prevBlockInfo;\n};\n\n/**\n * If a block has children like this:\n * A\n * - B\n * - C\n * -- D\n *\n * Then the bottom nested block returned is D.\n */\nexport const getBottomNestedBlockInfo = (doc: Node, blockInfo: BlockInfo) => {\n  while (blockInfo.childContainer) {\n    const group = blockInfo.childContainer.node;\n\n    const newPos = doc\n      .resolve(blockInfo.childContainer.beforePos + 1)\n      .posAtIndex(group.childCount - 1);\n    blockInfo = getBlockInfoFromResolvedPos(doc.resolve(newPos));\n  }\n\n  return blockInfo;\n};\n\nconst canMerge = (prevBlockInfo: BlockInfo, nextBlockInfo: BlockInfo) => {\n  return (\n    prevBlockInfo.isBlockContainer &&\n    prevBlockInfo.blockContent.node.type.spec.content === \"inline*\" &&\n    prevBlockInfo.blockContent.node.childCount > 0 &&\n    nextBlockInfo.isBlockContainer &&\n    nextBlockInfo.blockContent.node.type.spec.content === \"inline*\"\n  );\n};\n\nconst mergeBlocks = (\n  state: EditorState,\n  dispatch: ((args?: any) => any) | undefined,\n  prevBlockInfo: BlockInfo,\n  nextBlockInfo: BlockInfo,\n) => {\n  // Un-nests all children of the next block.\n  if (!nextBlockInfo.isBlockContainer) {\n    throw new Error(\n      `Attempted to merge block at position ${nextBlockInfo.bnBlock.beforePos} into previous block at position ${prevBlockInfo.bnBlock.beforePos}, but next block is not a block container`,\n    );\n  }\n\n  // Removes a level of nesting all children of the next block by 1 level, if it contains both content and block\n  // group nodes.\n  if (nextBlockInfo.childContainer) {\n    const childBlocksStart = state.doc.resolve(\n      nextBlockInfo.childContainer.beforePos + 1,\n    );\n    const childBlocksEnd = state.doc.resolve(\n      nextBlockInfo.childContainer.afterPos - 1,\n    );\n    const childBlocksRange = childBlocksStart.blockRange(childBlocksEnd);\n\n    if (dispatch) {\n      const pos = state.doc.resolve(nextBlockInfo.bnBlock.beforePos);\n      state.tr.lift(childBlocksRange!, pos.depth);\n    }\n  }\n\n  // Deletes the boundary between the two blocks. Can be thought of as\n  // removing the closing tags of the first block and the opening tags of the\n  // second one to stitch them together.\n  if (dispatch) {\n    if (!prevBlockInfo.isBlockContainer) {\n      throw new Error(\n        `Attempted to merge block at position ${nextBlockInfo.bnBlock.beforePos} into previous block at position ${prevBlockInfo.bnBlock.beforePos}, but previous block is not a block container`,\n      );\n    }\n\n    // TODO: test merging between a columnList and paragraph, between two columnLists, and v.v.\n    dispatch(\n      state.tr.delete(\n        prevBlockInfo.blockContent.afterPos - 1,\n        nextBlockInfo.blockContent.beforePos + 1,\n      ),\n    );\n  }\n\n  return true;\n};\n\nexport const mergeBlocksCommand =\n  (posBetweenBlocks: number) =>\n  ({\n    state,\n    dispatch,\n  }: {\n    state: EditorState;\n    dispatch: ((args?: any) => any) | undefined;\n  }) => {\n    const $pos = state.doc.resolve(posBetweenBlocks);\n    const nextBlockInfo = getBlockInfoFromResolvedPos($pos);\n\n    const prevBlockInfo = getPrevBlockInfo(\n      state.doc,\n      nextBlockInfo.bnBlock.beforePos,\n    );\n\n    if (!prevBlockInfo) {\n      return false;\n    }\n\n    const bottomNestedBlockInfo = getBottomNestedBlockInfo(\n      state.doc,\n      prevBlockInfo,\n    );\n\n    if (!canMerge(bottomNestedBlockInfo, nextBlockInfo)) {\n      return false;\n    }\n\n    return mergeBlocks(state, dispatch, bottomNestedBlockInfo, nextBlockInfo);\n  };\n","import { Extension } from \"@tiptap/core\";\n\nimport { TextSelection } from \"prosemirror-state\";\nimport {\n  getBottomNestedBlockInfo,\n  getPrevBlockInfo,\n  mergeBlocksCommand,\n} from \"../../../api/blockManipulation/commands/mergeBlocks/mergeBlocks.js\";\nimport { nestBlock } from \"../../../api/blockManipulation/commands/nestBlock/nestBlock.js\";\nimport { fixColumnList } from \"../../../api/blockManipulation/commands/replaceBlocks/util/fixColumnList.js\";\nimport { splitBlockCommand } from \"../../../api/blockManipulation/commands/splitBlock/splitBlock.js\";\nimport { updateBlockCommand } from \"../../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromSelection } from \"../../../api/getBlockInfoFromPos.js\";\nimport { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport { FormattingToolbarExtension } from \"../../FormattingToolbar/FormattingToolbar.js\";\nimport { FilePanelExtension } from \"../../FilePanel/FilePanel.js\";\n\nexport const KeyboardShortcutsExtension = Extension.create<{\n  editor: BlockNoteEditor<any, any, any>;\n  tabBehavior: \"prefer-navigate-ui\" | \"prefer-indent\";\n}>({\n  priority: 50,\n\n  // TODO: The shortcuts need a refactor. Do we want to use a command priority\n  //  design as there is now, or clump the logic into a single function?\n  addKeyboardShortcuts() {\n    // handleBackspace is partially adapted from https://github.com/ueberdosis/tiptap/blob/ed56337470efb4fd277128ab7ef792b37cfae992/packages/core/src/extensions/keymap.ts\n    const handleBackspace = () =>\n      this.editor.commands.first(({ chain, commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => commands.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n            const isParagraph =\n              blockInfo.blockContent.node.type.name === \"paragraph\";\n\n            if (selectionAtBlockStart && !isParagraph) {\n              return commands.command(\n                updateBlockCommand(blockInfo.bnBlock.beforePos, {\n                  type: \"paragraph\",\n                  props: {},\n                }),\n              );\n            }\n\n            return false;\n          }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.from === blockContent.beforePos + 1;\n\n            if (selectionAtBlockStart) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Merges block with the previous one if it isn't indented, and the selection is at the start of the\n        // block. The target block for merging must contain inline content.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.from === blockContent.beforePos + 1;\n            const selectionEmpty = state.selection.empty;\n\n            const posBetweenBlocks = blockContainer.beforePos;\n\n            if (selectionAtBlockStart && selectionEmpty) {\n              return chain()\n                .command(mergeBlocksCommand(posBetweenBlocks))\n                .scrollIntoView()\n                .run();\n            }\n\n            return false;\n          }),\n        () =>\n          commands.command(({ state, tr, dispatch }) => {\n            // when at the start of a first block in a column\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const selectionAtBlockStart =\n              tr.selection.from === blockInfo.blockContent.beforePos + 1;\n            if (!selectionAtBlockStart) {\n              return false;\n            }\n\n            const $pos = tr.doc.resolve(blockInfo.bnBlock.beforePos);\n\n            const prevBlock = $pos.nodeBefore;\n            if (prevBlock) {\n              // should be no previous block\n              return false;\n            }\n\n            const parentBlock = $pos.node();\n            if (parentBlock.type.name !== \"column\") {\n              return false;\n            }\n\n            const $blockPos = tr.doc.resolve(blockInfo.bnBlock.beforePos);\n            const $columnPos = tr.doc.resolve($blockPos.before());\n            const columnListPos = $columnPos.before();\n\n            if (dispatch) {\n              const fragment = tr.doc.slice(\n                blockInfo.bnBlock.beforePos,\n                blockInfo.bnBlock.afterPos,\n              ).content;\n\n              tr.delete(\n                blockInfo.bnBlock.beforePos,\n                blockInfo.bnBlock.afterPos,\n              );\n\n              if ($columnPos.index() === 0) {\n                // Fix `columnList` and insert the block before it.\n                fixColumnList(tr, columnListPos);\n                tr.insert(columnListPos, fragment);\n                tr.setSelection(\n                  TextSelection.near(tr.doc.resolve(columnListPos)),\n                );\n              } else {\n                // Insert the block at the end of the first column and fix\n                // `columnList`.\n                tr.insert($columnPos.pos - 1, fragment);\n                tr.setSelection(\n                  TextSelection.near(tr.doc.resolve($columnPos.pos - 1)),\n                );\n                fixColumnList(tr, columnListPos);\n              }\n            }\n\n            return true;\n          }),\n        // Deletes the current block if it's an empty block with inline content,\n        // and moves the selection to the previous block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const blockEmpty =\n              blockInfo.blockContent.node.childCount === 0 &&\n              blockInfo.blockContent.node.type.spec.content === \"inline*\";\n\n            if (blockEmpty) {\n              const prevBlockInfo = getPrevBlockInfo(\n                state.doc,\n                blockInfo.bnBlock.beforePos,\n              );\n              if (!prevBlockInfo || !prevBlockInfo.isBlockContainer) {\n                return false;\n              }\n\n              let chainedCommands = chain();\n\n              if (\n                prevBlockInfo.blockContent.node.type.spec.content ===\n                \"tableRow+\"\n              ) {\n                const tableBlockEndPos = blockInfo.bnBlock.beforePos - 1;\n                const tableBlockContentEndPos = tableBlockEndPos - 1;\n                const lastRowEndPos = tableBlockContentEndPos - 1;\n                const lastCellEndPos = lastRowEndPos - 1;\n                const lastCellParagraphEndPos = lastCellEndPos - 1;\n\n                chainedCommands = chainedCommands.setTextSelection(\n                  lastCellParagraphEndPos,\n                );\n              } else if (\n                prevBlockInfo.blockContent.node.type.spec.content === \"\"\n              ) {\n                const nonEditableBlockContentStartPos =\n                  prevBlockInfo.blockContent.afterPos -\n                  prevBlockInfo.blockContent.node.nodeSize;\n\n                chainedCommands = chainedCommands.setNodeSelection(\n                  nonEditableBlockContentStartPos,\n                );\n              } else {\n                const blockContentStartPos =\n                  prevBlockInfo.blockContent.afterPos -\n                  prevBlockInfo.blockContent.node.nodeSize;\n\n                chainedCommands =\n                  chainedCommands.setTextSelection(blockContentStartPos);\n              }\n\n              return chainedCommands\n                .deleteRange({\n                  from: blockInfo.bnBlock.beforePos,\n                  to: blockInfo.bnBlock.afterPos,\n                })\n                .scrollIntoView()\n                .run();\n            }\n\n            return false;\n          }),\n        // Deletes previous block if it contains no content and isn't a table,\n        // when the selection is empty and at the start of the block. Moves the\n        // current block into the deleted block's place.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n\n            if (!blockInfo.isBlockContainer) {\n              // TODO\n              throw new Error(`todo`);\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n            const selectionEmpty = state.selection.empty;\n\n            const prevBlockInfo = getPrevBlockInfo(\n              state.doc,\n              blockInfo.bnBlock.beforePos,\n            );\n\n            if (prevBlockInfo && selectionAtBlockStart && selectionEmpty) {\n              const bottomBlock = getBottomNestedBlockInfo(\n                state.doc,\n                prevBlockInfo,\n              );\n\n              if (!bottomBlock.isBlockContainer) {\n                // TODO\n                throw new Error(`todo`);\n              }\n\n              const prevBlockNotTableAndNoContent =\n                bottomBlock.blockContent.node.type.spec.content === \"\" ||\n                (bottomBlock.blockContent.node.type.spec.content ===\n                  \"inline*\" &&\n                  bottomBlock.blockContent.node.childCount === 0);\n\n              if (prevBlockNotTableAndNoContent) {\n                return chain()\n                  .cut(\n                    {\n                      from: blockInfo.bnBlock.beforePos,\n                      to: blockInfo.bnBlock.afterPos,\n                    },\n                    bottomBlock.bnBlock.afterPos,\n                  )\n                  .deleteRange({\n                    from: bottomBlock.bnBlock.beforePos,\n                    to: bottomBlock.bnBlock.afterPos,\n                  })\n                  .run();\n              }\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleDelete = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Merges block with the next one (at the same nesting level or lower),\n        // if one exists, the block has no children, and the selection is at the\n        // end of the block.\n        () =>\n          commands.command(({ state }) => {\n            // TODO: Change this to not rely on offsets & schema assumptions\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const {\n              bnBlock: blockContainer,\n              blockContent,\n              childContainer,\n            } = blockInfo;\n\n            const { depth } = state.doc.resolve(blockContainer.beforePos);\n            const blockAtDocEnd =\n              blockContainer.afterPos === state.doc.nodeSize - 3;\n            const selectionAtBlockEnd =\n              state.selection.from === blockContent.afterPos - 1;\n            const selectionEmpty = state.selection.empty;\n            const hasChildBlocks = childContainer !== undefined;\n\n            if (\n              !blockAtDocEnd &&\n              selectionAtBlockEnd &&\n              selectionEmpty &&\n              !hasChildBlocks\n            ) {\n              let oldDepth = depth;\n              let newPos = blockContainer.afterPos + 1;\n              let newDepth = state.doc.resolve(newPos).depth;\n\n              while (newDepth < oldDepth) {\n                oldDepth = newDepth;\n                newPos += 2;\n                newDepth = state.doc.resolve(newPos).depth;\n              }\n\n              return commands.command(mergeBlocksCommand(newPos - 1));\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleEnter = (withShift = false) => {\n      return this.editor.commands.first(({ commands, tr }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const { depth } = state.doc.resolve(blockContainer.beforePos);\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = blockContent.node.childCount === 0;\n            const blockIndented = depth > 1;\n\n            if (\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              blockEmpty &&\n              blockIndented\n            ) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Creates a hard break if block is configured to do so.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n\n            const blockHardBreakShortcut =\n              this.options.editor.schema.blockSchema[\n                blockInfo.blockNoteType as keyof typeof this.options.editor.schema.blockSchema\n              ].meta?.hardBreakShortcut ?? \"shift+enter\";\n\n            if (blockHardBreakShortcut === \"none\") {\n              return false;\n            }\n\n            if (\n              // If shortcut is not configured, or is configured as \"shift+enter\",\n              // create a hard break for shift+enter, but not for enter.\n              (blockHardBreakShortcut === \"shift+enter\" && withShift) ||\n              // If shortcut is configured as \"enter\", create a hard break for\n              // both enter and shift+enter.\n              blockHardBreakShortcut === \"enter\"\n            ) {\n              const marks =\n                tr.storedMarks ||\n                tr.selection.$head\n                  .marks()\n                  .filter((m) =>\n                    this.editor.extensionManager.splittableMarks.includes(\n                      m.type.name,\n                    ),\n                  );\n\n              tr.insert(\n                tr.selection.head,\n                tr.doc.type.schema.nodes.hardBreak.create(),\n              ).ensureMarks(marks);\n              return true;\n            }\n\n            return false;\n          }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () =>\n          commands.command(({ state, dispatch }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = blockContent.node.childCount === 0;\n\n            if (selectionAtBlockStart && selectionEmpty && blockEmpty) {\n              const newBlockInsertionPos = blockContainer.afterPos;\n              const newBlockContentPos = newBlockInsertionPos + 2;\n\n              if (dispatch) {\n                const newBlock =\n                  state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n                state.tr\n                  .insert(newBlockInsertionPos, newBlock)\n                  .scrollIntoView();\n                state.tr.setSelection(\n                  new TextSelection(state.doc.resolve(newBlockContentPos)),\n                );\n              }\n\n              return true;\n            }\n\n            return false;\n          }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () =>\n          commands.command(({ state, chain }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const blockEmpty = blockContent.node.childCount === 0;\n\n            if (!blockEmpty) {\n              chain()\n                .deleteSelection()\n                .command(\n                  splitBlockCommand(\n                    state.selection.from,\n                    selectionAtBlockStart,\n                    selectionAtBlockStart,\n                  ),\n                )\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n      ]);\n    };\n\n    return {\n      Backspace: handleBackspace,\n      Delete: handleDelete,\n      Enter: () => handleEnter(),\n      \"Shift-Enter\": () => handleEnter(true),\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        if (\n          this.options.tabBehavior !== \"prefer-indent\" &&\n          (this.options.editor.getExtension(FormattingToolbarExtension)?.store\n            .state ||\n            this.options.editor.getExtension(FilePanelExtension)?.store\n              .state !== undefined)\n          // TODO need to check if the link toolbar is open or another alternative entirely\n        ) {\n          // don't handle tabs if a toolbar is shown, so we can tab into / out of it\n          return false;\n        }\n        return nestBlock(this.options.editor);\n      },\n      \"Shift-Tab\": () => {\n        if (\n          this.options.tabBehavior !== \"prefer-indent\" &&\n          (this.options.editor.getExtension(FormattingToolbarExtension)?.store\n            .state ||\n            this.options.editor.getExtension(FilePanelExtension)?.store\n              .state !== undefined)\n          // TODO need to check if the link toolbar is open or another alternative entirely\n          // other menu types?\n        ) {\n          // don't handle tabs if a toolbar is shown, so we can tab into / out of it\n          return false;\n        }\n        return this.editor.commands.liftListItem(\"blockContainer\");\n      },\n      \"Shift-Mod-ArrowUp\": () => {\n        this.options.editor.moveBlocksUp();\n        return true;\n      },\n      \"Shift-Mod-ArrowDown\": () => {\n        this.options.editor.moveBlocksDown();\n        return true;\n      },\n      \"Mod-z\": () => this.options.editor.undo(),\n      \"Mod-y\": () => this.options.editor.redo(),\n      \"Shift-Mod-z\": () => this.options.editor.redo(),\n    };\n  },\n});\n","import { Mark } from \"@tiptap/core\";\nimport { MarkSpec } from \"prosemirror-model\";\n\n// This copies the marks from @handlewithcare/prosemirror-suggest-changes,\n// but uses the Tiptap Mark API instead so we can use them in BlockNote\n\n// The ideal solution would be to not depend on tiptap nodes / marks, but be able to use prosemirror nodes / marks directly\n// this way we could directly use the exported marks from @handlewithcare/prosemirror-suggest-changes\nexport const SuggestionAddMark = Mark.create({\n  name: \"insertion\",\n  inclusive: false,\n  excludes: \"deletion modification insertion\",\n  addAttributes() {\n    return {\n      id: { default: null, validate: \"number\" }, // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"insertion\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n\n      toDOM(mark, inline) {\n        return [\n          \"ins\",\n          {\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-inline\": String(inline),\n            ...(!inline && { style: \"display: contents\" }), // changed to \"contents\" to make this work for table rows\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"ins\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n\nexport const SuggestionDeleteMark = Mark.create({\n  name: \"deletion\",\n  inclusive: false,\n  excludes: \"insertion modification deletion\",\n  addAttributes() {\n    return {\n      id: { default: null, validate: \"number\" }, // note: validate is supported in prosemirror but not in tiptap\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"deletion\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n\n      // attrs: {\n      //   id: { validate: \"number\" },\n      // },\n      toDOM(mark, inline) {\n        return [\n          \"del\",\n          {\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-inline\": String(inline),\n            ...(!inline && { style: \"display: contents\" }), // changed to \"contents\" to make this work for table rows\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"del\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n\nexport const SuggestionModificationMark = Mark.create({\n  name: \"modification\",\n  inclusive: false,\n  excludes: \"deletion insertion\",\n  addAttributes() {\n    // note: validate is supported in prosemirror but not in tiptap\n    return {\n      id: { default: null, validate: \"number\" },\n      type: { validate: \"string\" },\n      attrName: { default: null, validate: \"string|null\" },\n      previousValue: { default: null },\n      newValue: { default: null },\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"modification\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n      // attrs: {\n      //   id: { validate: \"number\" },\n      //   type: { validate: \"string\" },\n      //   attrName: { default: null, validate: \"string|null\" },\n      //   previousValue: { default: null },\n      //   newValue: { default: null },\n      // },\n      toDOM(mark, inline) {\n        return [\n          inline ? \"span\" : \"div\",\n          {\n            \"data-type\": \"modification\",\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-mod-type\": mark.attrs[\"type\"] as string,\n            \"data-mod-prev-val\": JSON.stringify(mark.attrs[\"previousValue\"]),\n            // TODO: Try to serialize marks with toJSON?\n            \"data-mod-new-val\": JSON.stringify(mark.attrs[\"newValue\"]),\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"span[data-type='modification']\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n              type: node.dataset[\"modType\"],\n              previousValue: node.dataset[\"modPrevVal\"],\n              newValue: node.dataset[\"modNewVal\"],\n            };\n          },\n        },\n        {\n          tag: \"div[data-type='modification']\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n              type: node.dataset[\"modType\"],\n              previousValue: node.dataset[\"modPrevVal\"],\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n","import { Extension } from \"@tiptap/core\";\n\nexport const TextAlignmentExtension = Extension.create({\n  name: \"textAlignment\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        // Generally text alignment is handled through props using the custom\n        // blocks API. Tables are the only blocks that are created as TipTap\n        // nodes and ported to blocks, so we need to add text alignment in a\n        // separate extension.\n        types: [\"tableCell\", \"tableHeader\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (element) => {\n              return element.getAttribute(\"data-text-alignment\");\n            },\n            renderHTML: (attributes) => {\n              if (attributes.textAlignment === \"left\") {\n                return {};\n              }\n              return {\n                \"data-text-alignment\": attributes.textAlignment,\n              };\n            },\n          },\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { getTextColorAttribute } from \"../../../blocks/defaultProps.js\";\n\nexport const TextColorExtension = Extension.create({\n  name: \"blockTextColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"table\", \"tableCell\", \"tableHeader\"],\n        attributes: {\n          textColor: getTextColorAttribute(),\n        },\n      },\n    ];\n  },\n});\n","import { Node } from \"@tiptap/core\";\n\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockNoteDOMAttributes } from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\n// Object containing all possible block attributes.\nconst BlockAttributes: Record<string, string> = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\",\n};\n\n/**\n * The main \"Block node\" documents consist of\n */\nexport const BlockContainer = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n  editor: BlockNoteEditor<any, any, any>;\n}>({\n  name: \"blockContainer\",\n  group: \"blockGroupChild bnBlock\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: true,\n  marks: \"insertion modification deletion\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-node-type=\" + this.name + \"]\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const attrs: Record<string, string> = {};\n          for (const [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {\n            if (element.getAttribute(HTMLAttr)) {\n              attrs[nodeAttr] = element.getAttribute(HTMLAttr)!;\n            }\n          }\n\n          return attrs;\n        },\n      },\n      // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.\n      {\n        tag: `div[data-node-type=\"blockOuter\"]`,\n        skip: true,\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockOuter = document.createElement(\"div\");\n    blockOuter.className = \"bn-block-outer\";\n    blockOuter.setAttribute(\"data-node-type\", \"blockOuter\");\n    for (const [attribute, value] of Object.entries(HTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockOuter.setAttribute(attribute, value);\n      }\n    }\n\n    const blockHTMLAttributes = {\n      ...(this.options.domAttributes?.block || {}),\n      ...HTMLAttributes,\n    };\n    const block = document.createElement(\"div\");\n    block.className = mergeCSSClasses(\"bn-block\", blockHTMLAttributes.class);\n    block.setAttribute(\"data-node-type\", this.name);\n    for (const [attribute, value] of Object.entries(blockHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        block.setAttribute(attribute, value);\n      }\n    }\n\n    blockOuter.appendChild(block);\n\n    return {\n      dom: blockOuter,\n      contentDOM: block,\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\nimport { BlockNoteDOMAttributes } from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\nexport const BlockGroup = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n}>({\n  name: \"blockGroup\",\n  group: \"childContainer\",\n  content: \"blockGroupChild+\",\n  marks: \"deletion insertion modification\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockGroup\") {\n            // Null means the element matches, but we don't want to add any attributes to the node.\n            return null;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockGroupHTMLAttributes = {\n      ...(this.options.domAttributes?.blockGroup || {}),\n      ...HTMLAttributes,\n    };\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.className = mergeCSSClasses(\n      \"bn-block-group\",\n      blockGroupHTMLAttributes.class,\n    );\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    for (const [attribute, value] of Object.entries(blockGroupHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockGroup.setAttribute(attribute, value);\n      }\n    }\n\n    return {\n      dom: blockGroup,\n      contentDOM: blockGroup,\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\n\nexport const Doc = Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"blockGroup\",\n  marks: \"insertion modification deletion\",\n});\n","import type * as Y from \"yjs\";\nimport type { Awareness } from \"y-protocols/awareness\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { ForkYDocExtension } from \"./ForkYDoc.js\";\nimport { SchemaMigration } from \"./schemaMigration/SchemaMigration.js\";\nimport { YCursorExtension } from \"./YCursorPlugin.js\";\nimport { YSyncExtension } from \"./YSync.js\";\nimport { YUndoExtension } from \"./YUndo.js\";\n\nexport type CollaborationOptions = {\n  /**\n   * The Yjs XML fragment that's used for collaboration.\n   */\n  fragment: Y.XmlFragment;\n  /**\n   * The user info for the current user that's shown to other collaborators.\n   */\n  user: {\n    name: string;\n    color: string;\n  };\n  /**\n   * A Yjs provider (used for awareness / cursor information)\n   */\n  provider?: { awareness?: Awareness };\n  /**\n   * Optional function to customize how cursors of users are rendered\n   */\n  renderCursor?: (user: any) => HTMLElement;\n  /**\n   * Optional flag to set when the user label should be shown with the default\n   * collaboration cursor. Setting to \"always\" will always show the label,\n   * while \"activity\" will only show the label when the user moves the cursor\n   * or types. Defaults to \"activity\".\n   */\n  showCursorLabels?: \"always\" | \"activity\";\n};\n\nexport const CollaborationExtension = createExtension(\n  ({ options }: ExtensionOptions<CollaborationOptions>) => {\n    return {\n      key: \"collaboration\",\n      blockNoteExtensions: [\n        ForkYDocExtension(options),\n        YCursorExtension(options),\n        YSyncExtension(options),\n        YUndoExtension(),\n        SchemaMigration(options),\n      ],\n    } as const;\n  },\n);\n","import {\n  AnyExtension as AnyTiptapExtension,\n  extensions,\n  Node,\n  Extension as TiptapExtension,\n} from \"@tiptap/core\";\nimport { Gapcursor } from \"@tiptap/extension-gapcursor\";\nimport { Link } from \"@tiptap/extension-link\";\nimport { Text } from \"@tiptap/extension-text\";\nimport { createDropFileExtension } from \"../../../api/clipboard/fromClipboard/fileDropExtension.js\";\nimport { createPasteFromClipboardExtension } from \"../../../api/clipboard/fromClipboard/pasteExtension.js\";\nimport { createCopyToClipboardExtension } from \"../../../api/clipboard/toClipboard/copyExtension.js\";\nimport {\n  BlockChangeExtension,\n  DropCursorExtension,\n  FilePanelExtension,\n  FormattingToolbarExtension,\n  HistoryExtension,\n  LinkToolbarExtension,\n  NodeSelectionKeyboardExtension,\n  PlaceholderExtension,\n  PreviousBlockTypeExtension,\n  ShowSelectionExtension,\n  SideMenuExtension,\n  SuggestionMenu,\n  TableHandlesExtension,\n  TrailingNodeExtension,\n} from \"../../../extensions/index.js\";\nimport {\n  DEFAULT_LINK_PROTOCOL,\n  VALID_LINK_PROTOCOLS,\n} from \"../../../extensions/LinkToolbar/protocols.js\";\nimport {\n  BackgroundColorExtension,\n  HardBreak,\n  KeyboardShortcutsExtension,\n  SuggestionAddMark,\n  SuggestionDeleteMark,\n  SuggestionModificationMark,\n  TextAlignmentExtension,\n  TextColorExtension,\n  UniqueID,\n} from \"../../../extensions/tiptap-extensions/index.js\";\nimport { BlockContainer, BlockGroup, Doc } from \"../../../pm-nodes/index.js\";\nimport {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../BlockNoteEditor.js\";\nimport { ExtensionFactoryInstance } from \"../../BlockNoteExtension.js\";\nimport { CollaborationExtension } from \"../../../extensions/Collaboration/Collaboration.js\";\n\n// TODO remove linkify completely by vendoring the link extension & dropping linkifyjs as a dependency\nlet LINKIFY_INITIALIZED = false;\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nexport function getDefaultTiptapExtensions(\n  editor: BlockNoteEditor<any, any, any>,\n  options: BlockNoteEditorOptions<any, any, any>,\n) {\n  const tiptapExtensions: AnyTiptapExtension[] = [\n    extensions.ClipboardTextSerializer,\n    extensions.Commands,\n    extensions.Editable,\n    extensions.FocusEvents,\n    extensions.Tabindex,\n    Gapcursor,\n\n    UniqueID.configure({\n      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)\n      types: [\"blockContainer\", \"columnList\", \"column\"],\n      setIdAttribute: options.setIdAttribute,\n    }),\n    HardBreak,\n    Text,\n\n    // marks:\n    SuggestionAddMark,\n    SuggestionDeleteMark,\n    SuggestionModificationMark,\n    Link.extend({\n      inclusive: false,\n    }).configure({\n      defaultProtocol: DEFAULT_LINK_PROTOCOL,\n      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450\n      protocols: LINKIFY_INITIALIZED ? [] : VALID_LINK_PROTOCOLS,\n    }),\n    ...(Object.values(editor.schema.styleSpecs).map((styleSpec) => {\n      return styleSpec.implementation.mark.configure({\n        editor: editor,\n      });\n    }) as any[]),\n\n    TextColorExtension,\n\n    BackgroundColorExtension,\n    TextAlignmentExtension,\n\n    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)\n    TiptapExtension.create({\n      name: \"OverrideEscape\",\n      addKeyboardShortcuts: () => {\n        return {\n          Escape: () => {\n            if (editor.getExtension(SuggestionMenu)?.shown()) {\n              // escape should close the suggestion menu, but not blur the editor\n              return false;\n            }\n            editor.blur();\n            return true;\n          },\n        };\n      },\n    }),\n\n    // nodes\n    Doc,\n    BlockContainer.configure({\n      editor: editor,\n      domAttributes: options.domAttributes,\n    }),\n    KeyboardShortcutsExtension.configure({\n      editor: editor,\n      tabBehavior: options.tabBehavior,\n    }),\n    BlockGroup.configure({\n      domAttributes: options.domAttributes,\n    }),\n    ...Object.values(editor.schema.inlineContentSpecs)\n      .filter((a) => a.config !== \"link\" && a.config !== \"text\")\n      .map((inlineContentSpec) => {\n        return inlineContentSpec.implementation!.node.configure({\n          editor: editor,\n        });\n      }),\n\n    ...Object.values(editor.schema.blockSpecs).flatMap((blockSpec) => {\n      return [\n        // the node extension implementations\n        ...(\"node\" in blockSpec.implementation\n          ? [\n              (blockSpec.implementation.node as Node).configure({\n                editor: editor,\n                domAttributes: options.domAttributes,\n              }),\n            ]\n          : []),\n      ];\n    }),\n    createCopyToClipboardExtension(editor),\n    createPasteFromClipboardExtension(\n      editor,\n      options.pasteHandler ||\n        ((context: {\n          defaultPasteHandler: (context?: {\n            prioritizeMarkdownOverHTML?: boolean;\n            plainTextAsMarkdown?: boolean;\n          }) => boolean | undefined;\n        }) => context.defaultPasteHandler()),\n    ),\n    createDropFileExtension(editor),\n  ];\n\n  LINKIFY_INITIALIZED = true;\n\n  return tiptapExtensions;\n}\n\nexport function getDefaultExtensions(\n  editor: BlockNoteEditor<any, any, any>,\n  options: BlockNoteEditorOptions<any, any, any>,\n) {\n  const extensions = [\n    BlockChangeExtension(),\n    DropCursorExtension(options),\n    FilePanelExtension(options),\n    FormattingToolbarExtension(options),\n    LinkToolbarExtension(options),\n    NodeSelectionKeyboardExtension(),\n    PlaceholderExtension(options),\n    ShowSelectionExtension(options),\n    SideMenuExtension(options),\n    SuggestionMenu(options),\n    ...(options.trailingBlock !== false ? [TrailingNodeExtension()] : []),\n  ] as ExtensionFactoryInstance[];\n\n  if (options.collaboration) {\n    extensions.push(CollaborationExtension(options.collaboration));\n  } else {\n    // YUndo is not compatible with ProseMirror's history plugin\n    extensions.push(HistoryExtension());\n  }\n\n  if (\"table\" in editor.schema.blockSpecs) {\n    extensions.push(TableHandlesExtension(options));\n  }\n\n  if (options.animations !== false) {\n    extensions.push(PreviousBlockTypeExtension());\n  }\n\n  return extensions;\n}\n","import {\n  InputRule,\n  inputRules as inputRulesPlugin,\n} from \"@handlewithcare/prosemirror-inputrules\";\nimport {\n  AnyExtension as AnyTiptapExtension,\n  Extension as TiptapExtension,\n} from \"@tiptap/core\";\nimport { keymap } from \"@tiptap/pm/keymap\";\nimport { Plugin } from \"prosemirror-state\";\nimport { updateBlockTr } from \"../../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromTransaction } from \"../../../api/getBlockInfoFromPos.js\";\nimport { sortByDependencies } from \"../../../util/topo-sort.js\";\nimport type {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../BlockNoteEditor.js\";\nimport type {\n  Extension,\n  ExtensionFactoryInstance,\n  ExtensionFactory,\n} from \"../../BlockNoteExtension.js\";\nimport { originalFactorySymbol } from \"./symbol.js\";\nimport {\n  getDefaultExtensions,\n  getDefaultTiptapExtensions,\n} from \"./extensions.js\";\n\nexport class ExtensionManager {\n  /**\n   * A set of extension keys which are disabled by the options\n   */\n  private disabledExtensions = new Set<string>();\n  /**\n   * A list of all the extensions that are registered to the editor\n   */\n  private extensions: Extension[] = [];\n  /**\n   * A map of all the abort controllers for each extension that has an init method defined\n   */\n  private abortMap = new Map<Extension, AbortController>();\n  /**\n   * A map of all the extension factories that are registered to the editor\n   */\n  private extensionFactories = new Map<ExtensionFactory, Extension>();\n  /**\n   * Because a single blocknote extension can both have it's own prosemirror plugins & additional generated ones (e.g. keymap & input rules plugins)\n   * We need to keep track of all the plugins for each extension, so that we can remove them when the extension is unregistered\n   */\n  private extensionPlugins: Map<Extension, Plugin[]> = new Map();\n\n  constructor(\n    private editor: BlockNoteEditor<any, any, any>,\n    private options: BlockNoteEditorOptions<any, any, any>,\n  ) {\n    /**\n     * When the editor is first mounted, we need to initialize all the extensions\n     */\n    editor.onMount(() => {\n      for (const extension of this.extensions) {\n        // If the extension has an init function, we can initialize it, otherwise, it is already added to the editor\n        if (extension.mount) {\n          // We create an abort controller for each extension, so that we can abort the extension when the editor is unmounted\n          const abortController = new window.AbortController();\n          const unmountCallback = extension.mount({\n            dom: editor.prosemirrorView.dom,\n            root: editor.prosemirrorView.root,\n            signal: abortController.signal,\n          });\n          // If the extension returns a method to unmount it, we can register it to be called when the abort controller is aborted\n          if (unmountCallback) {\n            abortController.signal.addEventListener(\"abort\", () => {\n              unmountCallback();\n            });\n          }\n          // Keep track of the abort controller for each extension, so that we can abort it when the editor is unmounted\n          this.abortMap.set(extension, abortController);\n        }\n      }\n    });\n\n    /**\n     * When the editor is unmounted, we need to abort all the extensions' abort controllers\n     */\n    editor.onUnmount(() => {\n      for (const [extension, abortController] of this.abortMap.entries()) {\n        // No longer track the abort controller for this extension\n        this.abortMap.delete(extension);\n        // Abort each extension's abort controller\n        abortController.abort();\n      }\n    });\n\n    // TODO do disabled extensions need to be only for editor base extensions? Or all of them?\n    this.disabledExtensions = new Set(options.disableExtensions || []);\n\n    // Add the default extensions\n    for (const extension of getDefaultExtensions(this.editor, this.options)) {\n      this.addExtension(extension);\n    }\n\n    // Add the extensions from the options\n    for (const extension of this.options.extensions ?? []) {\n      this.addExtension(extension);\n    }\n\n    // Add the extensions from blocks specs\n    for (const block of Object.values(this.editor.schema.blockSpecs)) {\n      for (const extension of block.extensions ?? []) {\n        this.addExtension(extension);\n      }\n    }\n  }\n\n  /**\n   * Register one or more extensions to the editor after the editor is initialized.\n   *\n   * This allows users to switch on & off extensions \"at runtime\".\n   */\n  public registerExtension(\n    extension:\n      | Extension\n      | ExtensionFactoryInstance\n      | (Extension | ExtensionFactoryInstance)[],\n  ): void {\n    const extensions = ([] as (Extension | ExtensionFactoryInstance)[])\n      .concat(extension)\n      .filter(Boolean) as (Extension | ExtensionFactoryInstance)[];\n\n    if (!extensions.length) {\n      // eslint-disable-next-line no-console\n      console.warn(`No extensions found to register`, extension);\n      return;\n    }\n\n    const registeredExtensions = extensions\n      .map((extension) => this.addExtension(extension))\n      .filter(Boolean) as Extension[];\n\n    const pluginsToAdd = new Set<Plugin>();\n    for (const extension of registeredExtensions) {\n      if (extension?.tiptapExtensions) {\n        // This is necessary because this can only switch out prosemirror plugins at runtime,\n        // it can't switch out Tiptap extensions since that can have more widespread effects (since a Tiptap extension can even add/remove to the schema).\n\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Extension ${extension.key} has tiptap extensions, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,\n          extension,\n        );\n      }\n\n      if (extension?.inputRules?.length) {\n        // This is necessary because input rules are defined in a single prosemirror plugin which cannot be re-initialized.\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Extension ${extension.key} has input rules, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,\n          extension,\n        );\n      }\n\n      this.getProsemirrorPluginsFromExtension(extension).plugins.forEach(\n        (plugin) => {\n          pluginsToAdd.add(plugin);\n        },\n      );\n    }\n\n    // TODO there isn't a great way to do sorting right now. This is something that should be improved in the future.\n    // So, we just append to the end of the list for now.\n    this.updatePlugins((plugins) => [...plugins, ...pluginsToAdd]);\n  }\n\n  /**\n   * Register an extension to the editor\n   * @param extension - The extension to register\n   * @returns The extension instance\n   */\n  private addExtension(\n    extension: Extension | ExtensionFactoryInstance,\n  ): Extension | undefined {\n    let instance: Extension;\n    if (typeof extension === \"function\") {\n      instance = extension({ editor: this.editor });\n    } else {\n      instance = extension;\n    }\n\n    if (!instance || this.disabledExtensions.has(instance.key)) {\n      return undefined as any;\n    }\n\n    // Now that we know that the extension is not disabled, we can add it to the extension factories\n    if (typeof extension === \"function\") {\n      const originalFactory = (instance as any)[originalFactorySymbol] as (\n        ...args: any[]\n      ) => ExtensionFactoryInstance;\n\n      if (typeof originalFactory === \"function\") {\n        this.extensionFactories.set(originalFactory, instance);\n      }\n    }\n\n    this.extensions.push(instance);\n\n    if (instance.blockNoteExtensions) {\n      for (const extension of instance.blockNoteExtensions) {\n        this.addExtension(extension);\n      }\n    }\n\n    return instance as any;\n  }\n\n  /**\n   * Resolve an extension or a list of extensions into a list of extension instances\n   * @param toResolve - The extension or list of extensions to resolve\n   * @returns A list of extension instances\n   */\n  private resolveExtensions(\n    toResolve:\n      | undefined\n      | string\n      | Extension\n      | ExtensionFactory\n      | (Extension | ExtensionFactory | string | undefined)[],\n  ): Extension[] {\n    const extensions = [] as Extension[];\n    if (typeof toResolve === \"function\") {\n      const instance = this.extensionFactories.get(toResolve);\n      if (instance) {\n        extensions.push(instance);\n      }\n    } else if (Array.isArray(toResolve)) {\n      for (const extension of toResolve) {\n        extensions.push(...this.resolveExtensions(extension));\n      }\n    } else if (typeof toResolve === \"object\" && \"key\" in toResolve) {\n      extensions.push(toResolve);\n    } else if (typeof toResolve === \"string\") {\n      const instance = this.extensions.find((e) => e.key === toResolve);\n      if (instance) {\n        extensions.push(instance);\n      }\n    }\n    return extensions;\n  }\n\n  /**\n   * Unregister an extension from the editor\n   * @param toUnregister - The extension to unregister\n   * @returns void\n   */\n  public unregisterExtension(\n    toUnregister:\n      | undefined\n      | string\n      | Extension\n      | ExtensionFactory\n      | (Extension | ExtensionFactory | string | undefined)[],\n  ): void {\n    const extensions = this.resolveExtensions(toUnregister);\n\n    if (!extensions.length) {\n      // eslint-disable-next-line no-console\n      console.warn(`No extensions found to unregister`, toUnregister);\n      return;\n    }\n    let didWarn = false;\n\n    const pluginsToRemove = new Set<Plugin>();\n    for (const extension of extensions) {\n      this.extensions = this.extensions.filter((e) => e !== extension);\n      this.extensionFactories.forEach((instance, factory) => {\n        if (instance === extension) {\n          this.extensionFactories.delete(factory);\n        }\n      });\n      this.abortMap.get(extension)?.abort();\n      this.abortMap.delete(extension);\n\n      const plugins = this.extensionPlugins.get(extension);\n      plugins?.forEach((plugin) => {\n        pluginsToRemove.add(plugin);\n      });\n      this.extensionPlugins.delete(extension);\n\n      if (extension.tiptapExtensions && !didWarn) {\n        didWarn = true;\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Extension ${extension.key} has tiptap extensions, but they will not be removed. Please separate the extension into multiple extensions if you want to remove them, or re-initialize the editor.`,\n          toUnregister,\n        );\n      }\n    }\n\n    this.updatePlugins((plugins) =>\n      plugins.filter((plugin) => !pluginsToRemove.has(plugin)),\n    );\n  }\n\n  /**\n   * Allows resetting the current prosemirror state's plugins\n   * @param update - A function that takes the current plugins and returns the new plugins\n   * @returns void\n   */\n  private updatePlugins(update: (plugins: Plugin[]) => Plugin[]): void {\n    const currentState = this.editor.prosemirrorState;\n\n    const state = currentState.reconfigure({\n      plugins: update(currentState.plugins.slice()),\n    });\n\n    this.editor.prosemirrorView.updateState(state);\n  }\n\n  /**\n   * Get all the extensions that are registered to the editor\n   */\n  public getTiptapExtensions(): AnyTiptapExtension[] {\n    // Start with the default tiptap extensions\n    const tiptapExtensions = getDefaultTiptapExtensions(\n      this.editor,\n      this.options,\n    ).filter((extension) => !this.disabledExtensions.has(extension.name));\n\n    const getPriority = sortByDependencies(this.extensions);\n\n    const inputRulesByPriority = new Map<number, InputRule[]>();\n    for (const extension of this.extensions) {\n      if (extension.tiptapExtensions) {\n        tiptapExtensions.push(...extension.tiptapExtensions);\n      }\n\n      const priority = getPriority(extension.key);\n\n      const { plugins: prosemirrorPlugins, inputRules } =\n        this.getProsemirrorPluginsFromExtension(extension);\n      // Sometimes a blocknote extension might need to make additional prosemirror plugins, so we generate them here\n      if (prosemirrorPlugins.length) {\n        tiptapExtensions.push(\n          TiptapExtension.create({\n            name: extension.key,\n            priority,\n            addProseMirrorPlugins: () => prosemirrorPlugins,\n          }),\n        );\n      }\n      if (inputRules.length) {\n        if (!inputRulesByPriority.has(priority)) {\n          inputRulesByPriority.set(priority, []);\n        }\n        inputRulesByPriority.get(priority)!.push(...inputRules);\n      }\n    }\n\n    // Collect all input rules into 1 extension to reduce conflicts\n    tiptapExtensions.push(\n      TiptapExtension.create({\n        name: \"blocknote-input-rules\",\n        addProseMirrorPlugins() {\n          const rules = [] as InputRule[];\n          Array.from(inputRulesByPriority.keys())\n            // We sort the rules by their priority (the key)\n            .sort()\n            .reverse()\n            .forEach((priority) => {\n              // Append in reverse priority order\n              rules.push(...inputRulesByPriority.get(priority)!);\n            });\n          return [inputRulesPlugin({ rules })];\n        },\n      }),\n    );\n\n    // Add any tiptap extensions from the `_tiptapOptions`\n    for (const extension of this.options._tiptapOptions?.extensions ?? []) {\n      tiptapExtensions.push(extension);\n    }\n\n    return tiptapExtensions;\n  }\n\n  /**\n   * This maps a blocknote extension into an array of Prosemirror plugins if it has any of the following:\n   * - plugins\n   * - keyboard shortcuts\n   * - input rules\n   */\n  private getProsemirrorPluginsFromExtension(extension: Extension): {\n    plugins: Plugin[];\n    inputRules: InputRule[];\n  } {\n    const plugins: Plugin[] = [...(extension.prosemirrorPlugins ?? [])];\n    const inputRules: InputRule[] = [];\n    if (\n      !extension.prosemirrorPlugins?.length &&\n      !Object.keys(extension.keyboardShortcuts || {}).length &&\n      !extension.inputRules?.length\n    ) {\n      // We can bail out early if the extension has no features to add to the tiptap editor\n      return { plugins, inputRules };\n    }\n\n    this.extensionPlugins.set(extension, plugins);\n\n    if (extension.inputRules?.length) {\n      inputRules.push(\n        ...extension.inputRules.map((inputRule) => {\n          return new InputRule(inputRule.find, (state, match, start, end) => {\n            const replaceWith = inputRule.replace({\n              match,\n              range: { from: start, to: end },\n              editor: this.editor,\n            });\n            if (replaceWith) {\n              const cursorPosition = this.editor.getTextCursorPosition();\n\n              if (\n                this.editor.schema.blockSchema[cursorPosition.block.type]\n                  .content !== \"inline\"\n              ) {\n                return null;\n              }\n\n              const blockInfo = getBlockInfoFromTransaction(state.tr);\n              const tr = state.tr.deleteRange(start, end);\n\n              updateBlockTr(tr, blockInfo.bnBlock.beforePos, replaceWith);\n              return tr;\n            }\n            return null;\n          });\n        }),\n      );\n    }\n\n    if (Object.keys(extension.keyboardShortcuts || {}).length) {\n      plugins.push(\n        keymap(\n          Object.fromEntries(\n            Object.entries(extension.keyboardShortcuts!).map(([key, value]) => [\n              key,\n              () => value({ editor: this.editor }),\n            ]),\n          ),\n        ),\n      );\n    }\n\n    return { plugins, inputRules };\n  }\n\n  /**\n   * Get all extensions\n   */\n  public getExtensions(): Map<string, Extension> {\n    return new Map(\n      this.extensions.map((extension) => [extension.key, extension]),\n    );\n  }\n\n  /**\n   * Get a specific extension by it's instance\n   */\n  public getExtension<\n    const Ext extends Extension | ExtensionFactory = Extension,\n  >(\n    extension: string,\n  ):\n    | (Ext extends Extension\n        ? Ext\n        : Ext extends ExtensionFactory\n          ? ReturnType<ReturnType<Ext>>\n          : never)\n    | undefined;\n  public getExtension<const T extends ExtensionFactory>(\n    extension: T,\n  ): ReturnType<ReturnType<T>> | undefined;\n  public getExtension<const T extends ExtensionFactory | string = string>(\n    extension: T,\n  ):\n    | (T extends ExtensionFactory\n        ? ReturnType<ReturnType<T>>\n        : T extends string\n          ? Extension\n          : never)\n    | undefined {\n    if (typeof extension === \"string\") {\n      const instance = this.extensions.find((e) => e.key === extension);\n      if (!instance) {\n        return undefined;\n      }\n      return instance as any;\n    } else if (typeof extension === \"function\") {\n      const instance = this.extensionFactories.get(extension);\n      if (!instance) {\n        return undefined;\n      }\n      return instance as any;\n    }\n    throw new Error(`Invalid extension type: ${typeof extension}`);\n  }\n\n  /**\n   * Check if an extension exists\n   */\n  public hasExtension(key: string | Extension | ExtensionFactory): boolean {\n    if (typeof key === \"string\") {\n      return this.extensions.some((e) => e.key === key);\n    } else if (typeof key === \"object\" && \"key\" in key) {\n      return this.extensions.some((e) => e.key === key.key);\n    } else if (typeof key === \"function\") {\n      return this.extensionFactories.has(key);\n    }\n    return false;\n  }\n}\n","import type { Node, ResolvedPos } from \"prosemirror-model\";\n\n/**\n * Expands a range (start to end) to include the rest of the word if it starts or ends within a word\n */\nexport function expandPMRangeToWords(\n  doc: Node,\n  range: { $from: ResolvedPos; $to: ResolvedPos },\n) {\n  let { $from, $to } = range;\n\n  // Expand Start\n  // If the selection starts with a word character or punctuation, check if we need to expand left to include the rest of the word\n  if ($from.pos > $from.start() && $from.pos < doc.content.size) {\n    const charAfterStart = doc.textBetween($from.pos, $from.pos + 1);\n    if (/^[\\w\\p{P}]$/u.test(charAfterStart)) {\n      const textBefore = doc.textBetween($from.start(), $from.pos);\n      const wordMatch = textBefore.match(/[\\w\\p{P}]+$/u);\n      if (wordMatch) {\n        $from = doc.resolve($from.pos - wordMatch[0].length);\n      }\n    }\n  }\n\n  // Expand End\n  // If the selection ends with a word characte or punctuation, check if we need to expand right to include the rest of the word\n  if ($to.pos < $to.end() && $to.pos > 0) {\n    const charBeforeEnd = doc.textBetween($to.pos - 1, $to.pos);\n    if (/^[\\w\\p{P}]$/u.test(charBeforeEnd)) {\n      const textAfter = doc.textBetween($to.pos, $to.end());\n      const wordMatch = textAfter.match(/^[\\w\\p{P}]+/u);\n      if (wordMatch) {\n        $to = doc.resolve($to.pos + wordMatch[0].length);\n      }\n    }\n  }\n  return { $from, $to, from: $from.pos, to: $to.pos };\n}\n","import { TextSelection, type Transaction } from \"prosemirror-state\";\nimport { TableMap } from \"prosemirror-tables\";\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport { Selection } from \"../../../editor/selectionTypes.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { expandPMRangeToWords } from \"../../../util/expandToWords.js\";\nimport { getBlockInfo, getNearestBlockPos } from \"../../getBlockInfoFromPos.js\";\nimport {\n  nodeToBlock,\n  prosemirrorSliceToSlicedBlocks,\n} from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getBlockNoteSchema, getPmSchema } from \"../../pmUtil.js\";\n\nexport function getSelection<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(tr: Transaction): Selection<BSchema, I, S> | undefined {\n  const pmSchema = getPmSchema(tr);\n  // Return undefined if the selection is collapsed or a node is selected.\n  if (tr.selection.empty || \"node\" in tr.selection) {\n    return undefined;\n  }\n\n  const $startBlockBeforePos = tr.doc.resolve(\n    getNearestBlockPos(tr.doc, tr.selection.from).posBeforeNode,\n  );\n  const $endBlockBeforePos = tr.doc.resolve(\n    getNearestBlockPos(tr.doc, tr.selection.to).posBeforeNode,\n  );\n\n  // Converts the node at the given index and depth around `$startBlockBeforePos`\n  // to a block. Used to get blocks at given indices at the shared depth and\n  // at the depth of `$startBlockBeforePos`.\n  const indexToBlock = (\n    index: number,\n    depth?: number,\n  ): Block<BSchema, I, S> => {\n    const pos = $startBlockBeforePos.posAtIndex(index, depth);\n    const node = tr.doc.resolve(pos).nodeAfter;\n\n    if (!node) {\n      throw new Error(\n        `Error getting selection - node not found at position ${pos}`,\n      );\n    }\n\n    return nodeToBlock(node, pmSchema);\n  };\n\n  const blocks: Block<BSchema, I, S>[] = [];\n  // Minimum depth at which the blocks share a common ancestor.\n  const sharedDepth = $startBlockBeforePos.sharedDepth($endBlockBeforePos.pos);\n  const startIndex = $startBlockBeforePos.index(sharedDepth);\n  const endIndex = $endBlockBeforePos.index(sharedDepth);\n\n  // In most cases, we want to return the blocks spanned by the selection at the\n  // shared depth. However, when the block in which the selection starts is at a\n  // higher depth than the shared depth, we omit the first block at the shared\n  // depth. Instead, we include the first block at its depth, and any blocks at\n  // a higher index up to the shared depth. The following  example illustrates\n  // this:\n  // - id-0\n  //   - id-1\n  //     - >|id-2\n  //     - id-3\n  //   - id-4\n  //     - id-5\n  //   - id-6\n  // - id-7\n  // - id-8\n  // - id-9|<\n  //   - id-10\n  // Here, each block is represented by its ID, and the selection is represented\n  // by the `>|` and `|<` markers. So the selection starts in block `id-2` and\n  // ends in block `id-8`. In this case, the shared depth is 0, since the blocks\n  // `id-6`, `id-7`, and `id-8` set the shared depth, as they are the least\n  // nested blocks spanned by the selection. Therefore, these blocks are all\n  // added to the `blocks` array. However, the selection starts in block `id-2`,\n  // which is at a higher depth than the shared depth. So we add block `id-2` to\n  // the `blocks` array, as well as any later siblings (in this case, `id-3`),\n  // and move up one level of depth. The ancestor of block `id-2` at this depth\n  // is block `id-1`, so we add all its later siblings to the `blocks` array as\n  // well, again moving up one level of depth. Since we're now at the shared\n  // depth, we are done. The final `blocks` array for this example would be:\n  // [ id-2, id-3, id-4, id-6, id-7, id-8, id-9 ]\n  if ($startBlockBeforePos.depth > sharedDepth) {\n    // Adds the block that the selection starts in.\n    blocks.push(nodeToBlock($startBlockBeforePos.nodeAfter!, pmSchema));\n\n    // Traverses all depths from the depth of the block in which the selection\n    // starts, up to the shared depth.\n    for (let depth = $startBlockBeforePos.depth; depth > sharedDepth; depth--) {\n      const parentNode = $startBlockBeforePos.node(depth);\n\n      if (parentNode.type.isInGroup(\"childContainer\")) {\n        const startIndexAtDepth = $startBlockBeforePos.index(depth) + 1;\n        const childCountAtDepth = $startBlockBeforePos.node(depth).childCount;\n\n        // Adds all blocks after the index of the block in which the selection\n        // starts (or its ancestors at lower depths).\n        for (let i = startIndexAtDepth; i < childCountAtDepth; i++) {\n          blocks.push(indexToBlock(i, depth));\n        }\n      }\n    }\n  } else {\n    // Adds the first block spanned by the selection at the shared depth.\n    blocks.push(indexToBlock(startIndex, sharedDepth));\n  }\n\n  // Adds all blocks spanned by the selection at the shared depth, excluding\n  // the first.\n  for (let i = startIndex + 1; i <= endIndex; i++) {\n    blocks.push(indexToBlock(i, sharedDepth));\n  }\n\n  if (blocks.length === 0) {\n    throw new Error(\n      `Error getting selection - selection doesn't span any blocks (${tr.selection})`,\n    );\n  }\n\n  return {\n    blocks,\n  };\n}\n\nexport function setSelection(\n  tr: Transaction,\n  startBlock: BlockIdentifier,\n  endBlock: BlockIdentifier,\n) {\n  const startBlockId =\n    typeof startBlock === \"string\" ? startBlock : startBlock.id;\n  const endBlockId = typeof endBlock === \"string\" ? endBlock : endBlock.id;\n  const pmSchema = getPmSchema(tr);\n  const schema = getBlockNoteSchema(pmSchema);\n\n  if (startBlockId === endBlockId) {\n    throw new Error(\n      `Attempting to set selection with the same anchor and head blocks (id ${startBlockId})`,\n    );\n  }\n  const anchorPosInfo = getNodeById(startBlockId, tr.doc);\n  if (!anchorPosInfo) {\n    throw new Error(`Block with ID ${startBlockId} not found`);\n  }\n  const headPosInfo = getNodeById(endBlockId, tr.doc);\n  if (!headPosInfo) {\n    throw new Error(`Block with ID ${endBlockId} not found`);\n  }\n\n  const anchorBlockInfo = getBlockInfo(anchorPosInfo);\n  const headBlockInfo = getBlockInfo(headPosInfo);\n\n  const anchorBlockConfig =\n    schema.blockSchema[\n      anchorBlockInfo.blockNoteType as keyof typeof schema.blockSchema\n    ];\n  const headBlockConfig =\n    schema.blockSchema[\n      headBlockInfo.blockNoteType as keyof typeof schema.blockSchema\n    ];\n\n  if (\n    !anchorBlockInfo.isBlockContainer ||\n    anchorBlockConfig.content === \"none\"\n  ) {\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${startBlockId})`,\n    );\n  }\n  if (!headBlockInfo.isBlockContainer || headBlockConfig.content === \"none\") {\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${endBlockId})`,\n    );\n  }\n\n  let startPos: number;\n  let endPos: number;\n\n  if (anchorBlockConfig.content === \"table\") {\n    const tableMap = TableMap.get(anchorBlockInfo.blockContent.node);\n    const firstCellPos =\n      anchorBlockInfo.blockContent.beforePos +\n      tableMap.positionAt(0, 0, anchorBlockInfo.blockContent.node) +\n      1;\n    startPos = firstCellPos + 2;\n  } else {\n    startPos = anchorBlockInfo.blockContent.beforePos + 1;\n  }\n\n  if (headBlockConfig.content === \"table\") {\n    const tableMap = TableMap.get(headBlockInfo.blockContent.node);\n    const lastCellPos =\n      headBlockInfo.blockContent.beforePos +\n      tableMap.positionAt(\n        tableMap.height - 1,\n        tableMap.width - 1,\n        headBlockInfo.blockContent.node,\n      ) +\n      1;\n    const lastCellNodeSize = tr.doc.resolve(lastCellPos).nodeAfter!.nodeSize;\n    endPos = lastCellPos + lastCellNodeSize - 2;\n  } else {\n    endPos = headBlockInfo.blockContent.afterPos - 1;\n  }\n\n  // TODO: We should polish up the `MultipleNodeSelection` and use that instead.\n  //  Right now it's missing a few things like a jsonID and styling to show\n  //  which nodes are selected. `TextSelection` is ok for now, but has the\n  //  restriction that the start/end blocks must have content.\n  tr.setSelection(TextSelection.create(tr.doc, startPos, endPos));\n}\n\nexport function getSelectionCutBlocks(tr: Transaction, expandToWords = false) {\n  // TODO: fix image node selection\n\n  const pmSchema = getPmSchema(tr);\n\n  const range = expandToWords\n    ? expandPMRangeToWords(tr.doc, tr.selection)\n    : tr.selection;\n\n  let start = range.$from;\n  let end = range.$to;\n\n  // the selection moves below are used to make sure `prosemirrorSliceToSlicedBlocks` returns\n  // the correct information about whether content is cut at the start or end of a block\n\n  // if the end is at the end of a node (|</span></p>) move it forward so we include all closing tags (</span></p>|)\n  while (end.parentOffset >= end.parent.nodeSize - 2 && end.depth > 0) {\n    end = tr.doc.resolve(end.pos + 1);\n  }\n\n  // if the end is at the start of an empty node (</span></p><p>|) move it backwards so we drop empty start tags (</span></p>|)\n  while (end.parentOffset === 0 && end.depth > 0) {\n    end = tr.doc.resolve(end.pos - 1);\n  }\n\n  // if the start is at the start of a node (<p><span>|) move it backwards so we include all open tags (|<p><span>)\n  while (start.parentOffset === 0 && start.depth > 0) {\n    start = tr.doc.resolve(start.pos - 1);\n  }\n\n  // if the start is at the end of a node (|</p><p><span>|) move it forwards so we drop all closing tags (|<p><span>)\n  while (start.parentOffset >= start.parent.nodeSize - 2 && start.depth > 0) {\n    start = tr.doc.resolve(start.pos + 1);\n  }\n\n  const selectionInfo = prosemirrorSliceToSlicedBlocks(\n    tr.doc.slice(start.pos, end.pos, true),\n    pmSchema,\n  );\n\n  return {\n    _meta: {\n      startPos: start.pos,\n      endPos: end.pos,\n    },\n    ...selectionInfo,\n  };\n}\n","import type { Node } from \"prosemirror-model\";\nimport {\n  NodeSelection,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport type { TextCursorPosition } from \"../../../editor/cursorPositionTypes.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../util/typescript.js\";\nimport {\n  getBlockInfo,\n  getBlockInfoFromTransaction,\n} from \"../../getBlockInfoFromPos.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getBlockNoteSchema, getPmSchema } from \"../../pmUtil.js\";\n\nexport function getTextCursorPosition<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(tr: Transaction): TextCursorPosition<BSchema, I, S> {\n  const { bnBlock } = getBlockInfoFromTransaction(tr);\n  const pmSchema = getPmSchema(tr.doc);\n\n  const resolvedPos = tr.doc.resolve(bnBlock.beforePos);\n  // Gets previous blockContainer node at the same nesting level, if the current node isn't the first child.\n  const prevNode = resolvedPos.nodeBefore;\n\n  // Gets next blockContainer node at the same nesting level, if the current node isn't the last child.\n  const nextNode = tr.doc.resolve(bnBlock.afterPos).nodeAfter;\n\n  // Gets parent blockContainer node, if the current node is nested.\n  let parentNode: Node | undefined = undefined;\n  if (resolvedPos.depth > 1) {\n    // for nodes nested in bnBlocks\n    parentNode = resolvedPos.node();\n    if (!parentNode.type.isInGroup(\"bnBlock\")) {\n      // for blockGroups, we need to go one level up\n      parentNode = resolvedPos.node(resolvedPos.depth - 1);\n    }\n  }\n\n  return {\n    block: nodeToBlock(bnBlock.node, pmSchema),\n    prevBlock: prevNode === null ? undefined : nodeToBlock(prevNode, pmSchema),\n    nextBlock: nextNode === null ? undefined : nodeToBlock(nextNode, pmSchema),\n    parentBlock:\n      parentNode === undefined ? undefined : nodeToBlock(parentNode, pmSchema),\n  };\n}\n\nexport function setTextCursorPosition(\n  tr: Transaction,\n  targetBlock: BlockIdentifier,\n  placement: \"start\" | \"end\" = \"start\",\n) {\n  const id = typeof targetBlock === \"string\" ? targetBlock : targetBlock.id;\n  const pmSchema = getPmSchema(tr.doc);\n  const schema = getBlockNoteSchema(pmSchema);\n\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  const info = getBlockInfo(posInfo);\n\n  const contentType: \"none\" | \"inline\" | \"table\" =\n    schema.blockSchema[info.blockNoteType]!.content;\n\n  if (info.isBlockContainer) {\n    const blockContent = info.blockContent;\n    if (contentType === \"none\") {\n      tr.setSelection(NodeSelection.create(tr.doc, blockContent.beforePos));\n      return;\n    }\n\n    if (contentType === \"inline\") {\n      if (placement === \"start\") {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.beforePos + 1),\n        );\n      } else {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.afterPos - 1),\n        );\n      }\n    } else if (contentType === \"table\") {\n      if (placement === \"start\") {\n        // Need to offset the position as we have to get through the `tableRow`\n        // and `tableCell` nodes to get to the `tableParagraph` node we want to\n        // set the selection in.\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.beforePos + 4),\n        );\n      } else {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.afterPos - 4),\n        );\n      }\n    } else {\n      throw new UnreachableCaseError(contentType);\n    }\n  } else {\n    const child =\n      placement === \"start\"\n        ? info.childContainer.node.firstChild!\n        : info.childContainer.node.lastChild!;\n\n    setTextCursorPosition(tr, child.attrs.id, placement);\n  }\n}\n","import { isNodeSelection, posToDOMRect } from \"@tiptap/core\";\nimport {\n  getSelection,\n  getSelectionCutBlocks,\n  setSelection,\n} from \"../../api/blockManipulation/selections/selection.js\";\nimport {\n  getTextCursorPosition,\n  setTextCursorPosition,\n} from \"../../api/blockManipulation/selections/textCursorPosition.js\";\nimport {\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\nimport { TextCursorPosition } from \"../cursorPositionTypes.js\";\nimport { Selection } from \"../selectionTypes.js\";\n\nexport class SelectionManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getSelection(tr));\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned block will be\n   * only the part of the block that is included in the selection.\n   */\n  public getSelectionCutBlocks(expandToWords = false) {\n    return this.editor.transact((tr) => getSelectionCutBlocks(tr, expandToWords));\n  }\n\n  /**\n   * Sets the selection to a range of blocks.\n   * @param startBlock The identifier of the block that should be the start of the selection.\n   * @param endBlock The identifier of the block that should be the end of the selection.\n   */\n  public setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier) {\n    return this.editor.transact((tr) => setSelection(tr, startBlock, endBlock));\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this.editor.transact((tr) => getTextCursorPosition(tr));\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\",\n  ) {\n    return this.editor.transact((tr) =>\n      setTextCursorPosition(tr, targetBlock, placement),\n    );\n  }\n\n  /**\n   * Gets the bounding box of the current selection.\n   */\n  public getSelectionBoundingBox() {\n    if (!this.editor.prosemirrorView) {\n      return undefined;\n    }\n\n    const { selection } = this.editor.prosemirrorState;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.editor.prosemirrorView.nodeDOM(from) as HTMLElement;\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(\n      this.editor.prosemirrorView,\n      from,\n      to,\n    ).toJSON() as DOMRect;\n  }\n}\n","import { Command, Transaction } from \"prosemirror-state\";\nimport type { YUndoExtension } from \"../../extensions/Collaboration/YUndo.js\";\nimport type { HistoryExtension } from \"../../extensions/History/History.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class StateManager {\n  constructor(private editor: BlockNoteEditor<any, any, any>) {}\n\n  /**\n   * Stores the currently active transaction, which is the accumulated transaction from all {@link dispatch} calls during a {@link transact} calls\n   */\n  private activeTransaction: Transaction | null = null;\n\n  /**\n   * For any command that can be executed, you can check if it can be executed by calling `editor.can(command)`.\n   * @example\n   * ```ts\n   * if (editor.can(editor.undo)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   */\n  public can(cb: () => boolean) {\n    try {\n      this.isInCan = true;\n      return cb();\n    } finally {\n      this.isInCan = false;\n    }\n  }\n\n  // Flag to indicate if we're in a `can` call\n  private isInCan = false;\n\n  /**\n   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.\n   *\n   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.\n   *\n   * @example\n   * ```ts\n   * editor.exec((state, dispatch, view) => {\n   *   dispatch(state.tr.insertText(\"Hello, world!\"));\n   * });\n   * ```\n   */\n  public exec(command: Command) {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call\",\n      );\n    }\n    if (this.isInCan) {\n      return this.canExec(command);\n    }\n    const state = this.prosemirrorState;\n    const view = this.prosemirrorView;\n    const dispatch = (tr: Transaction) => this.prosemirrorView.dispatch(tr);\n\n    return command(state, dispatch, view);\n  }\n\n  /**\n   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.\n   *\n   * @example\n   * ```ts\n   * if (editor.canExec(command)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   * ```\n   */\n  public canExec(command: Command): boolean {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call\",\n      );\n    }\n    const state = this.prosemirrorState;\n    const view = this.prosemirrorView;\n\n    return command(state, undefined, view);\n  }\n\n  /**\n   * Execute a function within a \"blocknote transaction\".\n   * All changes to the editor within the transaction will be grouped together, so that\n   * we can dispatch them as a single operation (thus creating only a single undo step)\n   *\n   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.\n   *\n   * @example\n   * ```ts\n   * // All changes to the editor will be grouped together\n   * editor.transact((tr) => {\n   *   tr.insertText(\"Hello, world!\");\n   * // These two operations will be grouped together in a single undo step\n   *   editor.transact((tr) => {\n   *     tr.insertText(\"Hello, world!\");\n   *   });\n   * });\n   * ```\n   */\n  public transact<T>(\n    callback: (\n      /**\n       * The current active transaction, this will automatically be dispatched to the editor when the callback is complete\n       * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.\n       */\n      tr: Transaction,\n    ) => T,\n  ): T {\n    if (this.activeTransaction) {\n      // Already in a transaction, so we can just callback immediately\n      return callback(this.activeTransaction);\n    }\n\n    try {\n      // Enter transaction mode, by setting a starting transaction\n      this.activeTransaction = this.editor._tiptapEditor.state.tr;\n\n      // Capture all dispatch'd transactions\n      const result = callback(this.activeTransaction);\n\n      // Any transactions captured by the `dispatch` call will be stored in `this.activeTransaction`\n      const activeTr = this.activeTransaction;\n\n      this.activeTransaction = null;\n      if (\n        activeTr &&\n        // Only dispatch if the transaction was actually modified in some way\n        (activeTr.docChanged ||\n          activeTr.selectionSet ||\n          activeTr.scrolledIntoView ||\n          activeTr.storedMarksSet ||\n          !activeTr.isGeneric)\n      ) {\n        // Dispatch the transaction if it was modified\n        this.prosemirrorView.dispatch(activeTr);\n      }\n\n      return result;\n    } finally {\n      // We wrap this in a finally block to ensure we don't disable future transactions just because of an error in the callback\n      this.activeTransaction = null;\n    }\n  }\n  /**\n   * Get the underlying prosemirror state\n   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date\n   * @see https://prosemirror.net/docs/ref/#state.EditorState\n   */\n  public get prosemirrorState() {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state\",\n      );\n    }\n    return this.editor._tiptapEditor.state;\n  }\n\n  /**\n   * Get the underlying prosemirror view\n   * @see https://prosemirror.net/docs/ref/#view.EditorView\n   */\n  public get prosemirrorView() {\n    return this.editor._tiptapEditor.view;\n  }\n\n  public isFocused() {\n    return this.prosemirrorView?.hasFocus() || false;\n  }\n\n  public focus() {\n    this.prosemirrorView?.focus();\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    if (!this.editor._tiptapEditor) {\n      if (!this.editor.headless) {\n        throw new Error(\"no editor, but also not headless?\");\n      }\n      return false;\n    }\n    return this.editor._tiptapEditor.isEditable === undefined\n      ? true\n      : this.editor._tiptapEditor.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    if (!this.editor._tiptapEditor) {\n      if (!this.editor.headless) {\n        throw new Error(\"no editor, but also not headless?\");\n      }\n      // not relevant on headless\n      return;\n    }\n    if (this.editor._tiptapEditor.options.editable !== editable) {\n      this.editor._tiptapEditor.setEditable(editable);\n    }\n  }\n\n  /**\n   * Undo the last action.\n   */\n  public undo(): boolean {\n    // Purposefully not using the UndoPlugin to not import y-prosemirror when not needed\n    const undoPlugin = this.editor.getExtension<typeof YUndoExtension>(\"yUndo\");\n    if (undoPlugin) {\n      return this.exec(undoPlugin.undoCommand);\n    }\n\n    const historyPlugin =\n      this.editor.getExtension<typeof HistoryExtension>(\"history\");\n    if (historyPlugin) {\n      return this.exec(historyPlugin.undoCommand);\n    }\n\n    throw new Error(\"No undo plugin found\");\n  }\n\n  /**\n   * Redo the last action.\n   */\n  public redo() {\n    const undoPlugin = this.editor.getExtension<typeof YUndoExtension>(\"yUndo\");\n    if (undoPlugin) {\n      return this.exec(undoPlugin.redoCommand);\n    }\n\n    const historyPlugin =\n      this.editor.getExtension<typeof HistoryExtension>(\"history\");\n    if (historyPlugin) {\n      return this.exec(historyPlugin.redoCommand);\n    }\n\n    throw new Error(\"No redo plugin found\");\n  }\n}\n","import { selectionToInsertionEnd } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\n\nimport type { Transaction } from \"prosemirror-state\";\n\n// similar to tiptap insertContentAt\nexport function insertContentAt(\n  tr: Transaction,\n  position: number | { from: number; to: number },\n  nodes: Node[],\n  options: {\n    updateSelection: boolean;\n  } = { updateSelection: true },\n) {\n  // dont dispatch an empty fragment because this can lead to strange errors\n  // if (content.toString() === \"<>\") {\n  //   return true;\n  // }\n\n  let { from, to } =\n    typeof position === \"number\"\n      ? { from: position, to: position }\n      : { from: position.from, to: position.to };\n\n  let isOnlyTextContent = true;\n  let isOnlyBlockContent = true;\n  // const nodes = isFragment(content) ? content : [content];\n\n  let text = \"\";\n\n  nodes.forEach((node) => {\n    // check if added node is valid\n    node.check();\n\n    if (isOnlyTextContent && node.isText && node.marks.length === 0) {\n      text += node.text;\n    } else {\n      isOnlyTextContent = false;\n    }\n\n    isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n  });\n\n  // check if we can replace the wrapping node by\n  // the newly inserted content\n  // example:\n  // replace an empty paragraph by an inserted image\n  // instead of inserting the image below the paragraph\n  if (from === to && isOnlyBlockContent) {\n    const { parent } = tr.doc.resolve(from);\n    const isEmptyTextBlock =\n      parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n\n    if (isEmptyTextBlock) {\n      from -= 1;\n      to += 1;\n    }\n  }\n\n  // if there is only plain text we have to use `insertText`\n  // because this will keep the current marks\n  if (isOnlyTextContent) {\n    // if value is string, we can use it directly\n    // otherwise if it is an array, we have to join it\n    // if (Array.isArray(value)) {\n    //   tr.insertText(value.map((v) => v.text || \"\").join(\"\"), from, to);\n    // } else if (typeof value === \"object\" && !!value && !!value.text) {\n    //   tr.insertText(value.text, from, to);\n    // } else {\n    //   tr.insertText(value as string, from, to);\n    // }\n    tr.insertText(text, from, to);\n  } else {\n    tr.replaceWith(from, to, nodes);\n  }\n\n  // set cursor at end of inserted content\n  if (options.updateSelection) {\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n  }\n\n  return true;\n}\n","import { insertContentAt } from \"../../api/blockManipulation/insertContentAt.js\";\nimport { inlineContentToNodes } from \"../../api/nodeConversions/blockToNode.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  PartialInlineContent,\n  StyleSchema,\n  Styles,\n} from \"../../schema/index.js\";\nimport {\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../../blocks/defaultBlocks.js\";\nimport { TextSelection } from \"@tiptap/pm/state\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class StyleManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(\n    content: PartialInlineContent<ISchema, SSchema>,\n    { updateSelection = false }: { updateSelection?: boolean } = {},\n  ) {\n    const nodes = inlineContentToNodes(content, this.editor.pmSchema);\n\n    this.editor.transact((tr) => {\n      insertContentAt(\n        tr,\n        {\n          from: tr.selection.from,\n          to: tr.selection.to,\n        },\n        nodes,\n        {\n          updateSelection,\n        },\n      );\n    });\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles() {\n    return this.editor.transact((tr) => {\n      const styles: Styles<SSchema> = {};\n      const marks = tr.selection.$to.marks();\n\n      for (const mark of marks) {\n        const config = this.editor.schema.styleSchema[mark.type.name];\n        if (!config) {\n          if (\n            // Links are not considered styles in blocknote\n            mark.type.name !== \"link\" &&\n            // \"blocknoteIgnore\" tagged marks (such as comments) are also not considered BlockNote \"styles\"\n            !mark.type.spec.blocknoteIgnore\n          ) {\n            // eslint-disable-next-line no-console\n            console.warn(\"mark not found in styleschema\", mark.type.name);\n          }\n\n          continue;\n        }\n        if (config.propSchema === \"boolean\") {\n          (styles as any)[config.type] = true;\n        } else {\n          (styles as any)[config.type] = mark.attrs.stringValue;\n        }\n      }\n\n      return styles;\n    });\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.editor.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this.editor._tiptapEditor.commands.setMark(style);\n      } else if (config.propSchema === \"string\") {\n        this.editor._tiptapEditor.commands.setMark(style, {\n          stringValue: value,\n        });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    for (const style of Object.keys(styles)) {\n      this.editor._tiptapEditor.commands.unsetMark(style);\n    }\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.editor.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this.editor._tiptapEditor.commands.toggleMark(style);\n      } else if (config.propSchema === \"string\") {\n        this.editor._tiptapEditor.commands.toggleMark(style, {\n          stringValue: value,\n        });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this.editor.transact((tr) => {\n      return tr.doc.textBetween(tr.selection.from, tr.selection.to);\n    });\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this.editor._tiptapEditor.getAttributes(\"link\").href as\n      | string\n      | undefined;\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    if (url === \"\") {\n      return;\n    }\n    const mark = this.editor.pmSchema.mark(\"link\", { href: url });\n    this.editor.transact((tr) => {\n      const { from, to } = tr.selection;\n\n      if (text) {\n        tr.insertText(text, from, to).addMark(from, from + text.length, mark);\n      } else {\n        tr.setSelection(TextSelection.create(tr.doc, to)).addMark(\n          from,\n          to,\n          mark,\n        );\n      }\n    });\n  }\n}\n","import { Fragment, Schema, Slice } from \"@tiptap/pm/model\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\nimport { getBlockInfoFromSelection } from \"../api/getBlockInfoFromPos.js\";\n\n// helper function to remove a child from a fragment\nfunction removeChild(node: Fragment, n: number) {\n  const children: any[] = [];\n  node.forEach((child, _, i) => {\n    if (i !== n) {\n      children.push(child);\n    }\n  });\n  return Fragment.from(children);\n}\n\n/**\n * Wrap adjacent tableRow items in a table.\n *\n * This makes sure the content that we paste is always a table (and not a tableRow)\n * A table works better for the remaing paste handling logic, as it's actually a blockContent node\n */\nexport function wrapTableRows(f: Fragment, schema: Schema) {\n  const newItems: any[] = [];\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.name === \"tableRow\") {\n      if (\n        newItems.length > 0 &&\n        newItems[newItems.length - 1].type.name === \"table\"\n      ) {\n        // append to existing table\n        const prevTable = newItems[newItems.length - 1];\n        const newTable = prevTable.copy(prevTable.content.addToEnd(f.child(i)));\n        newItems[newItems.length - 1] = newTable;\n      } else {\n        // create new table to wrap tableRow with\n        const newTable = schema.nodes.table.createChecked(\n          undefined,\n          f.child(i),\n        );\n        newItems.push(newTable);\n      }\n    } else {\n      newItems.push(f.child(i));\n    }\n  }\n  f = Fragment.from(newItems);\n  return f;\n}\n\n/**\n * fix for https://github.com/ProseMirror/prosemirror/issues/1430#issuecomment-1822570821\n *\n * This fix wraps pasted ProseMirror nodes in their own `blockContainer` nodes\n * in most cases. This is to ensure that ProseMirror inserts them as separate\n * blocks, which it sometimes doesn't do because it doesn't have enough context\n * about the hierarchy of the pasted nodes. The issue can be seen when pasting\n * e.g. an image or two consecutive paragraphs, where PM tries to nest the\n * pasted block(s) when it shouldn't.\n *\n * However, the fix is not applied in a few cases. See `shouldApplyFix` for\n * which cases are excluded.\n */\nexport function transformPasted(slice: Slice, view: EditorView) {\n  let f = Fragment.from(slice.content);\n  f = wrapTableRows(f, view.state.schema);\n\n  if (!shouldApplyFix(f, view)) {\n    // Don't apply the fix.\n    return new Slice(f, slice.openStart, slice.openEnd);\n  }\n\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.spec.group === \"blockContent\") {\n      const content = [f.child(i)];\n\n      // when there is a blockGroup with lists, it should be nested in the new blockcontainer\n      // (if we remove this if-block, the nesting bug will be fixed, but lists won't be nested correctly)\n      if (\n        i + 1 < f.childCount &&\n        f.child(i + 1).type.name === \"blockGroup\" // TODO\n      ) {\n        const nestedChild = f\n          .child(i + 1)\n          .child(0)\n          .child(0);\n\n        if (\n          nestedChild.type.name === \"bulletListItem\" ||\n          nestedChild.type.name === \"numberedListItem\" ||\n          nestedChild.type.name === \"checkListItem\"\n        ) {\n          content.push(f.child(i + 1));\n          f = removeChild(f, i + 1);\n        }\n      }\n      const container = view.state.schema.nodes.blockContainer.createChecked(\n        undefined,\n        content,\n      );\n      f = f.replaceChild(i, container);\n    }\n  }\n  return new Slice(f, slice.openStart, slice.openEnd);\n}\n\n/**\n * Used in `transformPasted` to check if the fix there should be applied, i.e.\n * if the pasted fragment should be wrapped in a `blockContainer` node. This\n * will explicitly tell ProseMirror to treat it as a separate block.\n */\nfunction shouldApplyFix(fragment: Fragment, view: EditorView) {\n  const nodeHasSingleChild = fragment.childCount === 1;\n  const nodeHasInlineContent =\n    fragment.firstChild?.type.spec.content === \"inline*\";\n  const nodeHasTableContent =\n    fragment.firstChild?.type.spec.content === \"tableRow+\";\n\n  if (nodeHasSingleChild) {\n    if (nodeHasInlineContent) {\n      // Case when we paste a single node with inline content, e.g. a paragraph\n      // or heading. We want to insert the content in-line for better UX instead\n      // of a separate block, so we return false.\n      return false;\n    }\n\n    if (nodeHasTableContent) {\n      // Not ideal that we check selection here, as `transformPasted` is called\n      // for both paste and drop events. Drop events can potentially cause\n      // issues as they don't always happen at the current selection.\n      const blockInfo = getBlockInfoFromSelection(view.state);\n      if (blockInfo.isBlockContainer) {\n        const selectedBlockHasTableContent =\n          blockInfo.blockContent.node.type.spec.content === \"tableRow+\";\n\n        // Case for when we paste a single node with table content, i.e. a\n        // table. Normally, we return true as we want to ensure the table is\n        // inserted as a separate block. However, if the selection is in an\n        // existing table, we return false, as we want the content of the pasted\n        // table to be added to the existing one for better UX.\n        return !selectedBlockHasTableContent;\n      }\n    }\n  }\n\n  return true;\n}\n","import {\n  createDocument,\n  EditorOptions,\n  FocusPosition,\n  getSchema,\n  Editor as TiptapEditor,\n} from \"@tiptap/core\";\nimport { type Command, type Plugin, type Transaction } from \"@tiptap/pm/state\";\nimport { Node, Schema } from \"prosemirror-model\";\nimport type { BlocksChanged } from \"../api/getBlocksChangedByTransaction.js\";\nimport { blockToNode } from \"../api/nodeConversions/blockToNode.js\";\nimport {\n  Block,\n  BlockNoteSchema,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../blocks/index.js\";\nimport type { CollaborationOptions } from \"../extensions/Collaboration/Collaboration.js\";\nimport { BlockChangeExtension } from \"../extensions/index.js\";\nimport { UniqueID } from \"../extensions/tiptap-extensions/UniqueID/UniqueID.js\";\nimport type { Dictionary } from \"../i18n/dictionary.js\";\nimport { en } from \"../i18n/locales/index.js\";\nimport type {\n  BlockIdentifier,\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  BlockSpecs,\n  CustomBlockNoteSchema,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialInlineContent,\n  Styles,\n  StyleSchema,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport \"../style.css\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\nimport { EventEmitter } from \"../util/EventEmitter.js\";\nimport type { NoInfer } from \"../util/typescript.js\";\nimport { ExtensionFactoryInstance } from \"./BlockNoteExtension.js\";\nimport type { TextCursorPosition } from \"./cursorPositionTypes.js\";\nimport {\n  BlockManager,\n  EventManager,\n  ExportManager,\n  ExtensionManager,\n  SelectionManager,\n  StateManager,\n  StyleManager,\n} from \"./managers/index.js\";\nimport type { Selection } from \"./selectionTypes.js\";\nimport { transformPasted } from \"./transformPasted.js\";\n\nexport type BlockCache<\n  BSchema extends BlockSchema = any,\n  ISchema extends InlineContentSchema = any,\n  SSchema extends StyleSchema = any,\n> = WeakMap<Node, Block<BSchema, ISchema, SSchema>>;\n\nexport interface BlockNoteEditorOptions<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> {\n  /**\n   * Whether changes to blocks (like indentation, creating lists, changing headings) should be animated or not. Defaults to `true`.\n   *\n   * @default true\n   */\n  animations?: boolean;\n\n  /**\n   * Whether the editor should be focused automatically when it's created.\n   *\n   * @default false\n   */\n  autofocus?: FocusPosition;\n\n  /**\n   * When enabled, allows for collaboration between multiple users.\n   * See [Real-time Collaboration](https://www.blocknotejs.org/docs/advanced/real-time-collaboration) for more info.\n   */\n  collaboration?: CollaborationOptions;\n\n  /**\n   * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.\n   *\n   * @default true\n   */\n  defaultStyles?: boolean;\n\n  /**\n   * A dictionary object containing translations for the editor.\n   *\n   * See [Localization / i18n](https://www.blocknotejs.org/docs/advanced/localization) for more info.\n   *\n   * @remarks `Dictionary` is a type that contains all the translations for the editor.\n   */\n  dictionary?: Dictionary & Record<string, any>;\n\n  /**\n   * Disable internal extensions (based on keys / extension name)\n   *\n   * @note Advanced\n   */\n  disableExtensions?: string[];\n\n  /**\n   * An object containing attributes that should be added to HTML elements of the editor.\n   *\n   * See [Adding DOM Attributes](https://www.blocknotejs.org/docs/theming#adding-dom-attributes) for more info.\n   *\n   * @example { editor: { class: \"my-editor-class\" } }\n   * @remarks `Record<string, Record<string, string>>`\n   */\n  domAttributes?: Partial<BlockNoteDOMAttributes>;\n\n  /**\n   * A replacement indicator to use when dragging and dropping blocks. Uses the [ProseMirror drop cursor](https://github.com/ProseMirror/prosemirror-dropcursor), or a modified version when [Column Blocks](https://www.blocknotejs.org/docs/document-structure#column-blocks) are enabled.\n   * @remarks `() => Plugin`\n   */\n  dropCursor?: (opts: {\n    editor: BlockNoteEditor<\n      NoInfer<BSchema>,\n      NoInfer<ISchema>,\n      NoInfer<SSchema>\n    >;\n    color?: string | false;\n    width?: number;\n    class?: string;\n  }) => Plugin;\n\n  /**\n   * The content that should be in the editor when it's created, represented as an array of {@link PartialBlock} objects.\n   *\n   * See [Partial Blocks](https://www.blocknotejs.org/docs/editor-api/manipulating-blocks#partial-blocks) for more info.\n   *\n   * @remarks `PartialBlock[]`\n   */\n  initialContent?: PartialBlock<\n    NoInfer<BSchema>,\n    NoInfer<ISchema>,\n    NoInfer<SSchema>\n  >[];\n\n  /**\n   * @deprecated, provide placeholders via dictionary instead\n   * @internal\n   */\n  placeholders?: Record<\n    string | \"default\" | \"emptyDocument\",\n    string | undefined\n  >;\n\n  /**\n   * Custom paste handler that can be used to override the default paste behavior.\n   *\n   * See [Paste Handling](https://www.blocknotejs.org/docs/advanced/paste-handling) for more info.\n   *\n   * @remarks `PasteHandler`\n   * @returns The function should return `true` if the paste event was handled, otherwise it should return `false` if it should be canceled or `undefined` if it should be handled by another handler.\n   *\n   * @example\n   * ```ts\n   * pasteHandler: ({ defaultPasteHandler }) => {\n   *   return defaultPasteHandler({ pasteBehavior: \"prefer-html\" });\n   * }\n   * ```\n   */\n  pasteHandler?: (context: {\n    event: ClipboardEvent;\n    editor: BlockNoteEditor<\n      NoInfer<BSchema>,\n      NoInfer<ISchema>,\n      NoInfer<SSchema>\n    >;\n    /**\n     * The default paste handler\n     * @param context The context object\n     * @returns Whether the paste event was handled or not\n     */\n    defaultPasteHandler: (context?: {\n      /**\n       * Whether to prioritize Markdown content in `text/plain` over `text/html` when pasting from the clipboard.\n       * @default true\n       */\n      prioritizeMarkdownOverHTML?: boolean;\n      /**\n       * Whether to parse `text/plain` content from the clipboard as Markdown content.\n       * @default true\n       */\n      plainTextAsMarkdown?: boolean;\n    }) => boolean | undefined;\n  }) => boolean | undefined;\n\n  /**\n   * Resolve a URL of a file block to one that can be displayed or downloaded. This can be used for creating authenticated URL or\n   * implementing custom protocols / schemes\n   * @returns The URL that's\n   */\n  resolveFileUrl?: (url: string) => Promise<string>;\n\n  /**\n   * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n   *\n   * See [Custom Schemas](https://www.blocknotejs.org/docs/custom-schemas) for more info.\n   * @remarks `BlockNoteSchema`\n   */\n  schema: CustomBlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  /**\n   * A flag indicating whether to set an HTML ID for every block\n   *\n   * When set to `true`, on each block an id attribute will be set with the block id\n   * Otherwise, the HTML ID attribute will not be set.\n   *\n   * (note that the id is always set on the `data-id` attribute)\n   */\n  setIdAttribute?: boolean;\n\n  /**\n   * Determines behavior when pressing Tab (or Shift-Tab) while multiple blocks are selected and a toolbar is open.\n   * - `\"prefer-navigate-ui\"`: Changes focus to the toolbar. User must press Escape to close toolbar before indenting blocks. Better for keyboard accessibility.\n   * - `\"prefer-indent\"`: Always indents selected blocks, regardless of toolbar state. Keyboard navigation of toolbars not possible.\n   * @default \"prefer-navigate-ui\"\n   */\n  tabBehavior?: \"prefer-navigate-ui\" | \"prefer-indent\";\n\n  /**\n   * Allows enabling / disabling features of tables.\n   *\n   * See [Tables](https://www.blocknotejs.org/docs/editor-basics/document-structure#tables) for more info.\n   *\n   * @remarks `TableConfig`\n   */\n  tables?: {\n    /**\n     * Whether to allow splitting and merging cells within a table.\n     *\n     * @default false\n     */\n    splitCells?: boolean;\n    /**\n     * Whether to allow changing the background color of cells.\n     *\n     * @default false\n     */\n    cellBackgroundColor?: boolean;\n    /**\n     * Whether to allow changing the text color of cells.\n     *\n     * @default false\n     */\n    cellTextColor?: boolean;\n    /**\n     * Whether to allow changing cells into headers.\n     *\n     * @default false\n     */\n    headers?: boolean;\n  };\n\n  /**\n   * An option which user can pass with `false` value to disable the automatic creation of a trailing new block on the next line when the user types or edits any block.\n   *\n   * @default true\n   */\n  trailingBlock?: boolean;\n\n  /**\n   * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n   * This method should set when creating the editor as this is application-specific.\n   *\n   * `undefined` means the application doesn't support file uploads.\n   *\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n   * @remarks `(file: File) => Promise<UploadFileResult>`\n   */\n  uploadFile?: (\n    file: File,\n    blockId?: string,\n  ) => Promise<string | Record<string, any>>;\n\n  /**\n   * additional tiptap options, undocumented\n   * @internal\n   */\n  _tiptapOptions?: Partial<EditorOptions>;\n\n  /**\n   * Register extensions to the editor.\n   *\n   * See [Extensions](/docs/features/extensions) for more info.\n   *\n   * @remarks `ExtensionFactory[]`\n   */\n  extensions?: Array<ExtensionFactoryInstance>;\n}\n\nconst blockNoteTipTapOptions = {\n  enableInputRules: true,\n  enablePasteRules: true,\n  enableCoreExtensions: false,\n};\n\nexport class BlockNoteEditor<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> extends EventEmitter<{\n  create: void;\n}> {\n  /**\n   * The underlying prosemirror schema\n   */\n  public readonly pmSchema: Schema;\n\n  public readonly _tiptapEditor: TiptapEditor & {\n    contentComponent: any;\n  };\n\n  /**\n   * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements\n   * in the correct context (used by `ReactRenderUtil`)\n   */\n  public elementRenderer: ((node: any, container: HTMLElement) => void) | null =\n    null;\n\n  /**\n   * Cache of all blocks. This makes sure we don't have to \"recompute\" blocks if underlying Prosemirror Nodes haven't changed.\n   * This is especially useful when we want to keep track of the same block across multiple operations,\n   * with this cache, blocks stay the same object reference (referential equality with ===).\n   */\n  public blockCache: BlockCache = new WeakMap();\n\n  /**\n   * The dictionary contains translations for the editor.\n   */\n  public readonly dictionary: Dictionary & Record<string, any>;\n\n  /**\n   * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n   */\n  public readonly schema: BlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  public readonly blockImplementations: BlockSpecs;\n  public readonly inlineContentImplementations: InlineContentSpecs;\n  public readonly styleImplementations: StyleSpecs;\n\n  /**\n   * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n   * This method should set when creating the editor as this is application-specific.\n   *\n   * `undefined` means the application doesn't support file uploads.\n   *\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n   */\n  public readonly uploadFile:\n    | ((file: File, blockId?: string) => Promise<string | Record<string, any>>)\n    | undefined;\n\n  private onUploadStartCallbacks: ((blockId?: string) => void)[] = [];\n  private onUploadEndCallbacks: ((blockId?: string) => void)[] = [];\n\n  public readonly resolveFileUrl?: (url: string) => Promise<string>;\n  /**\n   * Editor settings\n   */\n  public readonly settings: {\n    tables: {\n      splitCells: boolean;\n      cellBackgroundColor: boolean;\n      cellTextColor: boolean;\n      headers: boolean;\n    };\n  };\n  public static create<\n    Options extends Partial<BlockNoteEditorOptions<any, any, any>> | undefined,\n  >(\n    options?: Options,\n  ): Options extends {\n    schema: CustomBlockNoteSchema<infer BSchema, infer ISchema, infer SSchema>;\n  }\n    ? BlockNoteEditor<BSchema, ISchema, SSchema>\n    : BlockNoteEditor<\n        DefaultBlockSchema,\n        DefaultInlineContentSchema,\n        DefaultStyleSchema\n      > {\n    return new BlockNoteEditor(options ?? {}) as any;\n  }\n\n  protected constructor(\n    protected readonly options: Partial<\n      BlockNoteEditorOptions<BSchema, ISchema, SSchema>\n    >,\n  ) {\n    super();\n\n    this.dictionary = options.dictionary || en;\n    this.settings = {\n      tables: {\n        splitCells: options?.tables?.splitCells ?? false,\n        cellBackgroundColor: options?.tables?.cellBackgroundColor ?? false,\n        cellTextColor: options?.tables?.cellTextColor ?? false,\n        headers: options?.tables?.headers ?? false,\n      },\n    };\n\n    // apply defaults\n    const newOptions = {\n      defaultStyles: true,\n      schema:\n        options.schema ||\n        (BlockNoteSchema.create() as unknown as CustomBlockNoteSchema<\n          BSchema,\n          ISchema,\n          SSchema\n        >),\n      ...options,\n      placeholders: {\n        ...this.dictionary.placeholders,\n        ...options.placeholders,\n      },\n    };\n\n    // @ts-ignore\n    this.schema = newOptions.schema;\n    this.blockImplementations = newOptions.schema.blockSpecs;\n    this.inlineContentImplementations = newOptions.schema.inlineContentSpecs;\n    this.styleImplementations = newOptions.schema.styleSpecs;\n\n    // TODO this should just be an extension\n    if (newOptions.uploadFile) {\n      const uploadFile = newOptions.uploadFile;\n      this.uploadFile = async (file, blockId) => {\n        this.onUploadStartCallbacks.forEach((callback) =>\n          callback.apply(this, [blockId]),\n        );\n        try {\n          return await uploadFile(file, blockId);\n        } finally {\n          this.onUploadEndCallbacks.forEach((callback) =>\n            callback.apply(this, [blockId]),\n          );\n        }\n      };\n    }\n\n    this.resolveFileUrl = newOptions.resolveFileUrl;\n\n    this._eventManager = new EventManager(this as any);\n    this._extensionManager = new ExtensionManager(this, newOptions);\n\n    const tiptapExtensions = this._extensionManager.getTiptapExtensions();\n\n    const collaborationEnabled =\n      this._extensionManager.hasExtension(\"ySync\") ||\n      this._extensionManager.hasExtension(\"liveblocksExtension\");\n\n    if (collaborationEnabled && newOptions.initialContent) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider\",\n      );\n    }\n\n    const tiptapOptions: EditorOptions = {\n      ...blockNoteTipTapOptions,\n      ...newOptions._tiptapOptions,\n      element: null,\n      autofocus: newOptions.autofocus ?? false,\n      extensions: tiptapExtensions,\n      editorProps: {\n        ...newOptions._tiptapOptions?.editorProps,\n        attributes: {\n          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not\n          // editable, so you can't focus it. We want to revert this as we have\n          // UI behaviour that relies on it.\n          tabIndex: \"0\",\n          ...newOptions._tiptapOptions?.editorProps?.attributes,\n          ...newOptions.domAttributes?.editor,\n          class: mergeCSSClasses(\n            \"bn-editor\",\n            newOptions.defaultStyles ? \"bn-default-styles\" : \"\",\n            newOptions.domAttributes?.editor?.class || \"\",\n          ),\n        },\n        transformPasted,\n      },\n    } as any;\n\n    try {\n      const initialContent =\n        newOptions.initialContent ||\n        (collaborationEnabled\n          ? [\n              {\n                type: \"paragraph\",\n                id: \"initialBlockId\",\n              },\n            ]\n          : [\n              {\n                type: \"paragraph\",\n                id: UniqueID.options.generateID(),\n              },\n            ]);\n\n      if (!Array.isArray(initialContent) || initialContent.length === 0) {\n        throw new Error(\n          \"initialContent must be a non-empty array of blocks, received: \" +\n            initialContent,\n        );\n      }\n      const schema = getSchema(tiptapOptions.extensions!);\n      const pmNodes = initialContent.map((b) =>\n        blockToNode(b, schema, this.schema.styleSchema).toJSON(),\n      );\n      const doc = createDocument(\n        {\n          type: \"doc\",\n          content: [\n            {\n              type: \"blockGroup\",\n              content: pmNodes,\n            },\n          ],\n        },\n        schema,\n        tiptapOptions.parseOptions,\n      );\n\n      this._tiptapEditor = new TiptapEditor({\n        ...tiptapOptions,\n        content: doc.toJSON(),\n      }) as any;\n      this.pmSchema = this._tiptapEditor.schema;\n    } catch (e) {\n      throw new Error(\n        \"Error creating document from blocks passed as `initialContent`\",\n        { cause: e },\n      );\n    }\n\n    // When y-prosemirror creates an empty document, the `blockContainer` node is created with an `id` of `null`.\n    // This causes the unique id extension to generate a new id for the initial block, which is not what we want\n    // Since it will be randomly generated & cause there to be more updates to the ydoc\n    // This is a hack to make it so that anytime `schema.doc.createAndFill` is called, the initial block id is already set to \"initialBlockId\"\n    let cache: Node | undefined = undefined;\n    const oldCreateAndFill = this.pmSchema.nodes.doc.createAndFill;\n    this.pmSchema.nodes.doc.createAndFill = (...args: any) => {\n      if (cache) {\n        return cache;\n      }\n      const ret = oldCreateAndFill.apply(this.pmSchema.nodes.doc, args)!;\n\n      // create a copy that we can mutate (otherwise, assigning attrs is not safe and corrupts the pm state)\n      const jsonNode = JSON.parse(JSON.stringify(ret.toJSON()));\n      jsonNode.content[0].content[0].attrs.id = \"initialBlockId\";\n\n      cache = Node.fromJSON(this.pmSchema, jsonNode);\n      return cache;\n    };\n    this.pmSchema.cached.blockNoteEditor = this;\n\n    // Initialize managers\n    this._blockManager = new BlockManager(this as any);\n\n    this._exportManager = new ExportManager(this as any);\n    this._selectionManager = new SelectionManager(this as any);\n    this._stateManager = new StateManager(this as any);\n    this._styleManager = new StyleManager(this as any);\n\n    this.emit(\"create\");\n  }\n\n  // Manager instances\n  private readonly _blockManager: BlockManager<any, any, any>;\n  private readonly _eventManager: EventManager<any, any, any>;\n  private readonly _exportManager: ExportManager<any, any, any>;\n  private readonly _extensionManager: ExtensionManager;\n  private readonly _selectionManager: SelectionManager<any, any, any>;\n  private readonly _stateManager: StateManager;\n  private readonly _styleManager: StyleManager<any, any, any>;\n\n  /**\n   * BlockNote extensions that are added to the editor, keyed by the extension key\n   */\n  public get extensions() {\n    return this._extensionManager.getExtensions();\n  }\n\n  /**\n   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.\n   *\n   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.\n   *\n   * @example\n   * ```ts\n   * editor.exec((state, dispatch, view) => {\n   *   dispatch(state.tr.insertText(\"Hello, world!\"));\n   * });\n   * ```\n   */\n  public exec(command: Command) {\n    return this._stateManager.exec(command);\n  }\n\n  /**\n   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.\n   *\n   * @example\n   * ```ts\n   * if (editor.canExec(command)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   * ```\n   */\n  public canExec(command: Command): boolean {\n    return this._stateManager.canExec(command);\n  }\n\n  /**\n   * Execute a function within a \"blocknote transaction\".\n   * All changes to the editor within the transaction will be grouped together, so that\n   * we can dispatch them as a single operation (thus creating only a single undo step)\n   *\n   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.\n   *\n   * @example\n   * ```ts\n   * // All changes to the editor will be grouped together\n   * editor.transact((tr) => {\n   *   tr.insertText(\"Hello, world!\");\n   * // These two operations will be grouped together in a single undo step\n   *   editor.transact((tr) => {\n   *     tr.insertText(\"Hello, world!\");\n   *   });\n   * });\n   * ```\n   */\n  public transact<T>(\n    callback: (\n      /**\n       * The current active transaction, this will automatically be dispatched to the editor when the callback is complete\n       * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.\n       */\n      tr: Transaction,\n    ) => T,\n  ): T {\n    return this._stateManager.transact(callback);\n  }\n\n  /**\n   * Remove extension(s) from the editor\n   */\n  public unregisterExtension: ExtensionManager[\"unregisterExtension\"] = (\n    ...args: Parameters<ExtensionManager[\"unregisterExtension\"]>\n  ) => this._extensionManager.unregisterExtension(...args);\n\n  /**\n   * Register extension(s) to the editor\n   */\n  public registerExtension: ExtensionManager[\"registerExtension\"] = (\n    ...args: Parameters<ExtensionManager[\"registerExtension\"]>\n  ) => this._extensionManager.registerExtension(...args) as any;\n\n  /**\n   * Get an extension from the editor\n   */\n  public getExtension: ExtensionManager[\"getExtension\"] = ((\n    ...args: Parameters<ExtensionManager[\"getExtension\"]>\n  ) => this._extensionManager.getExtension(...args)) as any;\n\n  /**\n   * Mount the editor to a DOM element.\n   *\n   * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting\n   */\n  public mount = (element: HTMLElement) => {\n    this._tiptapEditor.mount({ mount: element });\n  };\n\n  /**\n   * Unmount the editor from the DOM element it is bound to\n   */\n  public unmount = () => {\n    this._tiptapEditor.unmount();\n  };\n\n  /**\n   * Get the underlying prosemirror state\n   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date\n   * @see https://prosemirror.net/docs/ref/#state.EditorState\n   */\n  public get prosemirrorState() {\n    return this._stateManager.prosemirrorState;\n  }\n\n  /**\n   * Get the underlying prosemirror view\n   * @see https://prosemirror.net/docs/ref/#view.EditorView\n   */\n  public get prosemirrorView() {\n    return this._stateManager.prosemirrorView;\n  }\n\n  public get domElement() {\n    if (this.headless) {\n      return undefined;\n    }\n    return this.prosemirrorView?.dom as HTMLDivElement | undefined;\n  }\n\n  public isFocused() {\n    if (this.headless) {\n      return false;\n    }\n    return this.prosemirrorView?.hasFocus() || false;\n  }\n\n  public get headless() {\n    return !this._tiptapEditor.isInitialized;\n  }\n\n  /**\n   * Focus on the editor\n   */\n  public focus() {\n    if (this.headless) {\n      return;\n    }\n    this.prosemirrorView.focus();\n  }\n\n  /**\n   * Blur the editor\n   */\n  public blur() {\n    if (this.headless) {\n      return;\n    }\n    this.domElement?.blur();\n  }\n\n  // TODO move to extension\n  public onUploadStart(callback: (blockId?: string) => void) {\n    this.onUploadStartCallbacks.push(callback);\n\n    return () => {\n      const index = this.onUploadStartCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.onUploadStartCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  public onUploadEnd(callback: (blockId?: string) => void) {\n    this.onUploadEndCallbacks.push(callback);\n\n    return () => {\n      const index = this.onUploadEndCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.onUploadEndCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * @deprecated, use `editor.document` instead\n   */\n  public get topLevelBlocks(): Block<BSchema, ISchema, SSchema>[] {\n    return this.document;\n  }\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    return this._blockManager.document;\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  public getPrevBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getPrevBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  public getNextBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getNextBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  public getParentBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getParentBlock(blockIdentifier);\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false,\n  ): void {\n    this._blockManager.forEachBlock(callback, reverse);\n  }\n\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use {@link BlockNoteEditor.onChange} instead\n   */\n  public onEditorContentChange(callback: () => void) {\n    this._tiptapEditor.on(\"update\", callback);\n  }\n\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use `onSelectionChange` instead\n   */\n  public onEditorSelectionChange(callback: () => void) {\n    this._tiptapEditor.on(\"selectionUpdate\", callback);\n  }\n\n  /**\n   * Executes a callback before any change is applied to the editor, allowing you to cancel the change.\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onBeforeChange(\n    callback: (context: {\n      getChanges: () => BlocksChanged<BSchema, ISchema, SSchema>;\n      tr: Transaction;\n    }) => boolean | void,\n  ): () => void {\n    return this._extensionManager\n      .getExtension(BlockChangeExtension)!\n      .subscribe(callback);\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this._selectionManager.getTextCursorPosition();\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\",\n  ) {\n    return this._selectionManager.setTextCursorPosition(targetBlock, placement);\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    return this._selectionManager.getSelection();\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned block will be\n   * only the part of the block that is included in the selection.\n   */\n  public getSelectionCutBlocks(expandToWords = false) {\n    return this._selectionManager.getSelectionCutBlocks(expandToWords);\n  }\n\n  /**\n   * Sets the selection to a range of blocks.\n   * @param startBlock The identifier of the block that should be the start of the selection.\n   * @param endBlock The identifier of the block that should be the end of the selection.\n   */\n  public setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier) {\n    return this._selectionManager.setSelection(startBlock, endBlock);\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    return this._stateManager.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    this._stateManager.isEditable = editable;\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" = \"before\",\n  ) {\n    return this._blockManager.insertBlocks(\n      blocksToInsert,\n      referenceBlock,\n      placement,\n    );\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>,\n  ) {\n    return this._blockManager.updateBlock(blockToUpdate, update);\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return this._blockManager.removeBlocks(blocksToRemove);\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n  ) {\n    return this._blockManager.replaceBlocks(blocksToRemove, blocksToInsert);\n  }\n\n  /**\n   * Undo the last action.\n   */\n  public undo(): boolean {\n    return this._stateManager.undo();\n  }\n\n  /**\n   * Redo the last action.\n   */\n  public redo(): boolean {\n    return this._stateManager.redo();\n  }\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(\n    content: PartialInlineContent<ISchema, SSchema>,\n    { updateSelection = false }: { updateSelection?: boolean } = {},\n  ) {\n    this._styleManager.insertInlineContent(content, { updateSelection });\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles(): Styles<SSchema> {\n    return this._styleManager.getActiveStyles();\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    this._styleManager.addStyles(styles);\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    this._styleManager.removeStyles(styles);\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    this._styleManager.toggleStyles(styles);\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this._styleManager.getSelectedText();\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this._styleManager.getSelectedLinkUrl();\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    this._styleManager.createLink(url, text);\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    return this._blockManager.canNestBlock();\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    this._blockManager.nestBlock();\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    return this._blockManager.canUnnestBlock();\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    this._blockManager.unnestBlock();\n  }\n\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  public moveBlocksUp() {\n    return this._blockManager.moveBlocksUp();\n  }\n\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  public moveBlocksDown() {\n    return this._blockManager.moveBlocksDown();\n  }\n\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToHTMLLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToHTMLLossy(blocks);\n  }\n\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToFullHTML(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToFullHTML(blocks);\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public tryParseHTMLToBlocks(\n    html: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return this._exportManager.tryParseHTMLToBlocks(html);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public blocksToMarkdownLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToMarkdownLossy(blocks);\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public tryParseMarkdownToBlocks(\n    markdown: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return this._exportManager.tryParseMarkdownToBlocks(markdown);\n  }\n\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onChange(\n    callback: (\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n      context: {\n        /**\n         * Returns the blocks that were inserted, updated, or deleted by the change that occurred.\n         */\n        getChanges(): BlocksChanged<BSchema, ISchema, SSchema>;\n      },\n    ) => void,\n    /**\n     * If true, the callback will be triggered when the changes are caused by a remote user\n     * @default true\n     */\n    includeUpdatesFromRemote?: boolean,\n  ) {\n    return this._eventManager.onChange(callback, includeUpdatesFromRemote);\n  }\n\n  /**\n   * A callback function that runs whenever the text cursor position or selection changes.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onSelectionChange(\n    callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>) => void,\n    includeSelectionChangedByRemote?: boolean,\n  ) {\n    return this._eventManager.onSelectionChange(\n      callback,\n      includeSelectionChangedByRemote,\n    );\n  }\n\n  /**\n   * A callback function that runs when the editor has been mounted.\n   *\n   * This can be useful for plugins to initialize themselves after the editor has been mounted.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onMount(\n    callback: (ctx: {\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>;\n    }) => void,\n  ) {\n    this._eventManager.onMount(callback);\n  }\n\n  /**\n   * A callback function that runs when the editor has been unmounted.\n   *\n   * This can be useful for plugins to clean up themselves after the editor has been unmounted.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onUnmount(\n    callback: (ctx: {\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>;\n    }) => void,\n  ) {\n    this._eventManager.onUnmount(callback);\n  }\n\n  /**\n   * Gets the bounding box of the current selection.\n   * @returns The bounding box of the current selection.\n   */\n  public getSelectionBoundingBox() {\n    return this._selectionManager.getSelectionBoundingBox();\n  }\n\n  public get isEmpty() {\n    const doc = this.document;\n    // Note: only works for paragraphs as default blocks (but for now this is default in blocknote)\n    // checking prosemirror directly might be faster\n    return (\n      doc.length === 0 ||\n      (doc.length === 1 &&\n        doc[0].type === \"paragraph\" &&\n        (doc[0].content as any).length === 0)\n    );\n  }\n\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  public pasteHTML(html: string, raw = false) {\n    this._exportManager.pasteHTML(html, raw);\n  }\n\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  public pasteText(text: string) {\n    return this._exportManager.pasteText(text);\n  }\n\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  public pasteMarkdown(markdown: string) {\n    return this._exportManager.pasteMarkdown(markdown);\n  }\n}\n","import { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport {\n  BlockFromConfig,\n  BlockSchema,\n  InlineContent,\n  InlineContentSchema,\n  StyleSchema,\n  StyledText,\n  Styles,\n} from \"../schema/index.js\";\n\nimport type {\n  BlockMapping,\n  InlineContentMapping,\n  StyleMapping,\n} from \"./mapping.js\";\n\nexport type ExporterOptions = {\n  /**\n   * A function that can be used to resolve files, images, etc.\n   * Exporters might need the binary contents of files like images,\n   * which might not always be available from the same origin as the main page.\n   * You can use this option to proxy requests through a server you control\n   * to avoid cross-origin (CORS) issues.\n   *\n   * @default uses a BlockNote hosted proxy (https://corsproxy.api.blocknotejs.org/)\n   * @param url - The URL of the file to resolve\n   * @returns A Promise that resolves to a string (the URL to use instead of the original)\n   * or a Blob (you can return the Blob directly if you have already fetched it)\n   */\n  resolveFileUrl?: (url: string) => Promise<string | Blob>;\n  /**\n   * Colors to use for background of blocks, font colors, and highlight colors\n   */\n  colors: typeof COLORS_DEFAULT;\n};\nexport abstract class Exporter<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RB,\n  RI,\n  RS,\n  TS,\n> {\n  public constructor(\n    _schema: BlockNoteSchema<B, I, S>, // only used for type inference\n    protected readonly mappings: {\n      blockMapping: BlockMapping<B, I, S, RB, RI>;\n      inlineContentMapping: InlineContentMapping<I, S, RI, TS>;\n      styleMapping: StyleMapping<S, RS>;\n    },\n    public readonly options: ExporterOptions,\n  ) {}\n\n  public async resolveFile(url: string) {\n    if (!this.options?.resolveFileUrl) {\n      return (await fetch(url)).blob();\n    }\n    const ret = await this.options.resolveFileUrl(url);\n    if (ret instanceof Blob) {\n      return ret;\n    }\n    return (await fetch(ret)).blob();\n  }\n\n  public mapStyles(styles: Styles<S>) {\n    const stylesArray = Object.entries(styles).map(([key, value]) => {\n      const mappedStyle = this.mappings.styleMapping[key](value, this);\n      return mappedStyle;\n    });\n    return stylesArray;\n  }\n\n  public mapInlineContent(inlineContent: InlineContent<I, S>) {\n    return this.mappings.inlineContentMapping[inlineContent.type](\n      inlineContent,\n      this,\n    );\n  }\n\n  public transformInlineContent(inlineContentArray: InlineContent<I, S>[]) {\n    return inlineContentArray.map((ic) => this.mapInlineContent(ic));\n  }\n\n  public abstract transformStyledText(styledText: StyledText<S>): TS;\n\n  public async mapBlock(\n    block: BlockFromConfig<B[keyof B], I, S>,\n    nestingLevel: number,\n    numberedListIndex: number,\n    children?: Array<Awaited<RB>>,\n  ) {\n    return this.mappings.blockMapping[block.type](\n      block,\n      this,\n      nestingLevel,\n      numberedListIndex,\n      children,\n    );\n  }\n}\n","import { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchema,\n  InlineContentFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n  Styles,\n} from \"../schema/index.js\";\nimport type { Exporter } from \"./Exporter.js\";\n\n/**\n * Defines a mapping from all block types with a schema to a result type `R`.\n */\nexport type BlockMapping<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RB,\n  RI,\n> = {\n  [K in keyof B]: (\n    block: BlockFromConfigNoChildren<B[K], I, S>,\n    // we don't know the exact types that are supported by the exporter at this point,\n    // because the mapping only knows about converting certain types (which might be a subset of the supported types)\n    // this is why there are many `any` types here (same for types below)\n    exporter: Exporter<any, any, any, RB, RI, any, any>,\n    nestingLevel: number,\n    numberedListIndex?: number,\n    children?: Array<Awaited<RB>>,\n  ) => RB | Promise<RB>;\n};\n\n/**\n * Defines a mapping from all inline content types with a schema to a result type R.\n */\nexport type InlineContentMapping<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RI,\n  TS,\n> = {\n  [K in keyof I]: (\n    inlineContent: InlineContentFromConfig<I[K], S>,\n    exporter: Exporter<any, I, S, any, RI, any, TS>,\n  ) => RI;\n};\n\n/**\n * Defines a mapping from all style types with a schema to a result type R.\n */\nexport type StyleMapping<S extends StyleSchema, RS> = {\n  [K in keyof S]: (\n    style: Styles<S>[K],\n    exporter: Exporter<any, any, any, any, any, RS, any>,\n  ) => RS;\n};\n\n/**\n * The mapping factory is a utility function to easily create mappings for\n * a BlockNoteSchema. Using the factory makes it easier to get typescript code completion etc.\n */\nexport function mappingFactory<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(_schema: BlockNoteSchema<B, I, S>) {\n  return {\n    createBlockMapping: <R, RI>(mapping: BlockMapping<B, I, S, R, RI>) =>\n      mapping,\n    createInlineContentMapping: <R, RS>(\n      mapping: InlineContentMapping<I, S, R, RS>,\n    ) => mapping,\n    createStyleMapping: <R>(mapping: StyleMapping<S, R>) => mapping,\n  };\n}\n","/**\n * Combines items by group. This can be used to combine multiple slash menu item arrays,\n * while making sure that items from the same group are adjacent to each other.\n */\nexport function combineByGroup<T extends { group?: string }>(\n  items: T[],\n  ...additionalItemsArray: {\n    group?: string;\n  }[][]\n) {\n  const combinedItems = [...items];\n  for (const additionalItems of additionalItemsArray) {\n    for (const additionalItem of additionalItems) {\n      const lastItemWithSameGroup = combinedItems.findLastIndex(\n        (item) => item.group === additionalItem.group,\n      );\n      if (lastItemWithSameGroup === -1) {\n        combinedItems.push(additionalItem as T);\n      } else {\n        combinedItems.splice(lastItemWithSameGroup + 1, 0, additionalItem as T);\n      }\n    }\n  }\n  return combinedItems;\n}\n"],"names":["getInlineContentParseRules","config","customParseFunction","rules","element","htmlElement","node","props","createInlineContentSpec","inlineContentConfig","inlineContentImplementation","Node","_a","propsToAttributes","addInlineContentKeyboardShortcuts","editor","output","nodeToCustomInlineContent","addInlineContentAttributes","getPos","update","content","inlineContentToNodes","pos","tr","createInlineContentSpecFromTipTapNode","inlineContent","updateInlineContent","insertBlocks","blocksToInsert","referenceBlock","placement","id","pmSchema","getPmSchema","nodesToInsert","block","blockToNode","posInfo","getNodeById","ReplaceStep","Slice","Fragment","nodeToBlock","isEmptyColumn","column","blockContainer","blockContent","removeEmptyColumns","columnListPos","$columnListPos","columnList","columnIndex","columnPos","fixColumnList","firstColumnBeforePos","firstColumn","lastColumnAfterPos","lastColumn","firstColumnEmpty","lastColumnEmpty","ReplaceAroundStep","removeAndInsertBlocks","blocksToRemove","idsOfBlocksToRemove","removedBlocks","columnListPositions","idOfFirstBlock","removedSize","oldDocSize","newDocSize","$pos","notFoundIds","serializeInlineContentInternalHTML","serializer","blockType","options","nodes","tableContentToNodes","UnreachableCaseError","fragment","contentFragment","dom","mark","newDom","domOutputSpec","DOMSerializer","nodeFragment","serializeBlock","BC_NODE","name","spec","children","ret","ic","serializeBlocks","bc","_c","_b","_d","_e","serializeBlocksInternalHTML","blocks","blockDOM","BG_NODE","bg","createInternalHTMLSerializer","schema","getBlockSelectionData","anchorBlockPosInfo","getNearestBlockPos","CellSelection","NodeSelection","headBlockPosInfo","updateBlockSelectionFromData","data","anchorBlockPos","selection","headBlockPos","TextSelection","flattenColumns","moveSelectedBlocksAndSelection","selectionData","checkPlacementIsValid","parentBlock","getMoveUpPlacement","prevBlock","referenceBlockParent","getMoveDownPlacement","nextBlock","moveBlocksUp","moveUpPlacement","moveBlocksDown","moveDownPlacement","sinkListItem","itemType","groupType","$from","$to","range","startIndex","nodeBefore","nestedBefore","inner","slice","before","after","nestBlock","unnestBlock","canNestBlock","getBlockInfoFromTransaction","canUnnestBlock","getBlock","doc","blockIdentifier","getPrevBlock","nodeToConvert","getNextBlock","getParentBlock","$posBeforeNode","parentNode","grandparentNode","BlockManager","docToBlocks","callback","reverse","traverseBlockArray","blockArray","blockToUpdate","updateBlock","EventManager","EventEmitter","transaction","appendedTransactions","includeUpdatesFromRemote","cb","isRemoteTransaction","getBlocksChangedByTransaction","includeSelectionChangedByRemote","e","getChildIndex","isWhitespaceNode","liftNestedListsToParent","list","index","parentListItem","siblingsAfter","sibling","siblingContainer","createGroups","listItem","blockGroup","_detachedDoc","detachedDoc","nestedListsToBlockNoteStructure","elementOrHTML","HTMLToBlocks","html","htmlNode","DOMParser","code","state","value","properties","result","video","url","title","markdownToHTML","markdown","unified","remarkParse","remarkGfm","remarkRehype","remarkRehypeDefaultHandlers","isVideoUrl","rehypeStringify","markdownToBlocks","htmlString","ExportManager","createExternalHTMLExporter","blocksToMarkdown","raw","htmlToPaste","text","acceptedMIMETypes","checkFileExtensionsMatch","fileExtension1","fileExtension2","checkMIMETypesMatch","mimeType1","mimeType2","types1","types2","insertOrUpdateBlock","newBlock","insertedBlockId","handleFileInsertion","event","dataTransfer","format","mimeType","items","fileBlockType","blockSpec","isFileExtension","file","fileBlock","currentBlock","coords","blockElement","blockRect","updateData","updatedFileBlock","createDropFileExtension","Extension","Plugin","_view","h1","bold","link","ul","ol","hr","fences","blockquote","tableHeader","tableDivider","tableRow","isMarkdown","src","handleVSCodePaste","view","vscode","vscodeData","language","defaultPasteHandler","prioritizeMarkdownOverHTML","plainTextAsMarkdown","plainText","createPasteFromClipboardExtension","pasteHandler","fragmentToExternalHTML","selectedFragment","isWithinBlockContent","isWithinTable","fragmentWithoutParents","i","child","externalHTML","externalHTMLExporter","contentNodeToTableContent","contentNodeToInlineContent","fragmentToBlocks","selectedFragmentToHTML","clipboardHTML","cleanHTMLToMarkdown","checkIfSelectionInNonEditableBlock","copyToClipboard","createCopyToClipboardExtension","BackgroundColorExtension","getBackgroundColorAttribute","HardBreak","HTMLAttributes","mergeAttributes","getPrevBlockInfo","beforePos","indexInParent","prevBlockBeforePos","getBlockInfoFromResolvedPos","getBottomNestedBlockInfo","blockInfo","group","newPos","canMerge","prevBlockInfo","nextBlockInfo","mergeBlocks","dispatch","childBlocksStart","childBlocksEnd","childBlocksRange","mergeBlocksCommand","posBetweenBlocks","bottomNestedBlockInfo","KeyboardShortcutsExtension","handleBackspace","chain","commands","getBlockInfoFromSelection","selectionAtBlockStart","isParagraph","updateBlockCommand","selectionEmpty","$blockPos","$columnPos","chainedCommands","lastCellParagraphEndPos","nonEditableBlockContentStartPos","blockContentStartPos","bottomBlock","handleDelete","childContainer","depth","blockAtDocEnd","selectionAtBlockEnd","oldDepth","newDepth","handleEnter","withShift","blockEmpty","blockIndented","blockHardBreakShortcut","marks","m","newBlockInsertionPos","newBlockContentPos","splitBlockCommand","FormattingToolbarExtension","FilePanelExtension","SuggestionAddMark","Mark","extension","inline","SuggestionDeleteMark","SuggestionModificationMark","TextAlignmentExtension","attributes","TextColorExtension","getTextColorAttribute","BlockAttributes","BlockContainer","attrs","nodeAttr","HTMLAttr","blockOuter","attribute","blockHTMLAttributes","mergeCSSClasses","BlockGroup","blockGroupHTMLAttributes","Doc","CollaborationExtension","createExtension","ForkYDocExtension","YCursorExtension","YSyncExtension","YUndoExtension","SchemaMigration","LINKIFY_INITIALIZED","getDefaultTiptapExtensions","tiptapExtensions","extensions","Gapcursor","UniqueID","Text","Link","DEFAULT_LINK_PROTOCOL","VALID_LINK_PROTOCOLS","styleSpec","TiptapExtension","SuggestionMenu","a","inlineContentSpec","context","getDefaultExtensions","BlockChangeExtension","DropCursorExtension","LinkToolbarExtension","NodeSelectionKeyboardExtension","PlaceholderExtension","ShowSelectionExtension","SideMenuExtension","TrailingNodeExtension","HistoryExtension","TableHandlesExtension","PreviousBlockTypeExtension","ExtensionManager","__publicField","abortController","unmountCallback","registeredExtensions","pluginsToAdd","plugin","plugins","instance","originalFactory","originalFactorySymbol","toResolve","toUnregister","didWarn","pluginsToRemove","factory","currentState","getPriority","sortByDependencies","inputRulesByPriority","priority","prosemirrorPlugins","inputRules","inputRulesPlugin","inputRule","InputRule","match","start","end","replaceWith","cursorPosition","updateBlockTr","keymap","key","expandPMRangeToWords","charAfterStart","wordMatch","charBeforeEnd","getSelection","$startBlockBeforePos","$endBlockBeforePos","indexToBlock","sharedDepth","endIndex","startIndexAtDepth","childCountAtDepth","setSelection","startBlock","endBlock","startBlockId","endBlockId","getBlockNoteSchema","anchorPosInfo","headPosInfo","anchorBlockInfo","getBlockInfo","headBlockInfo","anchorBlockConfig","headBlockConfig","startPos","endPos","tableMap","TableMap","lastCellPos","lastCellNodeSize","getSelectionCutBlocks","expandToWords","selectionInfo","prosemirrorSliceToSlicedBlocks","getTextCursorPosition","bnBlock","resolvedPos","prevNode","nextNode","setTextCursorPosition","targetBlock","info","contentType","SelectionManager","ranges","from","to","isNodeSelection","posToDOMRect","StateManager","command","activeTr","editable","undoPlugin","historyPlugin","insertContentAt","position","isOnlyTextContent","isOnlyBlockContent","parent","selectionToInsertionEnd","StyleManager","updateSelection","styles","style","removeChild","n","_","wrapTableRows","f","newItems","prevTable","newTable","transformPasted","shouldApplyFix","nestedChild","container","nodeHasSingleChild","nodeHasInlineContent","nodeHasTableContent","blockNoteTipTapOptions","BlockNoteEditor","args","en","newOptions","BlockNoteSchema","uploadFile","blockId","collaborationEnabled","tiptapOptions","_g","_f","_h","_j","_i","initialContent","getSchema","pmNodes","b","createDocument","TiptapEditor","cache","oldCreateAndFill","jsonNode","Exporter","_schema","mappings","inlineContentArray","nestingLevel","numberedListIndex","mappingFactory","mapping","combineByGroup","additionalItemsArray","combinedItems","additionalItems","additionalItem","lastItemWithSameGroup","item"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuFO,SAASA,GACdC,GACAC,GACA;AACA,QAAMC,IAAwB;AAAA,IAC5B;AAAA,MACE,KAAK,8BAA8BF,EAAO,IAAI;AAAA,MAC9C,gBAAgB,CAACG,MAAY;AAC3B,cAAMC,IAAcD;AAEpB,eAAIC,EAAY,QAAQ,iBAAiB,IAChCA,IAGFA,EAAY,cAAc,iBAAiB,KAAKA;AAAA,MACzD;AAAA,IAAA;AAAA,EACF;AAGF,SAAIH,KACFC,EAAM,KAAK;AAAA,IACT,KAAK;AAAA,IACL,SAASG,GAA4B;AACnC,UAAI,OAAOA,KAAS;AAClB,eAAO;AAGT,YAAMC,IAAQL,KAAA,gBAAAA,EAAsBI;AAEpC,aAAIC,MAAU,SACL,KAGFA;AAAA,IACT;AAAA,EAAA,CACD,GAEIJ;AACT;AAEO,SAASK,GAIdC,GACAC,GACsB;;AACtB,QAAMJ,IAAOK,EAAK,OAAO;AAAA,IACvB,MAAMF,EAAoB;AAAA,IAC1B,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,YAAWG,IAAAF,EAA4B,SAA5B,gBAAAE,EAAkC;AAAA,IAC7C,YAAYH,EAAoB,YAAY;AAAA,IAC5C,MAAMA,EAAoB,YAAY;AAAA,IACtC,SAASA,EAAoB,YAAY,WAAW,YAAY;AAAA,IAEhE,gBAAgB;AACd,aAAOI,GAAkBJ,EAAoB,UAAU;AAAA,IACzD;AAAA,IAEA,uBAAuB;AACrB,aAAOK,GAAkCL,CAAmB;AAAA,IAC9D;AAAA,IAEA,YAAY;AACV,aAAOT;AAAA,QACLS;AAAA,QACAC,EAA4B;AAAA,MAAA;AAAA,IAEhC;AAAA,IAEA,WAAW,EAAE,MAAAJ,KAAQ;AACnB,YAAMS,IAAS,KAAK,QAAQ,QAEtBC,IAASN,EAA4B,OAAO;AAAA,QAChD,EAAE,YAAY,OAAO,OAAO,OAAA;AAAA,QAC5BO;AAAA,UACEX;AAAAA,UACAS,EAAO,OAAO;AAAA,UACdA,EAAO,OAAO;AAAA,QAAA;AAAA;AAAA,QAEhB,MAAM;AAAA,QAEN;AAAA,QACAA;AAAA,MAAA;AAGF,aAAOG;AAAA,QACLF;AAAA,QACAP,EAAoB;AAAA,QACpBH,EAAK;AAAA,QACLG,EAAoB;AAAA,MAAA;AAAA,IAExB;AAAA,IAEA,cAAc;AACZ,aAAO,CAACF,MAAU;AAChB,cAAM,EAAE,MAAAD,GAAM,QAAAa,EAAA,IAAWZ,GACnBQ,IAAS,KAAK,QAAQ,QAEtBC,IAASN,EAA4B,OAAO;AAAA,UAChD,EAAE,YAAY,YAAY,OAAAH,EAAA;AAAA,UAC1BU;AAAA,YACEX;AAAAA,YACAS,EAAO,OAAO;AAAA,YACdA,EAAO,OAAO;AAAA,UAAA;AAAA;AAAA,UAEhB,CAACK,MAAW;AACV,kBAAMC,IAAUC,EAAqB,CAACF,CAAM,GAAGL,EAAO,QAAQ,GAExDQ,IAAMJ,EAAA;AAEZ,YAAKI,KAILR,EAAO;AAAA,cAAS,CAACS,MACfA,EAAG,YAAYD,GAAKA,IAAMjB,EAAK,UAAUe,CAAO;AAAA,YAAA;AAAA,UAEpD;AAAA,UACAN;AAAA,QAAA;AAGF,eAAOG;AAAA,UACLF;AAAA,UACAP,EAAoB;AAAA,UACpBH,EAAK;AAAA,UACLG,EAAoB;AAAA,QAAA;AAAA,MAExB;AAAA,IACF;AAAA,EAAA,CACD;AAED,SAAOgB;AAAA,IACLnB;AAAA,IACAG,EAAoB;AAAA,IACpB;AAAA,MACE,GAAGC;AAAA,MACH,gBAAgBA,EAA4B;AAAA,MAC5C,OAAOgB,GAAeC,GAAqBZ,GAAQ;AACjD,cAAMC,IAASN,EAA4B;AAAA,UACzCgB;AAAA,UACAC;AAAA,UACAZ;AAAA,QAAA;AAGF,eAAOG;AAAA,UACLF;AAAA,UACAP,EAAoB;AAAA,UACpBiB,EAAc;AAAA,UACdjB,EAAoB;AAAA,QAAA;AAAA,MAExB;AAAA,IAAA;AAAA,EACF;AAEJ;ACnOO,SAASmB,GAKdJ,GACAK,GACAC,GACAC,IAAgC,UACR;AACxB,QAAMC,IACJ,OAAOF,KAAmB,WAAWA,IAAiBA,EAAe,IACjEG,IAAWC,EAAYV,CAAE,GACzBW,IAAgBN,EAAe;AAAA,IAAI,CAACO,MACxCC,EAAYD,GAAOH,CAAQ;AAAA,EAAA,GAGvBK,IAAUC,EAAYP,GAAIR,EAAG,GAAG;AACtC,MAAI,CAACc;AACH,UAAM,IAAI,MAAM,iBAAiBN,CAAE,YAAY;AAGjD,MAAIT,IAAMe,EAAQ;AAClB,SAAIP,MAAc,YAChBR,KAAOe,EAAQ,KAAK,WAGtBd,EAAG;AAAA,IACD,IAAIgB,GAAYjB,GAAKA,GAAK,IAAIkB,EAAMC,EAAS,KAAKP,CAAa,GAAG,GAAG,CAAC,CAAC;AAAA,EAAA,GAKlDA,EAAc;AAAA,IAAI,CAAC7B,MACxCqC,EAAYrC,GAAM2B,CAAQ;AAAA,EAAA;AAI9B;AC3CO,SAASW,EAAcC,GAAc;AAC1C,MAAI,CAACA,KAAUA,EAAO,KAAK,SAAS;AAClC,UAAM,IAAI,MAAM,mDAAmD;AAGrE,QAAMC,IAAiBD,EAAO;AAC9B,MAAI,CAACC;AACH,UAAM,IAAI,MAAM,2CAA2C;AAG7D,QAAMC,IAAeD,EAAe;AACpC,MAAI,CAACC;AACH,UAAM,IAAI,MAAM,mDAAmD;AAGrE,SACEF,EAAO,eAAe,KACtBC,EAAe,eAAe,KAC9BC,EAAa,KAAK,SAAS,eAC3BA,EAAa,QAAQ,QAAQ,WAAW;AAE5C;AAUO,SAASC,GAAmBxB,GAAiByB,GAAuB;AACzE,QAAMC,IAAiB1B,EAAG,IAAI,QAAQyB,CAAa,GAC7CE,IAAaD,EAAe;AAClC,MAAI,CAACC,KAAcA,EAAW,KAAK,SAAS;AAC1C,UAAM,IAAI;AAAA,MACR;AAAA,IAAA;AAIJ,WACMC,IAAcD,EAAW,aAAa,GAC1CC,KAAe,GACfA,KACA;AACA,UAAMC,IAAY7B,EAAG,IAClB,QAAQ0B,EAAe,MAAM,CAAC,EAC9B,WAAWE,CAAW,GAEnBP,IADarB,EAAG,IAAI,QAAQ6B,CAAS,EACjB;AAC1B,QAAI,CAACR,KAAUA,EAAO,KAAK,SAAS;AAClC,YAAM,IAAI,MAAM,mDAAmD;AAGrE,IAAID,EAAcC,CAAM,KACtBrB,EAAG,OAAO6B,GAAWA,IAAYR,EAAO,QAAQ;AAAA,EAEpD;AACF;AAeO,SAASS,EAAc9B,GAAiByB,GAAuB;AACpE,EAAAD,GAAmBxB,GAAIyB,CAAa;AAGpC,QAAME,IADiB3B,EAAG,IAAI,QAAQyB,CAAa,EACjB;AAClC,MAAI,CAACE,KAAcA,EAAW,KAAK,SAAS;AAC1C,UAAM,IAAI;AAAA,MACR;AAAA,IAAA;AAIJ,MAAIA,EAAW,aAAa;AAO1B;AAGF,MAAIA,EAAW,aAAa;AAM1B,UAAM,IAAI,MAAM,uDAAuD;AAGzE,QAAMI,IAAuBN,IAAgB,GAEvCO,IADwBhC,EAAG,IAAI,QAAQ+B,CAAoB,EACvB,WAEpCE,IAAqBR,IAAgBE,EAAW,WAAW,GAE3DO,IADsBlC,EAAG,IAAI,QAAQiC,CAAkB,EACtB;AAEvC,MAAI,CAACD,KAAe,CAACE;AACnB,UAAM,IAAI,MAAM,gDAAgD;AAGlE,QAAMC,IAAmBf,EAAcY,CAAW,GAC5CI,IAAkBhB,EAAcc,CAAU;AAEhD,MAAIC,KAAoBC,GAAiB;AAEvC,IAAApC,EAAG,OAAOyB,GAAeA,IAAgBE,EAAW,QAAQ;AAE5D;AAAA,EACF;AAEA,MAAIQ,GAAkB;AACpB,IAAAnC,EAAG;AAAA,MACD,IAAIqC;AAAA;AAAA,QAEFZ;AAAA,QACAA,IAAgBE,EAAW;AAAA;AAAA,QAE3BM,IAAqBC,EAAW,WAAW;AAAA,QAC3CD,IAAqB;AAAA;AAAA,QAErBhB,EAAM;AAAA,QACN;AAAA,QACA;AAAA,MAAA;AAAA,IACF;AAGF;AAAA,EACF;AAEA,MAAImB,GAAiB;AACnB,IAAApC,EAAG;AAAA,MACD,IAAIqC;AAAA;AAAA,QAEFZ;AAAA,QACAA,IAAgBE,EAAW;AAAA;AAAA,QAE3BI,IAAuB;AAAA,QACvBA,IAAuBC,EAAY,WAAW;AAAA;AAAA,QAE9Cf,EAAM;AAAA,QACN;AAAA,QACA;AAAA,MAAA;AAAA,IACF;AAGF;AAAA,EACF;AACF;AC9JO,SAASqB,GAKdtC,GACAuC,GACAlC,GAIA;AACA,QAAMI,IAAWC,EAAYV,CAAE,GAGzBW,IAAwBN,EAAe;AAAA,IAAI,CAACO,MAChDC,EAAYD,GAAOH,CAAQ;AAAA,EAAA,GAGvB+B,IAAsB,IAAI;AAAA,IAC9BD,EAAe;AAAA,MAAI,CAAC3B,MAClB,OAAOA,KAAU,WAAWA,IAAQA,EAAM;AAAA,IAAA;AAAA,EAC5C,GAEI6B,IAAwC,CAAA,GACxCC,wBAA0B,IAAA,GAE1BC,IACJ,OAAOJ,EAAe,CAAC,KAAM,WACzBA,EAAe,CAAC,IAChBA,EAAe,CAAC,EAAE;AACxB,MAAIK,IAAc;AA0DlB,MAxDA5C,EAAG,IAAI,YAAY,CAAClB,GAAMiB,MAAQ;AAEhC,QAAIyC,EAAoB,SAAS;AAC/B,aAAO;AAIT,QACE,CAAC1D,EAAK,KAAK,UAAU,SAAS,KAC9B,CAAC0D,EAAoB,IAAI1D,EAAK,MAAM,EAAE;AAEtC,aAAO;AAOT,QAHA2D,EAAc,KAAKtB,EAAYrC,GAAM2B,CAAQ,CAAC,GAC9C+B,EAAoB,OAAO1D,EAAK,MAAM,EAAE,GAEpCuB,EAAe,SAAS,KAAKvB,EAAK,MAAM,OAAO6D,GAAgB;AACjE,YAAME,IAAa7C,EAAG,IAAI;AAC1B,MAAAA,EAAG,OAAOD,GAAKY,CAAa;AAC5B,YAAMmC,IAAa9C,EAAG,IAAI;AAE1B,MAAA4C,KAAeC,IAAaC;AAAAA,IAC9B;AAEA,UAAMD,IAAa7C,EAAG,IAAI,UAEpB+C,IAAO/C,EAAG,IAAI,QAAQD,IAAM6C,CAAW;AAE7C,IAAIG,EAAK,KAAA,EAAO,KAAK,SAAS,WAC5BL,EAAoB,IAAIK,EAAK,OAAO,EAAE,CAAC,IAC9BA,EAAK,KAAA,EAAO,KAAK,SAAS,gBACnCL,EAAoB,IAAIK,EAAK,QAAQ,GAIrCA,EAAK,KAAA,EAAO,KAAK,SAAS,gBAC1BA,EAAK,KAAKA,EAAK,QAAQ,CAAC,EAAE,KAAK,SAAS,SACxCA,EAAK,KAAA,EAAO,eAAe,IAK3B/C,EAAG,OAAO+C,EAAK,OAAA,GAAUA,EAAK,OAAO,IAErC/C,EAAG,OAAOD,IAAM6C,GAAa7C,IAAM6C,IAAc9D,EAAK,QAAQ;AAGhE,UAAMgE,IAAa9C,EAAG,IAAI;AAC1B,WAAA4C,KAAeC,IAAaC,GAErB;AAAA,EACT,CAAC,GAGGN,EAAoB,OAAO,GAAG;AAChC,UAAMQ,IAAc,CAAC,GAAGR,CAAmB,EAAE,KAAK;AAAA,CAAI;AAEtD,UAAM;AAAA,MACJ,qEACEQ;AAAA,IAAA;AAAA,EAEN;AAEA,SAAAN,EAAoB,QAAQ,CAAC3C,MAAQ+B,EAAc9B,GAAID,CAAG,CAAC,GAOpD,EAAE,gBAJcY,EAAc;AAAA,IAAI,CAAC7B,MACxCqC,EAAYrC,GAAM2B,CAAQ;AAAA,EAAA,GAGH,eAAAgC,EAAA;AAC3B;ACxGO,SAASQ,GAKd1D,GACAgC,GACA2B,GACAC,GACAC,GACA;AACA,MAAIC;AAGJ,MAAK9B;AAEL,QAAW,OAAOA,KAAiB;AACjC,MAAA8B,IAAQvD,EAAqB,CAACyB,CAAY,GAAGhC,EAAO,UAAU4D,CAAS;AAAA,aAC9D,MAAM,QAAQ5B,CAAY;AACnC,MAAA8B,IAAQvD,EAAqByB,GAAchC,EAAO,UAAU4D,CAAS;AAAA,aAC5D5B,EAAa,SAAS;AAC/B,MAAA8B,IAAQC,GAAoB/B,GAAchC,EAAO,QAAQ;AAAA;AAEzD,YAAM,IAAIgE,EAAqBhC,EAAa,IAAI;AAAA,MARhD,OAAM,IAAI,MAAM,0BAA0B;AAa5C,QAAMiC,MADMJ,KAAA,gBAAAA,EAAS,aAAY,UACZ,uBAAA;AAErB,aAAWtE,KAAQuE;AAEjB,QACEvE,EAAK,KAAK,SAAS,UACnBS,EAAO,OAAO,oBAAoBT,EAAK,KAAK,IAAI,GAChD;AACA,YAAMI,IACJK,EAAO,OAAO,mBAAmBT,EAAK,KAAK,IAAI,EAAE;AAEnD,UAAII,GAA6B;AAE/B,cAAMgB,IAAgBT;AAAA,UACpBX;AAAA,UACAS,EAAO,OAAO;AAAA,UACdA,EAAO,OAAO;AAAA,QAAA,GAIVC,IAASN,EAA4B,OAAO;AAAA,UAChD;AAAA,YACE,YAAY;AAAA,YACZ,OAAO;AAAA,UAAA;AAAA,UAETgB;AAAA,UACA,MAAM;AAAA,UAEN;AAAA,UACAX;AAAA,QAAA;AAGF,YAAIC,GAAQ;AAIV,cAHAgE,EAAS,YAAYhE,EAAO,GAAG,GAG3BA,EAAO,YAAY;AACrB,kBAAMiE,IAAkBP,EAAW;AAAA,cACjCpE,EAAK;AAAA,cACLsE;AAAA,YAAA;AAEF,YAAA5D,EAAO,WAAW,QAAQ,WAAW,IACrCA,EAAO,WAAW,YAAYiE,CAAe;AAAA,UAC/C;AACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,WAAW3E,EAAK,KAAK,SAAS,QAAQ;AAIpC,UAAI4E,IAA8B,SAAS;AAAA,QACzC5E,EAAK;AAAA,MAAA;AAGP,iBAAW6E,KAAQ7E,EAAK,MAAM,WAAA;AAC5B,YAAI6E,EAAK,KAAK,QAAQpE,EAAO,OAAO,YAAY;AAC9C,gBAAMqE,IAASrE,EAAO,OAAO,WAC3BoE,EAAK,KAAK,IACZ,EAAE,eAAe,OAAOA,EAAK,MAAM,aAAgBpE,CAAM;AACzD,UAAAqE,EAAO,WAAY,YAAYF,CAAG,GAClCA,IAAME,EAAO;AAAA,QACf,OAAO;AACL,gBAAMC,IAAgBF,EAAK,KAAK,KAAK,MAAOA,GAAM,EAAI,GAChDC,IAASE,GAAc,WAAW,UAAUD,CAAa;AAC/D,UAAAD,EAAO,WAAY,YAAYF,CAAG,GAClCA,IAAME,EAAO;AAAA,QACf;AAGF,MAAAJ,EAAS,YAAYE,CAAG;AAAA,IAC1B,OAAO;AAEL,YAAMK,IAAeb,EAAW;AAAA,QAC9BhC,EAAS,KAAK,CAACpC,CAAI,CAAC;AAAA,QACpBsE;AAAA,MAAA;AAEF,MAAAI,EAAS,YAAYO,CAAY;AAAA,IACnC;AAGF,SAAOP;AACT;AAEA,SAASQ,GAKPzE,GACAqB,GACAsC,GACAE,GACA;;AACA,QAAMa,IAAU1E,EAAO,SAAS,MAAM,gBAGhCR,IAAQ6B,EAAM,SAAS,CAAA;AAC7B,aAAW,CAACsD,GAAMC,CAAI,KAAK,OAAO;AAAA,IAChC5E,EAAO,OAAO,YAAYqB,EAAM,IAAW,EAAE;AAAA,EAAA;AAE7C,IAAI,EAAEsD,KAAQnF,MAAUoF,EAAK,YAAY,WACtCpF,EAAcmF,CAAI,IAAIC,EAAK;AAGhC,QAAMC,IAAWxD,EAAM,YAAY,CAAA,GAG7ByD,IADO9E,EAAO,qBAAqBqB,EAAM,IAAW,EAAE,eAC3C,OAAO;AAAA,IACtB;AAAA,MACE,YAAY;AAAA,MACZ,OAAO;AAAA,IAAA;AAAA,IAET,EAAE,GAAGA,GAAO,OAAA7B,GAAO,UAAAqF,EAAA;AAAA,IACnB7E;AAAA,EAAA;AAGF,MAAI8E,EAAI,cAAczD,EAAM,SAAS;AACnC,UAAM0D,IAAKrB;AAAA,MACT1D;AAAA,MACAqB,EAAM;AAAA;AAAA,MACNsC;AAAA,MACAtC,EAAM;AAAA,MACNwC;AAAA,IAAA;AAEF,IAAAiB,EAAI,WAAW,YAAYC,CAAE;AAAA,EAC/B;AAIA,MAFe/E,EAAO,SAAS,MAAMqB,EAAM,IAAW,EAE3C,UAAU,SAAS,GAAG;AAC/B,QAAIA,EAAM,YAAYA,EAAM,SAAS,SAAS,GAAG;AAC/C,YAAM4C,IAAWe;AAAA,QACfhF;AAAA,QACAqB,EAAM;AAAA,QACNsC;AAAA,QACAE;AAAA,MAAA;AAGF,OAAAhE,IAAAiF,EAAI,eAAJ,QAAAjF,EAAgB,OAAOoE;AAAA,IACzB;AACA,WAAOa,EAAI;AAAA,EACb;AAGA,QAAMG,KAAKC,KAAAC,IAAAT,EAAQ,SAAR,gBAAAS,EAAc,UAAd,gBAAAD,EAAA;AAAA,IAAAC;AAAA,IACTT,EAAQ,OAAO;AAAA,MACb,IAAIrD,EAAM;AAAA,MACV,GAAG7B;AAAA,IAAA,CACJ;AAAA;AAMH,UAAA4F,IAAAH,EAAG,eAAH,QAAAG,EAAe,YAAYN,EAAI,MAE3BzD,EAAM,YAAYA,EAAM,SAAS,SAAS,OAC5CgE,IAAAJ,EAAG,eAAH,QAAAI,EAAe;AAAA,IACbC,GAA4BtF,GAAQqB,EAAM,UAAUsC,GAAYE,CAAO;AAAA,MAGpEoB,EAAG;AACZ;AAEA,SAASD,GAKPhF,GACAuF,GACA5B,GACAE,GACA;AAEA,QAAMI,MADMJ,KAAA,gBAAAA,EAAS,aAAY,UACZ,uBAAA;AAErB,aAAWxC,KAASkE,GAAQ;AAC1B,UAAMC,IAAWf,GAAezE,GAAQqB,GAAOsC,GAAYE,CAAO;AAClE,IAAAI,EAAS,YAAYuB,CAAQ;AAAA,EAC/B;AAEA,SAAOvB;AACT;AAEO,MAAMqB,KAA8B,CAKzCtF,GACAuF,GACA5B,GACAE,MACG;;AACH,QAAM4B,IAAUzF,EAAO,SAAS,MAAM,YAEhC0F,IAAKD,EAAQ,KAAM,MAAOA,EAAQ,OAAO,CAAA,CAAE,CAAC,GAK5CxB,IAAWe,GAAgBhF,GAAQuF,GAAQ5B,GAAYE,CAAO;AAEpE,UAAAhE,IAAA6F,EAAG,eAAH,QAAA7F,EAAe,YAAYoE,IAEpByB,EAAG;AACZ,GC1OaC,KAA+B,CAK1CC,GACA5F,MACG;AACH,QAAM2D,IAAaY,GAAc,WAAWqB,CAAM;AAElD,SAAO;AAAA,IACL,iBAAiB,CACfL,GACA1B,MAEOyB,GAA4BtF,GAAQuF,GAAQ5B,GAAYE,CAAO,EACnE;AAAA,EACL;AAEJ;ACKA,SAASgC,GACP7F,GACoB;AACpB,SAAOA,EAAO,SAAS,CAACS,MAAO;AAC7B,UAAMqF,IAAqBC,EAAmBtF,EAAG,KAAKA,EAAG,UAAU,MAAM;AAEzE,QAAIA,EAAG,qBAAqBuF;AAC1B,aAAO;AAAA,QACL,MAAM;AAAA,QACN,eAAeF,EAAmB,KAAK,MAAM;AAAA,QAC7C,kBACErF,EAAG,UAAU,YAAY,MAAMqF,EAAmB;AAAA,QACpD,gBACErF,EAAG,UAAU,UAAU,MAAMqF,EAAmB;AAAA,MAAA;AAEtD,QAAWrF,EAAG,qBAAqBwF;AACjC,aAAO;AAAA,QACL,MAAM;AAAA,QACN,eAAeH,EAAmB,KAAK,MAAM;AAAA,MAAA;AAE1C;AACL,YAAMI,IAAmBH,EAAmBtF,EAAG,KAAKA,EAAG,UAAU,IAAI;AAErE,aAAO;AAAA,QACL,MAAM;AAAA,QACN,eAAeqF,EAAmB,KAAK,MAAM;AAAA,QAC7C,aAAaI,EAAiB,KAAK,MAAM;AAAA,QACzC,cAAczF,EAAG,UAAU,SAASqF,EAAmB;AAAA,QACvD,YAAYrF,EAAG,UAAU,OAAOyF,EAAiB;AAAA,MAAA;AAAA,IAErD;AAAA,EACF,CAAC;AACH;AAaA,SAASC,GACP1F,GACA2F,GACA;;AACA,QAAMC,KAAiBxG,IAAA2B,EAAY4E,EAAK,eAAe3F,EAAG,GAAG,MAAtC,gBAAAZ,EAAyC;AAChE,MAAIwG,MAAmB;AACrB,UAAM,IAAI;AAAA,MACR,gCAAgCD,EAAK,aAAa;AAAA,IAAA;AAItD,MAAIE;AACJ,MAAIF,EAAK,SAAS;AAChB,IAAAE,IAAYN,GAAc;AAAA,MACxBvF,EAAG;AAAA,MACH4F,IAAiBD,EAAK;AAAA,MACtBC,IAAiBD,EAAK;AAAA,IAAA;AAAA,WAEfA,EAAK,SAAS;AACvB,IAAAE,IAAYL,EAAc,OAAOxF,EAAG,KAAK4F,IAAiB,CAAC;AAAA,OACtD;AACL,UAAME,KAAepB,IAAA3D,EAAY4E,EAAK,aAAa3F,EAAG,GAAG,MAApC,gBAAA0E,EAAuC;AAC5D,QAAIoB,MAAiB;AACnB,YAAM,IAAI;AAAA,QACR,gCAAgCH,EAAK,WAAW;AAAA,MAAA;AAIpD,IAAAE,IAAYE,EAAc;AAAA,MACxB/F,EAAG;AAAA,MACH4F,IAAiBD,EAAK;AAAA,MACtBG,IAAeH,EAAK;AAAA,IAAA;AAAA,EAExB;AAEA,EAAA3F,EAAG,aAAa6F,CAAS;AAC3B;AAQA,SAASG,EACPlB,GACwB;AACxB,SAAOA,EACJ,IAAI,CAAClE,MACAA,EAAM,SAAS,eACVA,EAAM,SACV,IAAI,CAACS,MAAW2E,EAAe3E,EAAO,QAAQ,CAAC,EAC/C,KAAA,IAGE;AAAA,IACL,GAAGT;AAAA,IACH,UAAUoF,EAAepF,EAAM,QAAQ;AAAA,EAAA,CAE1C,EACA,KAAA;AACL;AAYO,SAASqF,GACd1G,GACAe,GACAC,GACA;AAEA,EAAAhB,EAAO,SAAS,CAACS,MAAO;;AACtB,UAAM8E,MAAS1F,IAAAG,EAAO,aAAA,MAAP,gBAAAH,EAAuB,WAAU;AAAA,MAC9CG,EAAO,wBAAwB;AAAA,IAAA,GAE3B2G,IAAgBd,GAAsB7F,CAAM;AAElD,IAAAA,EAAO,aAAauF,CAAM,GAC1BvF,EAAO,aAAayG,EAAelB,CAAM,GAAGxE,GAAgBC,CAAS,GAErEmF,GAA6B1F,GAAIkG,CAAa;AAAA,EAChD,CAAC;AACH;AAMA,SAASC,GAAsBC,GAA6C;AAC1E,SAAO,CAACA,KAAeA,EAAY,SAAS;AAC9C;AAYA,SAASC,GACP9G,GACA+G,GACAF,GAGY;AACZ,MAAI9F,GACAC;AAgBJ,MAdK+F,IAKMA,EAAU,SAAS,SAAS,KACrChG,IAAiBgG,EAAU,SAASA,EAAU,SAAS,SAAS,CAAC,GACjE/F,IAAY,YAEZD,IAAiBgG,GACjB/F,IAAY,YATR6F,MACF9F,IAAiB8F,GACjB7F,IAAY,WAWZ,CAACD,KAAkB,CAACC;AACtB;AAGF,QAAMgG,IAAuBhH,EAAO,eAAee,CAAc;AACjE,SAAK6F,GAAsBI,CAAoB,IAUxC,EAAE,gBAAAjG,GAAgB,WAAAC,EAAA,IAThB8F;AAAA,IACL9G;AAAA,IACAgB,MAAc,UACVD,IACAf,EAAO,aAAae,CAAc;AAAA,IACtCiG;AAAA,EAAA;AAKN;AAYA,SAASC,GACPjH,GACAkH,GACAL,GAGY;AACZ,MAAI9F,GACAC;AAgBJ,MAdKkG,IAKMA,EAAU,SAAS,SAAS,KACrCnG,IAAiBmG,EAAU,SAAS,CAAC,GACrClG,IAAY,aAEZD,IAAiBmG,GACjBlG,IAAY,WATR6F,MACF9F,IAAiB8F,GACjB7F,IAAY,UAWZ,CAACD,KAAkB,CAACC;AACtB;AAGF,QAAMgG,IAAuBhH,EAAO,eAAee,CAAc;AACjE,SAAK6F,GAAsBI,CAAoB,IAUxC,EAAE,gBAAAjG,GAAgB,WAAAC,EAAA,IAThBiG;AAAA,IACLjH;AAAA,IACAgB,MAAc,WACVD,IACAf,EAAO,aAAae,CAAc;AAAA,IACtCiG;AAAA,EAAA;AAKN;AAEO,SAASG,GAAanH,GAAwC;AACnE,EAAAA,EAAO,SAAS,MAAM;AACpB,UAAMsG,IAAYtG,EAAO,aAAA,GACnBqB,KAAQiF,KAAA,gBAAAA,EAAW,OAAO,OAAMtG,EAAO,wBAAwB,OAE/DoH,IAAkBN;AAAA,MACtB9G;AAAA,MACAA,EAAO,aAAaqB,CAAK;AAAA,MACzBrB,EAAO,eAAeqB,CAAK;AAAA,IAAA;AAG7B,IAAK+F,KAILV;AAAA,MACE1G;AAAA,MACAoH,EAAgB;AAAA,MAChBA,EAAgB;AAAA,IAAA;AAAA,EAEpB,CAAC;AACH;AAEO,SAASC,GAAerH,GAAwC;AACrE,EAAAA,EAAO,SAAS,MAAM;AACpB,UAAMsG,IAAYtG,EAAO,aAAA,GACnBqB,KACJiF,KAAA,gBAAAA,EAAW,QAAOA,KAAA,gBAAAA,EAAW,OAAO,UAAS,OAC7CtG,EAAO,sBAAA,EAAwB,OAE3BsH,IAAoBL;AAAA,MACxBjH;AAAA,MACAA,EAAO,aAAaqB,CAAK;AAAA,MACzBrB,EAAO,eAAeqB,CAAK;AAAA,IAAA;AAG7B,IAAKiG,KAILZ;AAAA,MACE1G;AAAA,MACAsH,EAAkB;AAAA,MAClBA,EAAkB;AAAA,IAAA;AAAA,EAEtB,CAAC;AACH;ACpUA,SAASC,GACP9G,GACA+G,GACAC,GACA;AACA,QAAM,EAAE,OAAAC,GAAO,KAAAC,EAAA,IAAQlH,EAAG,WACpBmH,IAAQF,EAAM;AAAA,IAClBC;AAAA,IACA,CAACpI,MACCA,EAAK,aAAa,MACjBA,EAAK,KAAK,SAAS,gBAAgBA,EAAK,KAAK,SAAS;AAAA;AAAA,EAAA;AAE3D,MAAI,CAACqI;AACH,WAAO;AAET,QAAMC,IAAaD,EAAM;AACzB,MAAIC,MAAe;AACjB,WAAO;AAGT,QAAMC,IADSF,EAAM,OACK,MAAMC,IAAa,CAAC;AAC9C,MAAIC,EAAW,SAASN;AACtB,WAAO;AAET,QAAMO,IACJD,EAAW,aAAaA,EAAW,UAAU,SAASL,GAClDO,IAAQrG,EAAS,KAAKoG,IAAeP,EAAS,OAAA,IAAW,IAAI,GAC7DS,IAAQ,IAAIvG;AAAA,IAChBC,EAAS;AAAA,MACP6F,EAAS,OAAO,MAAM7F,EAAS,KAAK8F,EAAU,OAAO,MAAMO,CAAK,CAAC,CAAC;AAAA;AAAA,IAAA;AAAA,IAEpED,IAAe,IAAI;AAAA,IACnB;AAAA,EAAA,GAGIG,IAASN,EAAM,OACfO,IAAQP,EAAM;AAEpB,SAAAnH,EAAG;AAAA,IACD,IAAIqC;AAAA,MACFoF,KAAUH,IAAe,IAAI;AAAA,MAC7BI;AAAA,MACAD;AAAA,MACAC;AAAA,MACAF;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EACF,EACA,eAAA,GAEK;AACT;AAEO,SAASG,GAAUpI,GAAwC;AAChE,SAAOA,EAAO,SAAS,CAACS,MACf8G;AAAA,IACL9G;AAAA,IACAT,EAAO,SAAS,MAAM;AAAA,IACtBA,EAAO,SAAS,MAAM;AAAA,EAAY,CAErC;AACH;AAEO,SAASqI,GAAYrI,GAAwC;AAClE,EAAAA,EAAO,cAAc,SAAS,aAAa,gBAAgB;AAC7D;AAEO,SAASsI,GAAatI,GAAwC;AACnE,SAAOA,EAAO,SAAS,CAACS,MAAO;AAC7B,UAAM,EAAE,SAASsB,MAAmBwG,EAA4B9H,CAAE;AAElE,WAAOA,EAAG,IAAI,QAAQsB,EAAe,SAAS,EAAE,eAAe;AAAA,EACjE,CAAC;AACH;AAEO,SAASyG,GAAexI,GAAwC;AACrE,SAAOA,EAAO,SAAS,CAACS,MAAO;AAC7B,UAAM,EAAE,SAASsB,MAAmBwG,EAA4B9H,CAAE;AAElE,WAAOA,EAAG,IAAI,QAAQsB,EAAe,SAAS,EAAE,QAAQ;AAAA,EAC1D,CAAC;AACH;AClFO,SAAS0G,GAKdC,GACAC,GACkC;AAClC,QAAM1H,IACJ,OAAO0H,KAAoB,WAAWA,IAAkBA,EAAgB,IACpEzH,IAAWC,EAAYuH,CAAG,GAE1BnH,IAAUC,EAAYP,GAAIyH,CAAG;AACnC,MAAKnH;AAIL,WAAOK,EAAYL,EAAQ,MAAML,CAAQ;AAC3C;AAEO,SAAS0H,GAKdF,GACAC,GACkC;AAClC,QAAM1H,IACJ,OAAO0H,KAAoB,WAAWA,IAAkBA,EAAgB,IAEpEpH,IAAUC,EAAYP,GAAIyH,CAAG,GAC7BxH,IAAWC,EAAYuH,CAAG;AAChC,MAAI,CAACnH;AACH;AAIF,QAAMsH,IADiBH,EAAI,QAAQnH,EAAQ,aAAa,EACnB;AACrC,MAAKsH;AAIL,WAAOjH,EAAYiH,GAAe3H,CAAQ;AAC5C;AAEO,SAAS4H,GAKdJ,GACAC,GACkC;AAClC,QAAM1H,IACJ,OAAO0H,KAAoB,WAAWA,IAAkBA,EAAgB,IACpEpH,IAAUC,EAAYP,GAAIyH,CAAG,GAC7BxH,IAAWC,EAAYuH,CAAG;AAChC,MAAI,CAACnH;AACH;AAMF,QAAMsH,IAHgBH,EAAI;AAAA,IACxBnH,EAAQ,gBAAgBA,EAAQ,KAAK;AAAA,EAAA,EAEH;AACpC,MAAKsH;AAIL,WAAOjH,EAAYiH,GAAe3H,CAAQ;AAC5C;AAEO,SAAS6H,GAKdL,GACAC,GACkC;AAClC,QAAM1H,IACJ,OAAO0H,KAAoB,WAAWA,IAAkBA,EAAgB,IACpEzH,IAAWC,EAAYuH,CAAG,GAC1BnH,IAAUC,EAAYP,GAAIyH,CAAG;AACnC,MAAI,CAACnH;AACH;AAGF,QAAMyH,IAAiBN,EAAI,QAAQnH,EAAQ,aAAa,GAClD0H,IAAaD,EAAe,KAAA,GAC5BE,IAAkBF,EAAe,KAAK,EAAE,GACxCH,IACJK,EAAgB,KAAK,SAAS,QAC1BD,EAAW,KAAK,SAAS,eACvBC,IACAD,IACF;AACN,MAAKJ;AAIL,WAAOjH,EAAYiH,GAAe3H,CAAQ;AAC5C;AChFO,MAAMiI,GAIX;AAAA,EACA,YAAoBnJ,GAAoD;AAApD,SAAA,SAAAA;AAAA,EAAqD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzE,IAAW,WAA+C;AACxD,WAAO,KAAK,OAAO,SAAS,CAACS,MACpB2I,GAAY3I,EAAG,KAAK,KAAK,OAAO,QAAQ,CAChD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,SACLkI,GAC8C;AAC9C,WAAO,KAAK,OAAO,SAAS,CAAClI,MAAOgI,GAAShI,EAAG,KAAKkI,CAAe,CAAC;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,aACLA,GAC8C;AAC9C,WAAO,KAAK,OAAO,SAAS,CAAClI,MAAOmI,GAAanI,EAAG,KAAKkI,CAAe,CAAC;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,aACLA,GAC8C;AAC9C,WAAO,KAAK,OAAO,SAAS,CAAClI,MAAOqI,GAAarI,EAAG,KAAKkI,CAAe,CAAC;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,eACLA,GAC8C;AAC9C,WAAO,KAAK,OAAO;AAAA,MAAS,CAAClI,MAC3BsI,GAAetI,EAAG,KAAKkI,CAAe;AAAA,IAAA;AAAA,EAE1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,aACLU,GACAC,IAAU,IACJ;AACN,UAAM/D,IAAS,KAAK,SAAS,MAAA;AAE7B,IAAI+D,KACF/D,EAAO,QAAA;AAGT,aAASgE,EACPC,GACS;AACT,iBAAWnI,KAASmI,GAAY;AAC9B,YAAIH,EAAShI,CAAK,MAAM;AACtB,iBAAO;AAGT,cAAMwD,IAAWyE,IACbjI,EAAM,SAAS,QAAQ,YACvBA,EAAM;AAEV,YAAI,CAACkI,EAAmB1E,CAAQ;AAC9B,iBAAO;AAAA,MAEX;AAEA,aAAO;AAAA,IACT;AAEA,IAAA0E,EAAmBhE,CAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,aACLzE,GACAC,GACAC,IAAgC,UAChC;AACA,WAAO,KAAK,OAAO;AAAA,MAAS,CAACP,MAC3BI,GAAaJ,GAAIK,GAAgBC,GAAgBC,CAAS;AAAA,IAAA;AAAA,EAE9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,YACLyI,GACApJ,GACA;AACA,WAAO,KAAK,OAAO,SAAS,CAACI,MAAOiJ,GAAYjJ,GAAIgJ,GAAepJ,CAAM,CAAC;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAa2C,GAAmC;AACrD,WAAO,KAAK,OAAO;AAAA,MACjB,CAACvC,MAAOsC,GAAsBtC,GAAIuC,GAAgB,CAAA,CAAE,EAAE;AAAA,IAAA;AAAA,EAE1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,cACLA,GACAlC,GACA;AACA,WAAO,KAAK,OAAO;AAAA,MAAS,CAACL,MAC3BsC,GAAsBtC,GAAIuC,GAAgBlC,CAAc;AAAA,IAAA;AAAA,EAE5D;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe;AACpB,WAAOwH,GAAa,KAAK,MAAM;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKO,YAAY;AACjB,IAAAF,GAAU,KAAK,MAAM;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKO,iBAAiB;AACtB,WAAOI,GAAe,KAAK,MAAM;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKO,cAAc;AACnB,IAAAH,GAAY,KAAK,MAAM;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,eAAe;AACpB,WAAOlB,GAAa,KAAK,MAAM;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,iBAAiB;AACtB,WAAOE,GAAe,KAAK,MAAM;AAAA,EACnC;AACF;ACrOO,MAAMsC,WAIHC,GAaP;AAAA,EACD,YAAoB5J,GAAwC;AAC1D,UAAA,GADkB,KAAA,SAAAA,GAIlBA,EAAO,GAAG,UAAU,MAAM;AACxB,MAAAA,EAAO,cAAc;AAAA,QACnB;AAAA,QACA,CAAC,EAAE,aAAA6J,GAAa,sBAAAC,QAA2B;AACzC,eAAK,KAAK,YAAY,EAAE,QAAA9J,GAAQ,aAAA6J,GAAa,sBAAAC,GAAsB;AAAA,QACrE;AAAA,MAAA,GAEF9J,EAAO,cAAc,GAAG,mBAAmB,CAAC,EAAE,aAAA6J,QAAkB;AAC9D,aAAK,KAAK,qBAAqB,EAAE,QAAA7J,GAAQ,aAAA6J,GAAa;AAAA,MACxD,CAAC,GACD7J,EAAO,cAAc,GAAG,SAAS,MAAM;AACrC,aAAK,KAAK,WAAW,EAAE,QAAAA,EAAA,CAAQ;AAAA,MACjC,CAAC,GACDA,EAAO,cAAc,GAAG,WAAW,MAAM;AACvC,aAAK,KAAK,aAAa,EAAE,QAAAA,EAAA,CAAQ;AAAA,MACnC,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKO,SACLqJ,GAUAU,IAA2B,IACd;AACb,UAAMC,IAAK,CAAC;AAAA,MACV,aAAAH;AAAA,MACA,sBAAAC;AAAA,IAAA,MAII;AACJ,MAAI,CAACC,KAA4BE,GAAoBJ,CAAW,KAIhER,EAAS,KAAK,QAAQ;AAAA,QACpB,aAAa;AACX,iBAAOa;AAAA,YACLL;AAAA,YACAC;AAAA,UAAA;AAAA,QAEJ;AAAA,MAAA,CACD;AAAA,IACH;AACA,gBAAK,GAAG,YAAYE,CAAE,GAEf,MAAM;AACX,WAAK,IAAI,YAAYA,CAAE;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,kBACLX,GAIAc,IAAkC,IACrB;AACb,UAAMH,IAAK,CAACI,MAAoC;AAC9C,MACE,CAACD,KACDF,GAAoBG,EAAE,WAAW,KAKnCf,EAAS,KAAK,MAAM;AAAA,IACtB;AAEA,gBAAK,GAAG,qBAAqBW,CAAE,GAExB,MAAM;AACX,WAAK,IAAI,qBAAqBA,CAAE;AAAA,IAClC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,QACLX,GACa;AACb,gBAAK,GAAG,WAAWA,CAAQ,GAEpB,MAAM;AACX,WAAK,IAAI,WAAWA,CAAQ;AAAA,IAC9B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,UACLA,GACa;AACb,gBAAK,GAAG,aAAaA,CAAQ,GAEtB,MAAM;AACX,WAAK,IAAI,aAAaA,CAAQ;AAAA,IAChC;AAAA,EACF;AACF;AAEA,SAASY,GAAoBJ,GAAmC;AAC9D,SAAO,CAAC,CAACA,EAAY,QAAQ,SAAS;AACxC;AClKA,SAASQ,GAAc9K,GAAe;AACpC,SAAO,MAAM,UAAU,QAAQ,KAAKA,EAAK,cAAe,YAAYA,CAAI;AAC1E;AAEA,SAAS+K,GAAiB/K,GAAY;AACpC,SAAOA,EAAK,aAAa,KAAK,CAAC,KAAK,KAAKA,EAAK,aAAa,EAAE;AAC/D;AAwBA,SAASgL,GAAwBlL,GAAsB;AACrD,EAAAA,EAAQ,iBAAiB,kBAAkB,EAAE,QAAQ,CAACmL,MAAS;AAC7D,UAAMC,IAAQJ,GAAcG,CAAI,GAC1BE,IAAiBF,EAAK,eACtBG,IAAgB,MAAM,KAAKD,EAAe,UAAU,EAAE;AAAA,MAC1DD,IAAQ;AAAA,IAAA;AAEV,IAAAD,EAAK,OAAA,GACLG,EAAc,QAAQ,CAACC,MAAY;AACjC,MAAAA,EAAQ,OAAA;AAAA,IACV,CAAC,GAEDF,EAAe,sBAAsB,YAAYF,CAAI,GAErDG,EAAc,QAAA,EAAU,QAAQ,CAACC,MAAY;AAC3C,UAAIN,GAAiBM,CAAO;AAC1B;AAEF,YAAMC,IAAmB,SAAS,cAAc,IAAI;AACpD,MAAAA,EAAiB,OAAOD,CAAO,GAC/BJ,EAAK,sBAAsB,YAAYK,CAAgB;AAAA,IACzD,CAAC,GACGH,EAAe,WAAW,WAAW,KACvCA,EAAe,OAAA;AAAA,EAEnB,CAAC;AACH;AAwBA,SAASI,GAAazL,GAAsB;AAC1C,EAAAA,EAAQ,iBAAiB,kBAAkB,EAAE,QAAQ,CAACmL,MAAS;;AAC7D,UAAMO,IAAWP,EAAK,wBAChBzI,IAAiB,SAAS,cAAc,KAAK;AAEnD,IAAAgJ,EAAS,sBAAsB,YAAYhJ,CAAc,GACzDA,EAAe,OAAOgJ,CAAQ;AAE9B,UAAMC,IAAa,SAAS,cAAc,KAAK;AAI/C,SAHAA,EAAW,aAAa,kBAAkB,YAAY,GACtDjJ,EAAe,OAAOiJ,CAAU,KAG9BnL,IAAAkC,EAAe,uBAAf,gBAAAlC,EAAmC,cAAa,UAChDsF,IAAApD,EAAe,uBAAf,gBAAAoD,EAAmC,cAAa;AAEhD,MAAA6F,EAAW,OAAOjJ,EAAe,kBAAkB;AAAA,EAEvD,CAAC;AACH;AAIA,IAAIkJ,KAAgC;AACpC,SAASC,KAAc;AACrB,SACED,OACCA,KAAe,SAAS,eAAe,mBAAmB,OAAO;AAEtE;AAEO,SAASE,GACdC,GACA;AACA,MAAI,OAAOA,KAAkB,UAAU;AACrC,UAAM/L,IAAU6L,KAAc,cAAc,KAAK;AACjD,IAAA7L,EAAQ,YAAY+L,GACpBA,IAAgB/L;AAAA,EAClB;AACA,SAAAkL,GAAwBa,CAAa,GACrCN,GAAaM,CAAa,GACnBA;AACT;AC/GO,SAASC,GAIdC,GAAcpK,GAA0C;AACxD,QAAMqK,IAAWJ,GAAgCG,CAAI,GAO/CrC,IANSuC,GAAU,WAAWtK,CAAQ,EAMlB,MAAMqK,GAAU;AAAA,IACxC,SAASrK,EAAS,MAAM,WAAc,OAAA;AAAA,EAAO,CAC9C,GAEKqE,IAAiC,CAAA;AAEvC,WAAS,IAAI,GAAG,IAAI0D,EAAW,YAAY;AACzC,IAAA1D,EAAO,KAAK3D,EAAYqH,EAAW,MAAM,CAAC,GAAG/H,CAAQ,CAAC;AAGxD,SAAOqE;AACT;ACdA,SAASkG,GAAKC,GAAYnM,GAAW;AACnC,QAAMoM,IAAQpM,EAAK,QAAQA,EAAK,QAAQ,IAElCqM,IAAkB,CAAA;AAExB,EAAIrM,EAAK,SAEPqM,EAAW,eAAe,IAAIrM,EAAK;AAKrC,MAAIsM,IAAc;AAAA,IAChB,MAAM;AAAA,IACN,SAAS;AAAA,IACT,YAAAD;AAAA,IACA,UAAU,CAAC,EAAE,MAAM,QAAQ,OAAAD,GAAO;AAAA,EAAA;AAGpC,SAAIpM,EAAK,SACPsM,EAAO,OAAO,EAAE,MAAMtM,EAAK,KAAA,IAG7BmM,EAAM,MAAMnM,GAAMsM,CAAM,GACxBA,IAASH,EAAM,UAAUnM,GAAMsM,CAAM,GAGrCA,IAAS;AAAA,IACP,MAAM;AAAA,IACN,SAAS;AAAA,IACT,YAAY,CAAA;AAAA,IACZ,UAAU,CAACA,CAAM;AAAA,EAAA,GAEnBH,EAAM,MAAMnM,GAAMsM,CAAM,GACjBA;AACT;AAEA,SAASC,GAAMJ,GAAYnM,GAAW;;AACpC,QAAMwM,IAAM,QAAOxM,KAAA,gBAAAA,EAAM,QAAO,EAAE,GAC5ByM,IAAQzM,KAAA,QAAAA,EAAM,QAAQ,OAAOA,EAAK,KAAK,IAAI;AAEjD,MAAIsM,IAAc;AAAA,IAChB,MAAM;AAAA,IACN,SAAS;AAAA,IACT,YAAY;AAAA,MACV,KAAKE;AAAA,MACL,aAAaC;AAAA,MACb,YAAYD;AAAA,MACZ,UAAU;AAAA,IAAA;AAAA,IAEZ,UAAU,CAAA;AAAA,EAAC;AAEb,UAAAlM,IAAA6L,EAAM,UAAN,QAAA7L,EAAA,KAAA6L,GAAcnM,GAAMsM,IACpBA,IAASH,EAAM,YAAYA,EAAM,UAAUnM,GAAMsM,CAAM,IAAIA,GAEpDA;AACT;AAEO,SAASI,GAAeC,GAA0B;AAiCvD,SAhCmBC,GAAA,EAChB,IAAIC,EAAW,EACf,IAAIC,EAAS,EACb,IAAIC,IAAc;AAAA,IACjB,UAAU;AAAA,MACR,GAAIC;AAAAA,MACJ,OAAO,CAACb,GAAYnM,MAAc;AAChC,cAAMwM,IAAM,QAAOxM,KAAA,gBAAAA,EAAM,QAAO,EAAE;AAElC,eAAIiN,GAAWT,CAAG,IACTD,GAAMJ,GAAOnM,CAAI,IAEjBgN,GAA4B,MAAMb,GAAOnM,CAAI;AAAA,MAExD;AAAA,MAAA,MACAkM;AAAAA,MACA,YAAY,CAACC,GAAYnM,MAAc;AACrC,cAAMsM,IAAS;AAAA,UACb,MAAM;AAAA,UACN,SAAS;AAAA,UACT,YAAY,CAAA;AAAA;AAAA,UAEZ,UAAUH,EAAM,KAAKA,EAAM,IAAInM,CAAI,GAAG,EAAK;AAAA,QAAA;AAE7C,eAAAmM,EAAM,MAAMnM,GAAMsM,CAAM,GACjBH,EAAM,UAAUnM,GAAMsM,CAAM;AAAA,MACrC;AAAA,IAAA;AAAA,EACF,CACD,EACA,IAAIY,EAAe,EACnB,YAAYP,CAAQ,EAEL;AACpB;AAEO,SAASQ,GAIdR,GAAkBhL,GAA0C;AAC5D,QAAMyL,IAAaV,GAAeC,CAAQ;AAE1C,SAAOb,GAAasB,GAAYzL,CAAQ;AAC1C;ACpGO,MAAM0L,GAIX;AAAA,EACA,YAAoB5M,GAAoD;AAApD,SAAA,SAAAA;AAAA,EAAqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASlE,kBACLuF,IAAoD,KAAK,OAAO,UACxD;AAKR,WAJiBsH;AAAA,MACf,KAAK,OAAO;AAAA,MACZ,KAAK;AAAA,IAAA,EAES,aAAatH,GAAQ,EAAE;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,iBACLA,IAAoD,KAAK,OAAO,UACxD;AAKR,WAJiBI;AAAA,MACf,KAAK,OAAO;AAAA,MACZ,KAAK;AAAA,IAAA,EAES,gBAAgBJ,GAAQ,EAAE;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,qBACL+F,GACoC;AACpC,WAAOD,GAAaC,GAAM,KAAK,OAAO,QAAQ;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,sBACL/F,IAAoD,KAAK,OAAO,UACxD;AACR,WAAOuH,GAAiBvH,GAAQ,KAAK,OAAO,UAAU,KAAK,QAAQ,EAAE;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,yBACL2G,GACoC;AACpC,WAAOQ,GAAiBR,GAAU,KAAK,OAAO,QAAQ;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,UAAUZ,GAAcyB,IAAM,IAAO;;AAC1C,QAAIC,IAAc1B;AAClB,QAAI,CAACyB,GAAK;AACR,YAAMxH,IAAS,KAAK,qBAAqB+F,CAAI;AAC7C,MAAA0B,IAAc,KAAK,iBAAiBzH,CAAM;AAAA,IAC5C;AACA,IAAKyH,OAGLnN,IAAA,KAAK,OAAO,oBAAZ,QAAAA,EAA6B,UAAUmN;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAUC,GAAc;;AAC7B,YAAOpN,IAAA,KAAK,OAAO,oBAAZ,gBAAAA,EAA6B,UAAUoN;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,cAAcf,GAAkB;AACrC,UAAMZ,IAAOW,GAAeC,CAAQ;AACpC,WAAO,KAAK,UAAUZ,CAAI;AAAA,EAC5B;AACF;ACxIO,MAAM4B,KAAoB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;ACGA,SAASC,GACPC,GACAC,GACA;AACA,MAAI,CAACD,EAAe,WAAW,GAAG,KAAK,CAACC,EAAe,WAAW,GAAG;AACnE,UAAM,IAAI,MAAM,qDAAqD;AAGvE,SAAOD,MAAmBC;AAC5B;AAEA,SAASC,GAAoBC,GAAmBC,GAAmB;AACjE,QAAMC,IAASF,EAAU,MAAM,GAAG,GAC5BG,IAASF,EAAU,MAAM,GAAG;AAElC,MAAIC,EAAO,WAAW;AACpB,UAAM,IAAI,MAAM,cAAcF,CAAS,4BAA4B;AAErE,MAAIG,EAAO,WAAW;AACpB,UAAM,IAAI,MAAM,cAAcF,CAAS,4BAA4B;AAGrE,SAAIC,EAAO,CAAC,MAAM,OAAOC,EAAO,CAAC,MAAM,MAC9BD,EAAO,CAAC,MAAMC,EAAO,CAAC,KAE3BD,EAAO,CAAC,MAAM,OAAOC,EAAO,CAAC,MAAM,OAIhCD,EAAO,CAAC,MAAMC,EAAO,CAAC,MAAKD,EAAO,CAAC,MAAMC,EAAO,CAAC;AAC1D;AAEA,SAASC,GAKP3N,GACAe,GACA6M,GACA5M,IAAgC,SAChC;AACA,MAAI6M;AAEJ,SACE,MAAM,QAAQ9M,EAAe,OAAO,KACpCA,EAAe,QAAQ,WAAW,IAElC8M,IAAkB7N,EAAO,YAAYe,GAAgB6M,CAAQ,EAAE,KAE/DC,IAAkB7N,EAAO;AAAA,IACvB,CAAC4N,CAAQ;AAAA,IACT7M;AAAA,IACAC;AAAA,EAAA,EACA,CAAC,EAAE,IAGA6M;AACT;AAEA,eAAsBC,GAIpBC,GAAmC/N,GAAwC;;AAC3E,MAAI,CAACA,EAAO,YAAY;AAEtB,YAAQ;AAAA,MACN;AAAA,IAAA;AAEF;AAAA,EACF;AAEA,QAAMgO,IACJ,kBAAkBD,IAAQA,EAAM,eAAeA,EAAM;AACvD,MAAIC,MAAiB;AACnB;AAGF,MAAIC,IAAoD;AACxD,aAAWC,KAAYhB;AACrB,QAAIc,EAAa,MAAM,SAASE,CAAQ,GAAG;AACzC,MAAAD,IAASC;AACT;AAAA,IACF;AAEF,MAAID,MAAW;AACb;AAGF,QAAME,IAAQH,EAAa;AAC3B,MAAKG,GAIL;AAAA,IAAAJ,EAAM,eAAA;AAEN,aAAS,IAAI,GAAG,IAAII,EAAM,QAAQ,KAAK;AAErC,UAAIC,IAAgB;AACpB,iBAAWC,KAAa,OAAO,OAAOrO,EAAO,OAAO,UAAU;AAC5D,mBAAWkO,OAAYrO,IAAAwO,EAAU,eAAe,SAAzB,gBAAAxO,EAA+B,oBACpD,IAAI;AACJ,gBAAMyO,IAAkBJ,EAAS,WAAW,GAAG,GACzCK,IAAOJ,EAAM,CAAC,EAAE,UAAA;AAEtB,cAAII,MAEC,CAACD,KACAC,EAAK,QACLjB,GAAoBa,EAAM,CAAC,EAAE,MAAMD,CAAQ,KAC5CI,KACCnB;AAAA,YACE,MAAMoB,EAAK,KAAK,MAAM,GAAG,EAAE,IAAA;AAAA,YAC3BL;AAAA,UAAA,IAEJ;AACA,YAAAE,IAAgBC,EAAU,OAAO;AACjC;AAAA,UACF;AAAA,QAEJ;AAGF,YAAME,IAAOJ,EAAM,CAAC,EAAE,UAAA;AACtB,UAAII,GAAM;AACR,cAAMC,IAAY;AAAA,UAChB,MAAMJ;AAAA,UACN,OAAO;AAAA,YACL,MAAMG,EAAK;AAAA,UAAA;AAAA,QACb;AAGF,YAAIV;AAEJ,YAAIE,EAAM,SAAS,SAAS;AAC1B,gBAAMU,IAAezO,EAAO,sBAAA,EAAwB;AACpD,UAAA6N,IAAkBF,GAAoB3N,GAAQyO,GAAcD,CAAS;AAAA,QACvE,WAAWT,EAAM,SAAS,QAAQ;AAChC,gBAAMW,IAAS;AAAA,YACb,MAAOX,EAAoB;AAAA,YAC3B,KAAMA,EAAoB;AAAA,UAAA,GAGtBvN,IAAMR,EAAO,gBAAgB,YAAY0O,CAAM;AAErD,cAAI,CAAClO;AACH;AAGF,UAAAqN,IAAkB7N,EAAO,SAAS,CAACS,MAAO;;AACxC,kBAAMc,IAAUwE,EAAmBtF,EAAG,KAAKD,EAAI,GAAG,GAC5CmO,KAAe9O,IAAAG,EAAO,eAAP,gBAAAH,EAAmB;AAAA,cACtC,aAAa0B,EAAQ,KAAK,MAAM,EAAE;AAAA,eAG9BqN,IAAYD,KAAA,gBAAAA,EAAc;AAEhC,mBAAOhB;AAAA,cACL3N;AAAA,cACAA,EAAO,SAASuB,EAAQ,KAAK,MAAM,EAAE;AAAA,cACrCiN;AAAA,cACAI,MAAcA,EAAU,MAAMA,EAAU,UAAU,IAAIF,EAAO,MACzD,WACA;AAAA,YAAA;AAAA,UAER,CAAC;AAAA,QACH;AACE;AAGF,cAAMG,IAAa,MAAM7O,EAAO,WAAWuO,GAAMV,CAAe,GAE1DiB,IACJ,OAAOD,KAAe,WACjB;AAAA,UACC,OAAO;AAAA,YACL,KAAKA;AAAA,UAAA;AAAA,QACP,IAEF,EAAE,GAAGA,EAAA;AAEX,QAAA7O,EAAO,YAAY6N,GAAiBiB,CAAgB;AAAA,MACtD;AAAA,IACF;AAAA;AACF;ACvLO,MAAMC,KAA0B,CAKrC/O,MAEAgP,EAAU,OAA8D;AAAA,EACtE,MAAM;AAAA,EACN,wBAAwB;AACtB,WAAO;AAAA,MACL,IAAIC,GAAO;AAAA,QACT,OAAO;AAAA,UACL,iBAAiB;AAAA,YACf,KAAKC,GAAOnB,GAAO;AACjB,kBAAI,CAAC/N,EAAO;AACV;AAGF,kBAAIiO,IAAoD;AACxD,yBAAWC,KAAYhB;AACrB,oBAAIa,EAAM,aAAc,MAAM,SAASG,CAAQ,GAAG;AAChD,kBAAAD,IAASC;AACT;AAAA,gBACF;AAEF,qBAAID,MAAW,OACN,KAGLA,MAAW,WACbH,GAAoBC,GAAO/N,CAAM,GAC1B,MAGF;AAAA,YACT;AAAA,UAAA;AAAA,QACF;AAAA,MACF,CACD;AAAA,IAAA;AAAA,EAEL;AACF,CAAC,GCrDGmP,KAAK,2DAGLC,KACJ,sEAGIC,KAAO,4CAGP5D,KAAO,mEAGP6D,KAAK,4CAGLC,KAAK,oDAGLC,KAAK,2BAGLC,KACJ,oGAGIzD,KAAQ,mEAGR0D,KACJ,+DAGIC,KAAc,sBAGdC,KAAe,mCAGfC,KAAW,sBAOJC,KAAa,CAACC,MACzBZ,GAAG,KAAKY,CAAG,KACXX,GAAK,KAAKW,CAAG,KACbV,GAAK,KAAKU,CAAG,KACbtE,GAAK,KAAKsE,CAAG,KACbT,GAAG,KAAKS,CAAG,KACXR,GAAG,KAAKQ,CAAG,KACXP,GAAG,KAAKO,CAAG,KACXN,GAAO,KAAKM,CAAG,KACf/D,GAAM,KAAK+D,CAAG,KACdL,GAAW,KAAKK,CAAG,KACnBJ,GAAY,KAAKI,CAAG,KACpBH,GAAa,KAAKG,CAAG,KACrBF,GAAS,KAAKE,CAAG;AC1DnB,eAAsBC,GACpBjC,GACAkC,GACA;AACA,QAAM,EAAE,QAAArK,MAAWqK,EAAK;AAExB,MAAI,CAAClC,EAAM;AACT,WAAO;AAGT,QAAMd,IAAOc,EAAM,cAAe,QAAQ,YAAY;AAEtD,MAAI,CAACd;AACH,WAAO;AAGT,MAAI,CAACrH,EAAO,MAAM;AAChB,WAAAqK,EAAK,UAAUhD,CAAI,GACZ;AAGT,QAAMiD,IAASnC,EAAM,cAAe,QAAQ,oBAAoB,GAC1DoC,IAAaD,IAAS,KAAK,MAAMA,CAAM,IAAI,QAC3CE,IAAWD,KAAA,gBAAAA,EAAY;AAE7B,SAAKC,KAMLH,EAAK;AAAA,IACH,8BAA8BG,CAAQ,KAAKnD,EAAK;AAAA,MAC9C;AAAA,MACA;AAAA;AAAA,IAAA,CACD;AAAA,EAAA,GAGI,MAZE;AAaX;ACxBA,SAASoD,GAAoB;AAAA,EAC3B,OAAAtC;AAAA,EACA,QAAA/N;AAAA,EACA,4BAAAsQ;AAAA,EACA,qBAAAC;AACF,GAKG;;AASD,MANsBvQ,EAAO;AAAA,IAC3B,CAACS,MACCA,EAAG,UAAU,MAAM,OAAO,KAAK,KAAK,QACpCA,EAAG,UAAU,IAAI,OAAO,KAAK,KAAK;AAAA,EAAA,GAGnB;AACjB,UAAM2F,KAAOvG,IAAAkO,EAAM,kBAAN,gBAAAlO,EAAqB,QAAQ;AAE1C,QAAIuG;AACF,aAAApG,EAAO,UAAUoG,CAAI,GAEd;AAAA,EAEX;AAEA,MAAI6H;AACJ,aAAWC,KAAYhB;AACrB,QAAIa,EAAM,cAAe,MAAM,SAASG,CAAQ,GAAG;AACjD,MAAAD,IAASC;AACT;AAAA,IACF;AAGF,MAAI,CAACD;AACH,WAAO;AAGT,MAAIA,MAAW;AACb,WAAA+B,GAAkBjC,GAAO/N,EAAO,eAAe,GACxC;AAGT,MAAIiO,MAAW;AACb,WAAAH,GAAoBC,GAAO/N,CAAM,GAC1B;AAGT,QAAMoG,IAAO2H,EAAM,cAAe,QAAQE,CAAM;AAEhD,MAAIA,MAAW;AAEb,WAAAjO,EAAO,UAAUoG,GAAM,EAAI,GACpB;AAGT,MAAI6H,MAAW;AACb,WAAAjO,EAAO,cAAcoG,CAAI,GAClB;AAGT,MAAIkK,GAA4B;AAE9B,UAAME,IAAYzC,EAAM,cAAe,QAAQ,YAAY;AAE3D,QAAI+B,GAAWU,CAAS;AACtB,aAAAxQ,EAAO,cAAcwQ,CAAS,GACvB;AAAA,EAEX;AAEA,SAAIvC,MAAW,eACbjO,EAAO,UAAUoG,CAAI,GACd,MAGLmK,KACFvQ,EAAO,cAAcoG,CAAI,GAClB,OAGTpG,EAAO,UAAUoG,CAAI,GACd;AACT;AAEO,MAAMqK,KAAoC,CAK/CzQ,GACA0Q,MAKA1B,EAAU,OAAO;AAAA,EACf,MAAM;AAAA,EACN,wBAAwB;AACtB,WAAO;AAAA,MACL,IAAIC,GAAO;AAAA,QACT,OAAO;AAAA,UACL,iBAAiB;AAAA,YACf,MAAMC,GAAOnB,GAAO;AAGlB,kBAFAA,EAAM,eAAA,GAEF,EAAC/N,EAAO;AAIZ,uBAAO0Q,EAAa;AAAA,kBAClB,OAAA3C;AAAA,kBACA,QAAA/N;AAAA,kBACA,qBAAqB,CAAC;AAAA,oBACpB,4BAAAsQ,IAA6B;AAAA,oBAC7B,qBAAAC,IAAsB;AAAA,kBAAA,IACpB,OACKF,GAAoB;AAAA,oBACzB,OAAAtC;AAAA,oBACA,QAAA/N;AAAA,oBACA,4BAAAsQ;AAAA,oBACA,qBAAAC;AAAA,kBAAA,CACD;AAAA,gBACH,CACD;AAAA,YACH;AAAA,UAAA;AAAA,QACF;AAAA,MACF,CACD;AAAA,IAAA;AAAA,EAEL;AACF,CAAC;ACnIH,SAASI,GAKPV,GACAW,GACA5Q,GACA;;AACA,MAAI6Q,IAAuB;AAC3B,QAAMC,IAAgBb,EAAK,MAAM,qBAAqBjK;AAEtD,MAAI,CAAC8K,GAAe;AAIlB,UAAMC,IAAyBd,EAAK,MAAM,IAAI;AAAA,MAC5CA,EAAK,MAAM,UAAU;AAAA,MACrBA,EAAK,MAAM,UAAU;AAAA,MACrB;AAAA,IAAA,EACA,SAEIpL,IAAW,CAAA;AACjB,aAASmM,IAAI,GAAGA,IAAID,EAAuB,YAAYC;AACrD,MAAAnM,EAAS,KAAKkM,EAAuB,MAAMC,CAAC,CAAC;AAG/C,IAAAH,IACEhM,EAAS;AAAA,MACP,CAACoM,MACCA,EAAM,KAAK,UAAU,SAAS,KAC9BA,EAAM,KAAK,SAAS,gBACpBA,EAAM,KAAK,KAAK,UAAU;AAAA,IAAA,MACxB,QACJJ,MACFD,IAAmBG;AAAA,EAEvB;AAEA,MAAIG;AAEJ,QAAMC,IAAuBtE;AAAA,IAC3BoD,EAAK,MAAM;AAAA,IACXjQ;AAAA,EAAA;AAGF,MAAI8Q,GAAe;AACjB,MAAIjR,IAAA+Q,EAAiB,eAAjB,gBAAA/Q,EAA6B,KAAK,UAAS,YAG7C+Q,IAAmBA,EAAiB,WAAW;AAKjD,UAAM7L,IAAKqM;AAAA,MACTR;AAAA,MACA5Q,EAAO,OAAO;AAAA,MACdA,EAAO,OAAO;AAAA,IAAA;AAIhB,IAAAkR,IAAe,UAAUC,EAAqB;AAAA,MAC5CpM;AAAA,MACA,CAAA;AAAA,IAAC,CACF;AAAA,EACH,WAAW8L,GAAsB;AAG/B,UAAM9L,IAAKsM;AAAA,MACTT;AAAA,MACA5Q,EAAO,OAAO;AAAA,MACdA,EAAO,OAAO;AAAA,IAAA;AAEhB,IAAAkR,IAAeC,EAAqB,oBAAoBpM,GAAI,CAAA,CAAE;AAAA,EAChE,OAAO;AACL,UAAMQ,IAAS+L,GAAgCV,CAAgB;AAC/D,IAAAM,IAAeC,EAAqB,aAAa5L,GAAQ,CAAA,CAAE;AAAA,EAC7D;AACA,SAAO2L;AACT;AAEO,SAASK,GAKdtB,GACAjQ,GAKA;AAKA,EACE,UAAUiQ,EAAK,MAAM,aACpBA,EAAK,MAAM,UAAU,KAAc,KAAK,KAAK,UAAU,kBAExDjQ,EAAO;AAAA,IAAS,CAACS,MACfA,EAAG;AAAA,MACD,IAAIwF,EAAcxF,EAAG,IAAI,QAAQwP,EAAK,MAAM,UAAU,OAAO,CAAC,CAAC;AAAA,IAAA;AAAA,EACjE;AAKJ,QAAMuB,IAAwBvB,EAAK;AAAA,IACjCA,EAAK,MAAM,UAAU,QAAA;AAAA,EAAQ,EAC7B,IAAI,WAEAW,IAAmBX,EAAK,MAAM,UAAU,UAAU,SAElDiB,IAAeP;AAAA,IACnBV;AAAA,IACAW;AAAA,IACA5Q;AAAA,EAAA,GAGIkM,IAAWuF,GAAoBP,CAAY;AAEjD,SAAO,EAAE,eAAAM,GAAe,cAAAN,GAAc,UAAAhF,EAAA;AACxC;AAEA,MAAMwF,KAAqC,MAAM;AAG/C,QAAMpL,IAAY,OAAO,aAAA;AACzB,MAAI,CAACA,KAAaA,EAAU;AAC1B,WAAO;AAQT,MAAI/G,IAAO+G,EAAU;AACrB,SAAO/G,KAAM;AACX,QACEA,aAAgB,eAChBA,EAAK,aAAa,iBAAiB,MAAM;AAEzC,aAAO;AAGT,IAAAA,IAAOA,EAAK;AAAA,EACd;AAEA,SAAO;AACT,GAEMoS,KAAkB,CAKtB3R,GACAiQ,GACAlC,MACG;AAEH,EAAAA,EAAM,eAAA,GACNA,EAAM,cAAe,UAAA;AAErB,QAAM,EAAE,eAAAyD,GAAe,cAAAN,GAAc,UAAAhF,EAAA,IAAaqF;AAAA,IAChDtB;AAAA,IACAjQ;AAAA,EAAA;AAKF,EAAA+N,EAAM,cAAe,QAAQ,kBAAkByD,CAAa,GAC5DzD,EAAM,cAAe,QAAQ,aAAamD,CAAY,GACtDnD,EAAM,cAAe,QAAQ,cAAc7B,CAAQ;AACrD,GAEa0F,KAAiC,CAK5C5R,MAEAgP,EAAU,OAA8D;AAAA,EACtE,MAAM;AAAA,EACN,wBAAwB;AACtB,WAAO;AAAA,MACL,IAAIC,GAAO;AAAA,QACT,OAAO;AAAA,UACL,iBAAiB;AAAA,YACf,KAAKgB,GAAMlC,GAAO;AAChB,qBAAI2D,QAIJC,GAAgB3R,GAAQiQ,GAAMlC,CAAK,GAE5B;AAAA,YACT;AAAA,YACA,IAAIkC,GAAMlC,GAAO;AACf,qBAAI2D,SAIJC,GAAgB3R,GAAQiQ,GAAMlC,CAAK,GAC/BkC,EAAK,YACPA,EAAK,SAASA,EAAK,MAAM,GAAG,iBAAiB,IAGxC;AAAA,YACT;AAAA;AAAA;AAAA;AAAA,YAIA,UAAUA,GAAMlC,GAAO;AAOrB,kBALI,EAAE,UAAUkC,EAAK,MAAM,cAMxBA,EAAK,MAAM,UAAU,KAAc,KAAK,KAAK,UAC9C;AAEA;AAIF,cAAAjQ,EAAO;AAAA,gBAAS,CAACS,MACfA,EAAG;AAAA,kBACD,IAAIwF;AAAA,oBACFxF,EAAG,IAAI,QAAQwP,EAAK,MAAM,UAAU,OAAO,CAAC;AAAA,kBAAA;AAAA,gBAC9C;AAAA,cACF,GAIFlC,EAAM,eAAA,GACNA,EAAM,aAAc,UAAA;AAEpB,oBAAM,EAAE,eAAAyD,GAAe,cAAAN,GAAc,UAAAhF,MACnCqF,GAAuBtB,GAAMjQ,CAAM;AAIrC,qBAAA+N,EAAM,aAAc,QAAQ,kBAAkByD,CAAa,GAC3DzD,EAAM,aAAc,QAAQ,aAAamD,CAAY,GACrDnD,EAAM,aAAc,QAAQ,cAAc7B,CAAQ,GAG3C;AAAA,YACT;AAAA,UAAA;AAAA,QACF;AAAA,MACF,CACD;AAAA,IAAA;AAAA,EAEL;AACF,CAAC,GCvRU2F,KAA2B7C,EAAU,OAAO;AAAA,EACvD,MAAM;AAAA,EAEN,sBAAsB;AACpB,WAAO;AAAA,MACL;AAAA,QACE,OAAO,CAAC,aAAa,aAAa;AAAA,QAClC,YAAY;AAAA,UACV,iBAAiB8C,GAAA;AAAA,QAA4B;AAAA,MAC/C;AAAA,IACF;AAAA,EAEJ;AACF,CAAC,GCNYC,KAAYnS,EAAK,OAAO;AAAA,EACnC,MAAM;AAAA,EAEN,QAAQ;AAAA,EAER,OAAO;AAAA,EAEP,YAAY;AAAA,EAEZ,sBAAsB;AAAA,EAEtB,UAAU;AAAA,EAEV,YAAY;AACV,WAAO,CAAC,EAAE,KAAK,MAAM;AAAA,EACvB;AAAA,EAEA,WAAW,EAAE,gBAAAoS,KAAkB;AAC7B,WAAO,CAAC,MAAMC,GAAgB,KAAK,QAAQ,gBAAgBD,CAAc,CAAC;AAAA,EAC5E;AAAA,EAEA,aAAa;AACX,WAAO;AAAA;AAAA,EACT;AACF,CAAC,GCCYE,IAAmB,CAACxJ,GAAWyJ,MAAsB;AAChE,QAAM3O,IAAOkF,EAAI,QAAQyJ,CAAS,GAE5BC,IAAgB5O,EAAK,MAAA;AAE3B,MAAI4O,MAAkB;AACpB;AAGF,QAAMC,IAAqB7O,EAAK,WAAW4O,IAAgB,CAAC;AAK5D,SAHsBE;AAAA,IACpB5J,EAAI,QAAQ2J,CAAkB;AAAA,EAAA;AAGlC,GAWaE,KAA2B,CAAC7J,GAAW8J,MAAyB;AAC3E,SAAOA,EAAU,kBAAgB;AAC/B,UAAMC,IAAQD,EAAU,eAAe,MAEjCE,IAAShK,EACZ,QAAQ8J,EAAU,eAAe,YAAY,CAAC,EAC9C,WAAWC,EAAM,aAAa,CAAC;AAClC,IAAAD,IAAYF,EAA4B5J,EAAI,QAAQgK,CAAM,CAAC;AAAA,EAC7D;AAEA,SAAOF;AACT,GAEMG,KAAW,CAACC,GAA0BC,MAExCD,EAAc,oBACdA,EAAc,aAAa,KAAK,KAAK,KAAK,YAAY,aACtDA,EAAc,aAAa,KAAK,aAAa,KAC7CC,EAAc,oBACdA,EAAc,aAAa,KAAK,KAAK,KAAK,YAAY,WAIpDC,KAAc,CAClBpH,GACAqH,GACAH,GACAC,MACG;AAEH,MAAI,CAACA,EAAc;AACjB,UAAM,IAAI;AAAA,MACR,wCAAwCA,EAAc,QAAQ,SAAS,oCAAoCD,EAAc,QAAQ,SAAS;AAAA,IAAA;AAM9I,MAAIC,EAAc,gBAAgB;AAChC,UAAMG,IAAmBtH,EAAM,IAAI;AAAA,MACjCmH,EAAc,eAAe,YAAY;AAAA,IAAA,GAErCI,IAAiBvH,EAAM,IAAI;AAAA,MAC/BmH,EAAc,eAAe,WAAW;AAAA,IAAA,GAEpCK,IAAmBF,EAAiB,WAAWC,CAAc;AAEnE,QAAIF,GAAU;AACZ,YAAMvS,IAAMkL,EAAM,IAAI,QAAQmH,EAAc,QAAQ,SAAS;AAC7D,MAAAnH,EAAM,GAAG,KAAKwH,GAAmB1S,EAAI,KAAK;AAAA,IAC5C;AAAA,EACF;AAKA,MAAIuS,GAAU;AACZ,QAAI,CAACH,EAAc;AACjB,YAAM,IAAI;AAAA,QACR,wCAAwCC,EAAc,QAAQ,SAAS,oCAAoCD,EAAc,QAAQ,SAAS;AAAA,MAAA;AAK9I,IAAAG;AAAA,MACErH,EAAM,GAAG;AAAA,QACPkH,EAAc,aAAa,WAAW;AAAA,QACtCC,EAAc,aAAa,YAAY;AAAA,MAAA;AAAA,IACzC;AAAA,EAEJ;AAEA,SAAO;AACT,GAEaM,KACX,CAACC,MACD,CAAC;AAAA,EACC,OAAA1H;AAAA,EACA,UAAAqH;AACF,MAGM;AACJ,QAAMvP,IAAOkI,EAAM,IAAI,QAAQ0H,CAAgB,GACzCP,IAAgBP,EAA4B9O,CAAI,GAEhDoP,IAAgBV;AAAA,IACpBxG,EAAM;AAAA,IACNmH,EAAc,QAAQ;AAAA,EAAA;AAGxB,MAAI,CAACD;AACH,WAAO;AAGT,QAAMS,IAAwBd;AAAA,IAC5B7G,EAAM;AAAA,IACNkH;AAAA,EAAA;AAGF,SAAKD,GAASU,GAAuBR,CAAa,IAI3CC,GAAYpH,GAAOqH,GAAUM,GAAuBR,CAAa,IAH/D;AAIX,GCtJWS,KAA6BtE,EAAU,OAGjD;AAAA,EACD,UAAU;AAAA;AAAA;AAAA,EAIV,uBAAuB;AAErB,UAAMuE,IAAkB,MACtB,KAAK,OAAO,SAAS,MAAM,CAAC,EAAE,OAAAC,GAAO,UAAAC,QAAe;AAAA;AAAA,MAElD,MAAMA,EAAS,gBAAA;AAAA;AAAA,MAEf,MAAMA,EAAS,cAAA;AAAA;AAAA,MAEf,MACEA,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAGT,cAAMmB,IACJjI,EAAM,UAAU,SAAS8G,EAAU,aAAa,YAAY,GACxDoB,IACJpB,EAAU,aAAa,KAAK,KAAK,SAAS;AAE5C,eAAImB,KAAyB,CAACC,IACrBH,EAAS;AAAA,UACdI,GAAmBrB,EAAU,QAAQ,WAAW;AAAA,YAC9C,MAAM;AAAA,YACN,OAAO,CAAA;AAAA,UAAC,CACT;AAAA,QAAA,IAIE;AAAA,MACT,CAAC;AAAA;AAAA,MAEH,MACEiB,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAET,cAAM,EAAE,cAAAxQ,MAAiBwQ;AAKzB,eAFE9G,EAAM,UAAU,SAAS1J,EAAa,YAAY,IAG3CyR,EAAS,aAAa,gBAAgB,IAGxC;AAAA,MACT,CAAC;AAAA;AAAA;AAAA,MAGH,MACEA,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAET,cAAM,EAAE,SAASzQ,GAAgB,cAAAC,EAAA,IAAiBwQ,GAE5CmB,IACJjI,EAAM,UAAU,SAAS1J,EAAa,YAAY,GAC9C8R,IAAiBpI,EAAM,UAAU,OAEjC0H,IAAmBrR,EAAe;AAExC,eAAI4R,KAAyBG,IACpBN,EAAA,EACJ,QAAQL,GAAmBC,CAAgB,CAAC,EAC5C,eAAA,EACA,IAAA,IAGE;AAAA,MACT,CAAC;AAAA,MACH,MACEK,EAAS,QAAQ,CAAC,EAAE,OAAA/H,GAAO,IAAAjL,GAAI,UAAAsS,QAAe;AAE5C,cAAMP,IAAYkB,EAA0BhI,CAAK;AAOjD,YANI,CAAC8G,EAAU,oBAMX,EADF/R,EAAG,UAAU,SAAS+R,EAAU,aAAa,YAAY;AAEzD,iBAAO;AAGT,cAAMhP,IAAO/C,EAAG,IAAI,QAAQ+R,EAAU,QAAQ,SAAS;AASvD,YAPkBhP,EAAK,cAMHA,EAAK,KAAA,EACT,KAAK,SAAS;AAC5B,iBAAO;AAGT,cAAMuQ,IAAYtT,EAAG,IAAI,QAAQ+R,EAAU,QAAQ,SAAS,GACtDwB,IAAavT,EAAG,IAAI,QAAQsT,EAAU,QAAQ,GAC9C7R,IAAgB8R,EAAW,OAAA;AAEjC,YAAIjB,GAAU;AACZ,gBAAM9O,IAAWxD,EAAG,IAAI;AAAA,YACtB+R,EAAU,QAAQ;AAAA,YAClBA,EAAU,QAAQ;AAAA,UAAA,EAClB;AAEF,UAAA/R,EAAG;AAAA,YACD+R,EAAU,QAAQ;AAAA,YAClBA,EAAU,QAAQ;AAAA,UAAA,GAGhBwB,EAAW,MAAA,MAAY,KAEzBzR,EAAc9B,GAAIyB,CAAa,GAC/BzB,EAAG,OAAOyB,GAAe+B,CAAQ,GACjCxD,EAAG;AAAA,YACD+F,EAAc,KAAK/F,EAAG,IAAI,QAAQyB,CAAa,CAAC;AAAA,UAAA,MAKlDzB,EAAG,OAAOuT,EAAW,MAAM,GAAG/P,CAAQ,GACtCxD,EAAG;AAAA,YACD+F,EAAc,KAAK/F,EAAG,IAAI,QAAQuT,EAAW,MAAM,CAAC,CAAC;AAAA,UAAA,GAEvDzR,EAAc9B,GAAIyB,CAAa;AAAA,QAEnC;AAEA,eAAO;AAAA,MACT,CAAC;AAAA;AAAA;AAAA,MAGH,MACEuR,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAOT,YAHEA,EAAU,aAAa,KAAK,eAAe,KAC3CA,EAAU,aAAa,KAAK,KAAK,KAAK,YAAY,WAEpC;AACd,gBAAMI,IAAgBV;AAAA,YACpBxG,EAAM;AAAA,YACN8G,EAAU,QAAQ;AAAA,UAAA;AAEpB,cAAI,CAACI,KAAiB,CAACA,EAAc;AACnC,mBAAO;AAGT,cAAIqB,IAAkBT,EAAA;AAEtB,cACEZ,EAAc,aAAa,KAAK,KAAK,KAAK,YAC1C,aACA;AAKA,kBAAMsB,IAJmB1B,EAAU,QAAQ,YAAY,IACJ,IACH,IACT,IACU;AAEjD,YAAAyB,IAAkBA,EAAgB;AAAA,cAChCC;AAAA,YAAA;AAAA,UAEJ,WACEtB,EAAc,aAAa,KAAK,KAAK,KAAK,YAAY,IACtD;AACA,kBAAMuB,IACJvB,EAAc,aAAa,WAC3BA,EAAc,aAAa,KAAK;AAElC,YAAAqB,IAAkBA,EAAgB;AAAA,cAChCE;AAAA,YAAA;AAAA,UAEJ,OAAO;AACL,kBAAMC,IACJxB,EAAc,aAAa,WAC3BA,EAAc,aAAa,KAAK;AAElC,YAAAqB,IACEA,EAAgB,iBAAiBG,CAAoB;AAAA,UACzD;AAEA,iBAAOH,EACJ,YAAY;AAAA,YACX,MAAMzB,EAAU,QAAQ;AAAA,YACxB,IAAIA,EAAU,QAAQ;AAAA,UAAA,CACvB,EACA,eAAA,EACA,IAAA;AAAA,QACL;AAEA,eAAO;AAAA,MACT,CAAC;AAAA;AAAA;AAAA;AAAA,MAIH,MACEiB,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AAEjD,YAAI,CAAC8G,EAAU;AAEb,gBAAM,IAAI,MAAM,MAAM;AAGxB,cAAMmB,IACJjI,EAAM,UAAU,SAAS8G,EAAU,aAAa,YAAY,GACxDsB,IAAiBpI,EAAM,UAAU,OAEjCkH,IAAgBV;AAAA,UACpBxG,EAAM;AAAA,UACN8G,EAAU,QAAQ;AAAA,QAAA;AAGpB,YAAII,KAAiBe,KAAyBG,GAAgB;AAC5D,gBAAMO,IAAc9B;AAAA,YAClB7G,EAAM;AAAA,YACNkH;AAAA,UAAA;AAGF,cAAI,CAACyB,EAAY;AAEf,kBAAM,IAAI,MAAM,MAAM;AASxB,cALEA,EAAY,aAAa,KAAK,KAAK,KAAK,YAAY,MACnDA,EAAY,aAAa,KAAK,KAAK,KAAK,YACvC,aACAA,EAAY,aAAa,KAAK,eAAe;AAG/C,mBAAOb,IACJ;AAAA,cACC;AAAA,gBACE,MAAMhB,EAAU,QAAQ;AAAA,gBACxB,IAAIA,EAAU,QAAQ;AAAA,cAAA;AAAA,cAExB6B,EAAY,QAAQ;AAAA,YAAA,EAErB,YAAY;AAAA,cACX,MAAMA,EAAY,QAAQ;AAAA,cAC1B,IAAIA,EAAY,QAAQ;AAAA,YAAA,CACzB,EACA,IAAA;AAAA,QAEP;AAEA,eAAO;AAAA,MACT,CAAC;AAAA,IAAA,CACJ,GAEGC,IAAe,MACnB,KAAK,OAAO,SAAS,MAAM,CAAC,EAAE,UAAAb,QAAe;AAAA;AAAA,MAE3C,MAAMA,EAAS,gBAAA;AAAA;AAAA;AAAA;AAAA,MAIf,MACEA,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAE9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAET,cAAM;AAAA,UACJ,SAASzQ;AAAA,UACT,cAAAC;AAAA,UACA,gBAAAuS;AAAA,QAAA,IACE/B,GAEE,EAAE,OAAAgC,EAAA,IAAU9I,EAAM,IAAI,QAAQ3J,EAAe,SAAS,GACtD0S,IACJ1S,EAAe,aAAa2J,EAAM,IAAI,WAAW,GAC7CgJ,IACJhJ,EAAM,UAAU,SAAS1J,EAAa,WAAW,GAC7C8R,IAAiBpI,EAAM,UAAU;AAGvC,YACE,CAAC+I,KACDC,KACAZ,KACA,EANqBS,MAAmB,SAOxC;AACA,cAAII,IAAWH,GACX9B,IAAS3Q,EAAe,WAAW,GACnC6S,IAAWlJ,EAAM,IAAI,QAAQgH,CAAM,EAAE;AAEzC,iBAAOkC,IAAWD;AAChB,YAAAA,IAAWC,GACXlC,KAAU,GACVkC,IAAWlJ,EAAM,IAAI,QAAQgH,CAAM,EAAE;AAGvC,iBAAOe,EAAS,QAAQN,GAAmBT,IAAS,CAAC,CAAC;AAAA,QACxD;AAEA,eAAO;AAAA,MACT,CAAC;AAAA,IAAA,CACJ,GAEGmC,IAAc,CAACC,IAAY,OACxB,KAAK,OAAO,SAAS,MAAM,CAAC,EAAE,UAAArB,GAAU,IAAAhT,QAAS;AAAA;AAAA;AAAA,MAGtD,MACEgT,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAET,cAAM,EAAE,SAASzQ,GAAgB,cAAAC,EAAA,IAAiBwQ,GAE5C,EAAE,OAAAgC,EAAA,IAAU9I,EAAM,IAAI,QAAQ3J,EAAe,SAAS,GAEtD4R,IACJjI,EAAM,UAAU,QAAQ,iBAAiB,GACrCoI,IACJpI,EAAM,UAAU,WAAWA,EAAM,UAAU,MACvCqJ,IAAa/S,EAAa,KAAK,eAAe,GAC9CgT,IAAgBR,IAAQ;AAE9B,eACEb,KACAG,KACAiB,KACAC,IAEOvB,EAAS,aAAa,gBAAgB,IAGxC;AAAA,MACT,CAAC;AAAA;AAAA,MAEH,MACEA,EAAS,QAAQ,CAAC,EAAE,OAAA/H,QAAY;;AAC9B,cAAM8G,IAAYkB,EAA0BhI,CAAK,GAE3CuJ,MACJpV,IAAA,KAAK,QAAQ,OAAO,OAAO,YACzB2S,EAAU,aACZ,EAAE,SAFF,gBAAA3S,EAEQ,sBAAqB;AAE/B,YAAIoV,MAA2B;AAC7B,iBAAO;AAGT;AAAA;AAAA;AAAA,UAGGA,MAA2B,iBAAiBH;AAAA;AAAA,UAG7CG,MAA2B;AAAA,UAC3B;AACA,gBAAMC,IACJzU,EAAG,eACHA,EAAG,UAAU,MACV,QACA;AAAA,YAAO,CAAC0U,MACP,KAAK,OAAO,iBAAiB,gBAAgB;AAAA,cAC3CA,EAAE,KAAK;AAAA,YAAA;AAAA,UACT;AAGN,iBAAA1U,EAAG;AAAA,YACDA,EAAG,UAAU;AAAA,YACbA,EAAG,IAAI,KAAK,OAAO,MAAM,UAAU,OAAA;AAAA,UAAO,EAC1C,YAAYyU,CAAK,GACZ;AAAA,QACT;AAEA,eAAO;AAAA,MACT,CAAC;AAAA;AAAA;AAAA,MAGH,MACEzB,EAAS,QAAQ,CAAC,EAAE,OAAA/H,GAAO,UAAAqH,QAAe;AACxC,cAAMP,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAET,cAAM,EAAE,SAASzQ,GAAgB,cAAAC,EAAA,IAAiBwQ,GAE5CmB,IACJjI,EAAM,UAAU,QAAQ,iBAAiB,GACrCoI,IACJpI,EAAM,UAAU,WAAWA,EAAM,UAAU,MACvCqJ,IAAa/S,EAAa,KAAK,eAAe;AAEpD,YAAI2R,KAAyBG,KAAkBiB,GAAY;AACzD,gBAAMK,IAAuBrT,EAAe,UACtCsT,IAAqBD,IAAuB;AAElD,cAAIrC,GAAU;AACZ,kBAAMnF,IACJlC,EAAM,OAAO,MAAM,eAAkB,cAAA;AAEvC,YAAAA,EAAM,GACH,OAAO0J,GAAsBxH,CAAQ,EACrC,eAAA,GACHlC,EAAM,GAAG;AAAA,cACP,IAAIlF,EAAckF,EAAM,IAAI,QAAQ2J,CAAkB,CAAC;AAAA,YAAA;AAAA,UAE3D;AAEA,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,MACT,CAAC;AAAA;AAAA;AAAA,MAGH,MACE5B,EAAS,QAAQ,CAAC,EAAE,OAAA/H,GAAO,OAAA8H,QAAY;AACrC,cAAMhB,IAAYkB,EAA0BhI,CAAK;AACjD,YAAI,CAAC8G,EAAU;AACb,iBAAO;AAET,cAAM,EAAE,cAAAxQ,MAAiBwQ,GAEnBmB,IACJjI,EAAM,UAAU,QAAQ,iBAAiB;AAG3C,eAFmB1J,EAAa,KAAK,eAAe,IAiB7C,MAdLwR,EAAA,EACG,kBACA;AAAA,UACC8B;AAAA,YACE5J,EAAM,UAAU;AAAA,YAChBiI;AAAA,YACAA;AAAA,UAAA;AAAA,QACF,EAED,IAAA,GAEI;AAAA,MAIX,CAAC;AAAA,IAAA,CACJ;AAGH,WAAO;AAAA,MACL,WAAWJ;AAAA,MACX,QAAQe;AAAA,MACR,OAAO,MAAMO,EAAA;AAAA,MACb,eAAe,MAAMA,EAAY,EAAI;AAAA;AAAA;AAAA,MAGrC,KAAK,MAAM;;AACT,eACE,KAAK,QAAQ,gBAAgB,qBAC5BhV,IAAA,KAAK,QAAQ,OAAO,aAAa0V,CAA0B,MAA3D,QAAA1V,EAA8D,MAC5D,WACDsF,IAAA,KAAK,QAAQ,OAAO,aAAaqQ,CAAkB,MAAnD,gBAAArQ,EAAsD,MACnD,WAAU,UAIR,KAEFiD,GAAU,KAAK,QAAQ,MAAM;AAAA,MACtC;AAAA,MACA,aAAa,MAAM;;AACjB,eACE,KAAK,QAAQ,gBAAgB,qBAC5BvI,IAAA,KAAK,QAAQ,OAAO,aAAa0V,CAA0B,MAA3D,QAAA1V,EAA8D,MAC5D,WACDsF,IAAA,KAAK,QAAQ,OAAO,aAAaqQ,CAAkB,MAAnD,gBAAArQ,EAAsD,MACnD,WAAU,UAKR,KAEF,KAAK,OAAO,SAAS,aAAa,gBAAgB;AAAA,MAC3D;AAAA,MACA,qBAAqB,OACnB,KAAK,QAAQ,OAAO,aAAA,GACb;AAAA,MAET,uBAAuB,OACrB,KAAK,QAAQ,OAAO,eAAA,GACb;AAAA,MAET,SAAS,MAAM,KAAK,QAAQ,OAAO,KAAA;AAAA,MACnC,SAAS,MAAM,KAAK,QAAQ,OAAO,KAAA;AAAA,MACnC,eAAe,MAAM,KAAK,QAAQ,OAAO,KAAA;AAAA,IAAK;AAAA,EAElD;AACF,CAAC,GC5gBYsQ,KAAoBC,EAAK,OAAO;AAAA,EAC3C,MAAM;AAAA,EACN,WAAW;AAAA,EACX,UAAU;AAAA,EACV,gBAAgB;AACd,WAAO;AAAA,MACL,IAAI,EAAE,SAAS,MAAM,UAAU,SAAA;AAAA;AAAA,IAAS;AAAA,EAE5C;AAAA,EACA,iBAAiBC,GAAW;AAC1B,WAAIA,EAAU,SAAS,cACd,CAAA,IAEF;AAAA,MACL,iBAAiB;AAAA,MACjB,WAAW;AAAA,MAEX,MAAMvR,GAAMwR,GAAQ;AAClB,eAAO;AAAA,UACL;AAAA,UACA;AAAA,YACE,WAAW,OAAOxR,EAAK,MAAM,EAAK;AAAA,YAClC,eAAe,OAAOwR,CAAM;AAAA,YAC5B,GAAI,CAACA,KAAU,EAAE,OAAO,oBAAA;AAAA;AAAA,UAAoB;AAAA,UAE9C;AAAA,QAAA;AAAA,MAEJ;AAAA,MACA,UAAU;AAAA,QACR;AAAA,UACE,KAAK;AAAA,UACL,SAASrW,GAAM;AACb,mBAAKA,EAAK,QAAQ,KAGX;AAAA,cACL,IAAI,SAASA,EAAK,QAAQ,IAAO,EAAE;AAAA,YAAA,IAH5B;AAAA,UAKX;AAAA,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EAEJ;AACF,CAAC,GAEYsW,KAAuBH,EAAK,OAAO;AAAA,EAC9C,MAAM;AAAA,EACN,WAAW;AAAA,EACX,UAAU;AAAA,EACV,gBAAgB;AACd,WAAO;AAAA,MACL,IAAI,EAAE,SAAS,MAAM,UAAU,SAAA;AAAA;AAAA,IAAS;AAAA,EAE5C;AAAA,EACA,iBAAiBC,GAAW;AAC1B,WAAIA,EAAU,SAAS,aACd,CAAA,IAEF;AAAA,MACL,iBAAiB;AAAA,MACjB,WAAW;AAAA;AAAA;AAAA;AAAA,MAKX,MAAMvR,GAAMwR,GAAQ;AAClB,eAAO;AAAA,UACL;AAAA,UACA;AAAA,YACE,WAAW,OAAOxR,EAAK,MAAM,EAAK;AAAA,YAClC,eAAe,OAAOwR,CAAM;AAAA,YAC5B,GAAI,CAACA,KAAU,EAAE,OAAO,oBAAA;AAAA;AAAA,UAAoB;AAAA,UAE9C;AAAA,QAAA;AAAA,MAEJ;AAAA,MACA,UAAU;AAAA,QACR;AAAA,UACE,KAAK;AAAA,UACL,SAASrW,GAAM;AACb,mBAAKA,EAAK,QAAQ,KAGX;AAAA,cACL,IAAI,SAASA,EAAK,QAAQ,IAAO,EAAE;AAAA,YAAA,IAH5B;AAAA,UAKX;AAAA,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EAEJ;AACF,CAAC,GAEYuW,KAA6BJ,EAAK,OAAO;AAAA,EACpD,MAAM;AAAA,EACN,WAAW;AAAA,EACX,UAAU;AAAA,EACV,gBAAgB;AAEd,WAAO;AAAA,MACL,IAAI,EAAE,SAAS,MAAM,UAAU,SAAA;AAAA,MAC/B,MAAM,EAAE,UAAU,SAAA;AAAA,MAClB,UAAU,EAAE,SAAS,MAAM,UAAU,cAAA;AAAA,MACrC,eAAe,EAAE,SAAS,KAAA;AAAA,MAC1B,UAAU,EAAE,SAAS,KAAA;AAAA,IAAK;AAAA,EAE9B;AAAA,EACA,iBAAiBC,GAAW;AAC1B,WAAIA,EAAU,SAAS,iBACd,CAAA,IAEF;AAAA,MACL,iBAAiB;AAAA,MACjB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQX,MAAMvR,GAAMwR,GAAQ;AAClB,eAAO;AAAA,UACLA,IAAS,SAAS;AAAA,UAClB;AAAA,YACE,aAAa;AAAA,YACb,WAAW,OAAOxR,EAAK,MAAM,EAAK;AAAA,YAClC,iBAAiBA,EAAK,MAAM;AAAA,YAC5B,qBAAqB,KAAK,UAAUA,EAAK,MAAM,aAAgB;AAAA;AAAA,YAE/D,oBAAoB,KAAK,UAAUA,EAAK,MAAM,QAAW;AAAA,UAAA;AAAA,UAE3D;AAAA,QAAA;AAAA,MAEJ;AAAA,MACA,UAAU;AAAA,QACR;AAAA,UACE,KAAK;AAAA,UACL,SAAS7E,GAAM;AACb,mBAAKA,EAAK,QAAQ,KAGX;AAAA,cACL,IAAI,SAASA,EAAK,QAAQ,IAAO,EAAE;AAAA,cACnC,MAAMA,EAAK,QAAQ;AAAA,cACnB,eAAeA,EAAK,QAAQ;AAAA,cAC5B,UAAUA,EAAK,QAAQ;AAAA,YAAW,IAN3B;AAAA,UAQX;AAAA,QAAA;AAAA,QAEF;AAAA,UACE,KAAK;AAAA,UACL,SAASA,GAAM;AACb,mBAAKA,EAAK,QAAQ,KAGX;AAAA,cACL,IAAI,SAASA,EAAK,QAAQ,IAAO,EAAE;AAAA,cACnC,MAAMA,EAAK,QAAQ;AAAA,cACnB,eAAeA,EAAK,QAAQ;AAAA,YAAY,IALjC;AAAA,UAOX;AAAA,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EAEJ;AACF,CAAC,GC5KYwW,KAAyB/G,EAAU,OAAO;AAAA,EACrD,MAAM;AAAA,EAEN,sBAAsB;AACpB,WAAO;AAAA,MACL;AAAA;AAAA;AAAA;AAAA;AAAA,QAKE,OAAO,CAAC,aAAa,aAAa;AAAA,QAClC,YAAY;AAAA,UACV,eAAe;AAAA,YACb,SAAS;AAAA,YACT,WAAW,CAAC3P,MACHA,EAAQ,aAAa,qBAAqB;AAAA,YAEnD,YAAY,CAAC2W,MACPA,EAAW,kBAAkB,SACxB,CAAA,IAEF;AAAA,cACL,uBAAuBA,EAAW;AAAA,YAAA;AAAA,UAEtC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EAEJ;AACF,CAAC,GC7BYC,KAAqBjH,EAAU,OAAO;AAAA,EACjD,MAAM;AAAA,EAEN,sBAAsB;AACpB,WAAO;AAAA,MACL;AAAA,QACE,OAAO,CAAC,SAAS,aAAa,aAAa;AAAA,QAC3C,YAAY;AAAA,UACV,WAAWkH,GAAA;AAAA,QAAsB;AAAA,MACnC;AAAA,IACF;AAAA,EAEJ;AACF,CAAC,GCTKC,KAA0C;AAAA,EAC9C,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,aAAa;AACf,GAKaC,KAAiBxW,EAAK,OAGhC;AAAA,EACD,MAAM;AAAA,EACN,OAAO;AAAA;AAAA,EAEP,SAAS;AAAA;AAAA,EAET,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,YAAY;AACV,WAAO;AAAA,MACL;AAAA,QACE,KAAK,wBAAwB,KAAK,OAAO;AAAA,QACzC,UAAU,CAACP,MAAY;AACrB,cAAI,OAAOA,KAAY;AACrB,mBAAO;AAGT,gBAAMgX,IAAgC,CAAA;AACtC,qBAAW,CAACC,GAAUC,CAAQ,KAAK,OAAO,QAAQJ,EAAe;AAC/D,YAAI9W,EAAQ,aAAakX,CAAQ,MAC/BF,EAAMC,CAAQ,IAAIjX,EAAQ,aAAakX,CAAQ;AAInD,iBAAOF;AAAA,QACT;AAAA,MAAA;AAAA;AAAA,MAGF;AAAA,QACE,KAAK;AAAA,QACL,MAAM;AAAA,MAAA;AAAA,IACR;AAAA,EAEJ;AAAA,EAEA,WAAW,EAAE,gBAAArE,KAAkB;;AAC7B,UAAMwE,IAAa,SAAS,cAAc,KAAK;AAC/C,IAAAA,EAAW,YAAY,kBACvBA,EAAW,aAAa,kBAAkB,YAAY;AACtD,eAAW,CAACC,GAAW9K,CAAK,KAAK,OAAO,QAAQqG,CAAc;AAC5D,MAAIyE,MAAc,WAChBD,EAAW,aAAaC,GAAW9K,CAAK;AAI5C,UAAM+K,IAAsB;AAAA,MAC1B,KAAI7W,IAAA,KAAK,QAAQ,kBAAb,gBAAAA,EAA4B,UAAS,CAAA;AAAA,MACzC,GAAGmS;AAAA,IAAA,GAEC3Q,IAAQ,SAAS,cAAc,KAAK;AAC1C,IAAAA,EAAM,YAAYsV,EAAgB,YAAYD,EAAoB,KAAK,GACvErV,EAAM,aAAa,kBAAkB,KAAK,IAAI;AAC9C,eAAW,CAACoV,GAAW9K,CAAK,KAAK,OAAO,QAAQ+K,CAAmB;AACjE,MAAID,MAAc,WAChBpV,EAAM,aAAaoV,GAAW9K,CAAK;AAIvC,WAAA6K,EAAW,YAAYnV,CAAK,GAErB;AAAA,MACL,KAAKmV;AAAA,MACL,YAAYnV;AAAA,IAAA;AAAA,EAEhB;AACF,CAAC,GCnFYuV,KAAahX,EAAK,OAE5B;AAAA,EACD,MAAM;AAAA,EACN,OAAO;AAAA,EACP,SAAS;AAAA,EACT,OAAO;AAAA,EACP,YAAY;AACV,WAAO;AAAA,MACL;AAAA,QACE,KAAK;AAAA,QACL,UAAU,CAACP,MACL,OAAOA,KAAY,WACd,KAGLA,EAAQ,aAAa,gBAAgB,MAAM,eAEtC,OAGF;AAAA,MACT;AAAA,IACF;AAAA,EAEJ;AAAA,EAEA,WAAW,EAAE,gBAAA2S,KAAkB;;AAC7B,UAAM6E,IAA2B;AAAA,MAC/B,KAAIhX,IAAA,KAAK,QAAQ,kBAAb,gBAAAA,EAA4B,eAAc,CAAA;AAAA,MAC9C,GAAGmS;AAAA,IAAA,GAEChH,IAAa,SAAS,cAAc,KAAK;AAC/C,IAAAA,EAAW,YAAY2L;AAAA,MACrB;AAAA,MACAE,EAAyB;AAAA,IAAA,GAE3B7L,EAAW,aAAa,kBAAkB,YAAY;AACtD,eAAW,CAACyL,GAAW9K,CAAK,KAAK,OAAO,QAAQkL,CAAwB;AACtE,MAAIJ,MAAc,WAChBzL,EAAW,aAAayL,GAAW9K,CAAK;AAI5C,WAAO;AAAA,MACL,KAAKX;AAAA,MACL,YAAYA;AAAA,IAAA;AAAA,EAEhB;AACF,CAAC,GCnDY8L,KAAMlX,EAAK,OAAO;AAAA,EAC7B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,OAAO;AACT,CAAC,GCkCYmX,KAAyBC;AAAA,EACpC,CAAC,EAAE,SAAAnT,EAAA,OACM;AAAA,IACL,KAAK;AAAA,IACL,qBAAqB;AAAA,MACnBoT,GAAkBpT,CAAO;AAAA,MACzBqT,GAAiBrT,CAAO;AAAA,MACxBsT,GAAetT,CAAO;AAAA,MACtBuT,GAAA;AAAA,MACAC,GAAgBxT,CAAO;AAAA,IAAA;AAAA,EACzB;AAGN;ACFA,IAAIyT,KAAsB;AAKnB,SAASC,GACdvX,GACA6D,GACA;AACA,QAAM2T,IAAyC;AAAA,IAC7CC,EAAW;AAAA,IACXA,EAAW;AAAA,IACXA,EAAW;AAAA,IACXA,EAAW;AAAA,IACXA,EAAW;AAAA,IACXC;AAAA,IAEAC,GAAS,UAAU;AAAA;AAAA,MAEjB,OAAO,CAAC,kBAAkB,cAAc,QAAQ;AAAA,MAChD,gBAAgB9T,EAAQ;AAAA,IAAA,CACzB;AAAA,IACDkO;AAAA,IACA6F;AAAA;AAAA,IAGAnC;AAAA,IACAI;AAAA,IACAC;AAAA,IACA+B,GAAK,OAAO;AAAA,MACV,WAAW;AAAA,IAAA,CACZ,EAAE,UAAU;AAAA,MACX,iBAAiBC;AAAA;AAAA,MAEjB,WAAWR,KAAsB,KAAKS;AAAA,IAAA,CACvC;AAAA,IACD,GAAI,OAAO,OAAO/X,EAAO,OAAO,UAAU,EAAE,IAAI,CAACgY,MACxCA,EAAU,eAAe,KAAK,UAAU;AAAA,MAC7C,QAAAhY;AAAA,IAAA,CACD,CACF;AAAA,IAEDiW;AAAA,IAEApE;AAAA,IACAkE;AAAA;AAAA,IAGAkC,EAAgB,OAAO;AAAA,MACrB,MAAM;AAAA,MACN,sBAAsB,OACb;AAAA,QACL,QAAQ,MAAM;;AACZ,kBAAIpY,IAAAG,EAAO,aAAakY,EAAc,MAAlC,QAAArY,EAAqC,UAEhC,MAETG,EAAO,KAAA,GACA;AAAA,QACT;AAAA,MAAA;AAAA,IAEJ,CACD;AAAA;AAAA,IAGD8W;AAAA,IACAV,GAAe,UAAU;AAAA,MACvB,QAAApW;AAAA,MACA,eAAe6D,EAAQ;AAAA,IAAA,CACxB;AAAA,IACDyP,GAA2B,UAAU;AAAA,MACnC,QAAAtT;AAAA,MACA,aAAa6D,EAAQ;AAAA,IAAA,CACtB;AAAA,IACD+S,GAAW,UAAU;AAAA,MACnB,eAAe/S,EAAQ;AAAA,IAAA,CACxB;AAAA,IACD,GAAG,OAAO,OAAO7D,EAAO,OAAO,kBAAkB,EAC9C,OAAO,CAACmY,MAAMA,EAAE,WAAW,UAAUA,EAAE,WAAW,MAAM,EACxD,IAAI,CAACC,MACGA,EAAkB,eAAgB,KAAK,UAAU;AAAA,MACtD,QAAApY;AAAA,IAAA,CACD,CACF;AAAA,IAEH,GAAG,OAAO,OAAOA,EAAO,OAAO,UAAU,EAAE,QAAQ,CAACqO,MAC3C;AAAA;AAAA,MAEL,GAAI,UAAUA,EAAU,iBACpB;AAAA,QACGA,EAAU,eAAe,KAAc,UAAU;AAAA,UAChD,QAAArO;AAAA,UACA,eAAe6D,EAAQ;AAAA,QAAA,CACxB;AAAA,MAAA,IAEH,CAAA;AAAA,IAAC,CAER;AAAA,IACD+N,GAA+B5R,CAAM;AAAA,IACrCyQ;AAAA,MACEzQ;AAAA,MACA6D,EAAQ,iBACL,CAACwU,MAKIA,EAAQ,oBAAA;AAAA,IAAoB;AAAA,IAEtCtJ,GAAwB/O,CAAM;AAAA,EAAA;AAGhC,SAAAsX,KAAsB,IAEfE;AACT;AAEO,SAASc,GACdtY,GACA6D,GACA;AACA,QAAM4T,IAAa;AAAA,IACjBc,GAAA;AAAA,IACAC,GAAoB3U,CAAO;AAAA,IAC3B2R,EAAmB3R,CAAO;AAAA,IAC1B0R,EAA2B1R,CAAO;AAAA,IAClC4U,GAAqB5U,CAAO;AAAA,IAC5B6U,GAAA;AAAA,IACAC,GAAqB9U,CAAO;AAAA,IAC5B+U,GAAuB/U,CAAO;AAAA,IAC9BgV,GAAkBhV,CAAO;AAAA,IACzBqU,GAAerU,CAAO;AAAA,IACtB,GAAIA,EAAQ,kBAAkB,KAAQ,CAACiV,GAAA,CAAuB,IAAI,CAAA;AAAA,EAAC;AAGrE,SAAIjV,EAAQ,gBACV4T,EAAW,KAAKV,GAAuBlT,EAAQ,aAAa,CAAC,IAG7D4T,EAAW,KAAKsB,IAAkB,GAGhC,WAAW/Y,EAAO,OAAO,cAC3ByX,EAAW,KAAKuB,GAAsBnV,CAAO,CAAC,GAG5CA,EAAQ,eAAe,MACzB4T,EAAW,KAAKwB,IAA4B,GAGvCxB;AACT;AC/KO,MAAMyB,GAAiB;AAAA,EAuB5B,YACUlZ,GACA6D,GACR;AAtBM;AAAA;AAAA;AAAA,IAAAsV,EAAA,gDAAyB,IAAA;AAIzB;AAAA;AAAA;AAAA,IAAAA,EAAA,oBAA0B,CAAA;AAI1B;AAAA;AAAA;AAAA,IAAAA,EAAA,sCAAe,IAAA;AAIf;AAAA;AAAA;AAAA,IAAAA,EAAA,gDAAyB,IAAA;AAKzB;AAAA;AAAA;AAAA;AAAA,IAAAA,EAAA,8CAAiD,IAAA;AAG/C,SAAA,SAAAnZ,GACA,KAAA,UAAA6D,GAKR7D,EAAO,QAAQ,MAAM;AACnB,iBAAW2V,KAAa,KAAK;AAE3B,YAAIA,EAAU,OAAO;AAEnB,gBAAMyD,IAAkB,IAAI,OAAO,gBAAA,GAC7BC,IAAkB1D,EAAU,MAAM;AAAA,YACtC,KAAK3V,EAAO,gBAAgB;AAAA,YAC5B,MAAMA,EAAO,gBAAgB;AAAA,YAC7B,QAAQoZ,EAAgB;AAAA,UAAA,CACzB;AAED,UAAIC,KACFD,EAAgB,OAAO,iBAAiB,SAAS,MAAM;AACrD,YAAAC,EAAA;AAAA,UACF,CAAC,GAGH,KAAK,SAAS,IAAI1D,GAAWyD,CAAe;AAAA,QAC9C;AAAA,IAEJ,CAAC,GAKDpZ,EAAO,UAAU,MAAM;AACrB,iBAAW,CAAC2V,GAAWyD,CAAe,KAAK,KAAK,SAAS;AAEvD,aAAK,SAAS,OAAOzD,CAAS,GAE9ByD,EAAgB,MAAA;AAAA,IAEpB,CAAC,GAGD,KAAK,qBAAqB,IAAI,IAAIvV,EAAQ,qBAAqB,CAAA,CAAE;AAGjE,eAAW8R,KAAa2C,GAAqB,KAAK,QAAQ,KAAK,OAAO;AACpE,WAAK,aAAa3C,CAAS;AAI7B,eAAWA,KAAa,KAAK,QAAQ,cAAc,CAAA;AACjD,WAAK,aAAaA,CAAS;AAI7B,eAAWtU,KAAS,OAAO,OAAO,KAAK,OAAO,OAAO,UAAU;AAC7D,iBAAWsU,KAAatU,EAAM,cAAc,CAAA;AAC1C,aAAK,aAAasU,CAAS;AAAA,EAGjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,kBACLA,GAIM;;AACN,UAAM8B,IAAc,CAAA,EACjB,OAAO9B,CAAS,EAChB,OAAO,OAAO;AAEjB,QAAI,CAAC8B,EAAW,QAAQ;AAEtB,cAAQ,KAAK,mCAAmC9B,CAAS;AACzD;AAAA,IACF;AAEA,UAAM2D,IAAuB7B,EAC1B,IAAI,CAAC9B,MAAc,KAAK,aAAaA,CAAS,CAAC,EAC/C,OAAO,OAAO,GAEX4D,wBAAmB,IAAA;AACzB,eAAW5D,KAAa2D;AACtB,MAAI3D,KAAAA,QAAAA,EAAW,oBAKb,QAAQ;AAAA,QACN,aAAaA,EAAU,GAAG;AAAA,QAC1BA;AAAAA,MAAA,IAIAA,IAAAA,KAAAA,gBAAAA,EAAW,eAAXA,QAAAA,EAAuB,UAGzB,QAAQ;AAAA,QACN,aAAaA,EAAU,GAAG;AAAA,QAC1BA;AAAAA,MAAA,GAIJ,KAAK,mCAAmCA,CAAS,EAAE,QAAQ;AAAA,QACzD,CAAC6D,MAAW;AACV,UAAAD,EAAa,IAAIC,CAAM;AAAA,QACzB;AAAA,MAAA;AAMJ,SAAK,cAAc,CAACC,MAAY,CAAC,GAAGA,GAAS,GAAGF,CAAY,CAAC;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,aACN5D,GACuB;AACvB,QAAI+D;AAOJ,QANI,OAAO/D,KAAc,aACvB+D,IAAW/D,EAAU,EAAE,QAAQ,KAAK,QAAQ,IAE5C+D,IAAW/D,GAGT,GAAC+D,KAAY,KAAK,mBAAmB,IAAIA,EAAS,GAAG,IAKzD;AAAA,UAAI,OAAO/D,KAAc,YAAY;AACnC,cAAMgE,IAAmBD,EAAiBE,EAAqB;AAI/D,QAAI,OAAOD,KAAoB,cAC7B,KAAK,mBAAmB,IAAIA,GAAiBD,CAAQ;AAAA,MAEzD;AAIA,UAFA,KAAK,WAAW,KAAKA,CAAQ,GAEzBA,EAAS;AACX,mBAAW/D,KAAa+D,EAAS;AAC/B,eAAK,aAAa/D,CAAS;AAI/B,aAAO+D;AAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,kBACNG,GAMa;AACb,UAAMpC,IAAa,CAAA;AACnB,QAAI,OAAOoC,KAAc,YAAY;AACnC,YAAMH,IAAW,KAAK,mBAAmB,IAAIG,CAAS;AACtD,MAAIH,KACFjC,EAAW,KAAKiC,CAAQ;AAAA,IAE5B,WAAW,MAAM,QAAQG,CAAS;AAChC,iBAAWlE,KAAakE;AACtB,QAAApC,EAAW,KAAK,GAAG,KAAK,kBAAkB9B,CAAS,CAAC;AAAA,aAE7C,OAAOkE,KAAc,YAAY,SAASA;AACnD,MAAApC,EAAW,KAAKoC,CAAS;AAAA,aAChB,OAAOA,KAAc,UAAU;AACxC,YAAMH,IAAW,KAAK,WAAW,KAAK,CAACtP,MAAMA,EAAE,QAAQyP,CAAS;AAChE,MAAIH,KACFjC,EAAW,KAAKiC,CAAQ;AAAA,IAE5B;AACA,WAAOjC;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,oBACLqC,GAMM;;AACN,UAAMrC,IAAa,KAAK,kBAAkBqC,CAAY;AAEtD,QAAI,CAACrC,EAAW,QAAQ;AAEtB,cAAQ,KAAK,qCAAqCqC,CAAY;AAC9D;AAAA,IACF;AACA,QAAIC,IAAU;AAEd,UAAMC,wBAAsB,IAAA;AAC5B,eAAWrE,KAAa8B,GAAY;AAClC,WAAK,aAAa,KAAK,WAAW,OAAO,CAACrN,MAAMA,MAAMuL,CAAS,GAC/D,KAAK,mBAAmB,QAAQ,CAAC+D,GAAUO,MAAY;AACrD,QAAIP,MAAa/D,KACf,KAAK,mBAAmB,OAAOsE,CAAO;AAAA,MAE1C,CAAC,IACDpa,IAAA,KAAK,SAAS,IAAI8V,CAAS,MAA3B,QAAA9V,EAA8B,SAC9B,KAAK,SAAS,OAAO8V,CAAS;AAE9B,YAAM8D,IAAU,KAAK,iBAAiB,IAAI9D,CAAS;AACnD,MAAA8D,KAAA,QAAAA,EAAS,QAAQ,CAACD,MAAW;AAC3B,QAAAQ,EAAgB,IAAIR,CAAM;AAAA,MAC5B,IACA,KAAK,iBAAiB,OAAO7D,CAAS,GAElCA,EAAU,oBAAoB,CAACoE,MACjCA,IAAU,IAEV,QAAQ;AAAA,QACN,aAAapE,EAAU,GAAG;AAAA,QAC1BmE;AAAA,MAAA;AAAA,IAGN;AAEA,SAAK;AAAA,MAAc,CAACL,MAClBA,EAAQ,OAAO,CAACD,MAAW,CAACQ,EAAgB,IAAIR,CAAM,CAAC;AAAA,IAAA;AAAA,EAE3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,cAAcnZ,GAA+C;AACnE,UAAM6Z,IAAe,KAAK,OAAO,kBAE3BxO,IAAQwO,EAAa,YAAY;AAAA,MACrC,SAAS7Z,EAAO6Z,EAAa,QAAQ,OAAO;AAAA,IAAA,CAC7C;AAED,SAAK,OAAO,gBAAgB,YAAYxO,CAAK;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKO,sBAA4C;;AAEjD,UAAM8L,IAAmBD;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,IAAA,EACL,OAAO,CAAC5B,MAAc,CAAC,KAAK,mBAAmB,IAAIA,EAAU,IAAI,CAAC,GAE9DwE,IAAcC,GAAmB,KAAK,UAAU,GAEhDC,wBAA2B,IAAA;AACjC,eAAW1E,KAAa,KAAK,YAAY;AACvC,MAAIA,EAAU,oBACZ6B,EAAiB,KAAK,GAAG7B,EAAU,gBAAgB;AAGrD,YAAM2E,IAAWH,EAAYxE,EAAU,GAAG,GAEpC,EAAE,SAAS4E,GAAoB,YAAAC,MACnC,KAAK,mCAAmC7E,CAAS;AAEnD,MAAI4E,EAAmB,UACrB/C,EAAiB;AAAA,QACfS,EAAgB,OAAO;AAAA,UACrB,MAAMtC,EAAU;AAAA,UAChB,UAAA2E;AAAA,UACA,uBAAuB,MAAMC;AAAA,QAAA,CAC9B;AAAA,MAAA,GAGDC,EAAW,WACRH,EAAqB,IAAIC,CAAQ,KACpCD,EAAqB,IAAIC,GAAU,EAAE,GAEvCD,EAAqB,IAAIC,CAAQ,EAAG,KAAK,GAAGE,CAAU;AAAA,IAE1D;AAGA,IAAAhD,EAAiB;AAAA,MACfS,EAAgB,OAAO;AAAA,QACrB,MAAM;AAAA,QACN,wBAAwB;AACtB,gBAAM7Y,IAAQ,CAAA;AACd,uBAAM,KAAKib,EAAqB,MAAM,EAEnC,KAAA,EACA,QAAA,EACA,QAAQ,CAACC,MAAa;AAErB,YAAAlb,EAAM,KAAK,GAAGib,EAAqB,IAAIC,CAAQ,CAAE;AAAA,UACnD,CAAC,GACI,CAACG,GAAiB,EAAE,OAAArb,EAAA,CAAO,CAAC;AAAA,QACrC;AAAA,MAAA,CACD;AAAA,IAAA;AAIH,eAAWuW,OAAa9V,IAAA,KAAK,QAAQ,mBAAb,gBAAAA,EAA6B,eAAc;AACjE,MAAA2X,EAAiB,KAAK7B,CAAS;AAGjC,WAAO6B;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,mCAAmC7B,GAGzC;;AACA,UAAM8D,IAAoB,CAAC,GAAI9D,EAAU,sBAAsB,CAAA,CAAG,GAC5D6E,IAA0B,CAAA;AAChC,WACE,GAAC3a,IAAA8V,EAAU,uBAAV,QAAA9V,EAA8B,WAC/B,CAAC,OAAO,KAAK8V,EAAU,qBAAqB,CAAA,CAAE,EAAE,UAChD,GAACxQ,IAAAwQ,EAAU,eAAV,QAAAxQ,EAAsB,UAGhB,EAAE,SAAAsU,GAAS,YAAAe,EAAA,KAGpB,KAAK,iBAAiB,IAAI7E,GAAW8D,CAAO,IAExCvU,IAAAyQ,EAAU,eAAV,QAAAzQ,EAAsB,UACxBsV,EAAW;AAAA,MACT,GAAG7E,EAAU,WAAW,IAAI,CAAC+E,MACpB,IAAIC,GAAUD,EAAU,MAAM,CAAChP,GAAOkP,GAAOC,GAAOC,MAAQ;AACjE,cAAMC,IAAcL,EAAU,QAAQ;AAAA,UACpC,OAAAE;AAAA,UACA,OAAO,EAAE,MAAMC,GAAO,IAAIC,EAAA;AAAA,UAC1B,QAAQ,KAAK;AAAA,QAAA,CACd;AACD,YAAIC,GAAa;AACf,gBAAMC,IAAiB,KAAK,OAAO,sBAAA;AAEnC,cACE,KAAK,OAAO,OAAO,YAAYA,EAAe,MAAM,IAAI,EACrD,YAAY;AAEf,mBAAO;AAGT,gBAAMxI,IAAYjK,EAA4BmD,EAAM,EAAE,GAChDjL,IAAKiL,EAAM,GAAG,YAAYmP,GAAOC,CAAG;AAE1C,iBAAAG,GAAcxa,GAAI+R,EAAU,QAAQ,WAAWuI,CAAW,GACnDta;AAAA,QACT;AACA,eAAO;AAAA,MACT,CAAC,CACF;AAAA,IAAA,GAID,OAAO,KAAKkV,EAAU,qBAAqB,CAAA,CAAE,EAAE,UACjD8D,EAAQ;AAAA,MACNyB;AAAA,QACE,OAAO;AAAA,UACL,OAAO,QAAQvF,EAAU,iBAAkB,EAAE,IAAI,CAAC,CAACwF,GAAKxP,CAAK,MAAM;AAAA,YACjEwP;AAAA,YACA,MAAMxP,EAAM,EAAE,QAAQ,KAAK,QAAQ;AAAA,UAAA,CACpC;AAAA,QAAA;AAAA,MACH;AAAA,IACF,GAIG,EAAE,SAAA8N,GAAS,YAAAe,EAAA;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKO,gBAAwC;AAC7C,WAAO,IAAI;AAAA,MACT,KAAK,WAAW,IAAI,CAAC7E,MAAc,CAACA,EAAU,KAAKA,CAAS,CAAC;AAAA,IAAA;AAAA,EAEjE;AAAA,EAmBO,aACLA,GAOY;AACZ,QAAI,OAAOA,KAAc,UAAU;AACjC,YAAM+D,IAAW,KAAK,WAAW,KAAK,CAACtP,MAAMA,EAAE,QAAQuL,CAAS;AAChE,aAAK+D,KACH;AAAA,IAGJ,WAAW,OAAO/D,KAAc,YAAY;AAC1C,YAAM+D,IAAW,KAAK,mBAAmB,IAAI/D,CAAS;AACtD,aAAK+D,KACH;AAAA,IAGJ;AACA,UAAM,IAAI,MAAM,2BAA2B,OAAO/D,CAAS,EAAE;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKO,aAAawF,GAAqD;AACvE,WAAI,OAAOA,KAAQ,WACV,KAAK,WAAW,KAAK,CAAC/Q,MAAMA,EAAE,QAAQ+Q,CAAG,IACvC,OAAOA,KAAQ,YAAY,SAASA,IACtC,KAAK,WAAW,KAAK,CAAC/Q,MAAMA,EAAE,QAAQ+Q,EAAI,GAAG,IAC3C,OAAOA,KAAQ,aACjB,KAAK,mBAAmB,IAAIA,CAAG,IAEjC;AAAA,EACT;AACF;ACjgBO,SAASC,GACd1S,GACAd,GACA;AACA,MAAI,EAAE,OAAAF,GAAO,KAAAC,EAAA,IAAQC;AAIrB,MAAIF,EAAM,MAAMA,EAAM,MAAA,KAAWA,EAAM,MAAMgB,EAAI,QAAQ,MAAM;AAC7D,UAAM2S,IAAiB3S,EAAI,YAAYhB,EAAM,KAAKA,EAAM,MAAM,CAAC;AAC/D,QAAI,eAAe,KAAK2T,CAAc,GAAG;AAEvC,YAAMC,IADa5S,EAAI,YAAYhB,EAAM,MAAA,GAASA,EAAM,GAAG,EAC9B,MAAM,cAAc;AACjD,MAAI4T,MACF5T,IAAQgB,EAAI,QAAQhB,EAAM,MAAM4T,EAAU,CAAC,EAAE,MAAM;AAAA,IAEvD;AAAA,EACF;AAIA,MAAI3T,EAAI,MAAMA,EAAI,SAASA,EAAI,MAAM,GAAG;AACtC,UAAM4T,IAAgB7S,EAAI,YAAYf,EAAI,MAAM,GAAGA,EAAI,GAAG;AAC1D,QAAI,eAAe,KAAK4T,CAAa,GAAG;AAEtC,YAAMD,IADY5S,EAAI,YAAYf,EAAI,KAAKA,EAAI,KAAK,EACxB,MAAM,cAAc;AAChD,MAAI2T,MACF3T,IAAMe,EAAI,QAAQf,EAAI,MAAM2T,EAAU,CAAC,EAAE,MAAM;AAAA,IAEnD;AAAA,EACF;AACA,SAAO,EAAE,OAAA5T,GAAO,KAAAC,GAAK,MAAMD,EAAM,KAAK,IAAIC,EAAI,IAAA;AAChD;AClBO,SAAS6T,GAId/a,GAAuD;AACvD,QAAMS,IAAWC,EAAYV,CAAE;AAE/B,MAAIA,EAAG,UAAU,SAAS,UAAUA,EAAG;AACrC;AAGF,QAAMgb,IAAuBhb,EAAG,IAAI;AAAA,IAClCsF,EAAmBtF,EAAG,KAAKA,EAAG,UAAU,IAAI,EAAE;AAAA,EAAA,GAE1Cib,IAAqBjb,EAAG,IAAI;AAAA,IAChCsF,EAAmBtF,EAAG,KAAKA,EAAG,UAAU,EAAE,EAAE;AAAA,EAAA,GAMxCkb,IAAe,CACnBlR,GACA+J,MACyB;AACzB,UAAMhU,IAAMib,EAAqB,WAAWhR,GAAO+J,CAAK,GAClDjV,IAAOkB,EAAG,IAAI,QAAQD,CAAG,EAAE;AAEjC,QAAI,CAACjB;AACH,YAAM,IAAI;AAAA,QACR,wDAAwDiB,CAAG;AAAA,MAAA;AAI/D,WAAOoB,EAAYrC,GAAM2B,CAAQ;AAAA,EACnC,GAEMqE,IAAiC,CAAA,GAEjCqW,IAAcH,EAAqB,YAAYC,EAAmB,GAAG,GACrE7T,IAAa4T,EAAqB,MAAMG,CAAW,GACnDC,IAAWH,EAAmB,MAAME,CAAW;AAgCrD,MAAIH,EAAqB,QAAQG,GAAa;AAE5C,IAAArW,EAAO,KAAK3D,EAAY6Z,EAAqB,WAAYva,CAAQ,CAAC;AAIlE,aAASsT,IAAQiH,EAAqB,OAAOjH,IAAQoH,GAAapH;AAGhE,UAFmBiH,EAAqB,KAAKjH,CAAK,EAEnC,KAAK,UAAU,gBAAgB,GAAG;AAC/C,cAAMsH,IAAoBL,EAAqB,MAAMjH,CAAK,IAAI,GACxDuH,IAAoBN,EAAqB,KAAKjH,CAAK,EAAE;AAI3D,iBAASxD,IAAI8K,GAAmB9K,IAAI+K,GAAmB/K;AACrD,UAAAzL,EAAO,KAAKoW,EAAa3K,GAAGwD,CAAK,CAAC;AAAA,MAEtC;AAAA,EAEJ;AAEE,IAAAjP,EAAO,KAAKoW,EAAa9T,GAAY+T,CAAW,CAAC;AAKnD,WAAS5K,IAAInJ,IAAa,GAAGmJ,KAAK6K,GAAU7K;AAC1C,IAAAzL,EAAO,KAAKoW,EAAa3K,GAAG4K,CAAW,CAAC;AAG1C,MAAIrW,EAAO,WAAW;AACpB,UAAM,IAAI;AAAA,MACR,gEAAgE9E,EAAG,SAAS;AAAA,IAAA;AAIhF,SAAO;AAAA,IACL,QAAA8E;AAAA,EAAA;AAEJ;AAEO,SAASyW,GACdvb,GACAwb,GACAC,GACA;AACA,QAAMC,IACJ,OAAOF,KAAe,WAAWA,IAAaA,EAAW,IACrDG,IAAa,OAAOF,KAAa,WAAWA,IAAWA,EAAS,IAChEhb,IAAWC,EAAYV,CAAE,GACzBmF,IAASyW,GAAmBnb,CAAQ;AAE1C,MAAIib,MAAiBC;AACnB,UAAM,IAAI;AAAA,MACR,wEAAwED,CAAY;AAAA,IAAA;AAGxF,QAAMG,IAAgB9a,EAAY2a,GAAc1b,EAAG,GAAG;AACtD,MAAI,CAAC6b;AACH,UAAM,IAAI,MAAM,iBAAiBH,CAAY,YAAY;AAE3D,QAAMI,IAAc/a,EAAY4a,GAAY3b,EAAG,GAAG;AAClD,MAAI,CAAC8b;AACH,UAAM,IAAI,MAAM,iBAAiBH,CAAU,YAAY;AAGzD,QAAMI,IAAkBC,EAAaH,CAAa,GAC5CI,IAAgBD,EAAaF,CAAW,GAExCI,IACJ/W,EAAO,YACL4W,EAAgB,aAClB,GACII,IACJhX,EAAO,YACL8W,EAAc,aAChB;AAEF,MACE,CAACF,EAAgB,oBACjBG,EAAkB,YAAY;AAE9B,UAAM,IAAI;AAAA,MACR,mEAAmER,CAAY;AAAA,IAAA;AAGnF,MAAI,CAACO,EAAc,oBAAoBE,EAAgB,YAAY;AACjE,UAAM,IAAI;AAAA,MACR,mEAAmER,CAAU;AAAA,IAAA;AAIjF,MAAIS,GACAC;AAEJ,MAAIH,EAAkB,YAAY,SAAS;AACzC,UAAMI,IAAWC,GAAS,IAAIR,EAAgB,aAAa,IAAI;AAK/D,IAAAK,IAHEL,EAAgB,aAAa,YAC7BO,EAAS,WAAW,GAAG,GAAGP,EAAgB,aAAa,IAAI,IAC3D,IACwB;AAAA,EAC5B;AACE,IAAAK,IAAWL,EAAgB,aAAa,YAAY;AAGtD,MAAII,EAAgB,YAAY,SAAS;AACvC,UAAMG,IAAWC,GAAS,IAAIN,EAAc,aAAa,IAAI,GACvDO,IACJP,EAAc,aAAa,YAC3BK,EAAS;AAAA,MACPA,EAAS,SAAS;AAAA,MAClBA,EAAS,QAAQ;AAAA,MACjBL,EAAc,aAAa;AAAA,IAAA,IAE7B,GACIQ,IAAmBzc,EAAG,IAAI,QAAQwc,CAAW,EAAE,UAAW;AAChE,IAAAH,IAASG,IAAcC,IAAmB;AAAA,EAC5C;AACE,IAAAJ,IAASJ,EAAc,aAAa,WAAW;AAOjD,EAAAjc,EAAG,aAAa+F,EAAc,OAAO/F,EAAG,KAAKoc,GAAUC,CAAM,CAAC;AAChE;AAEO,SAASK,GAAsB1c,GAAiB2c,IAAgB,IAAO;AAG5E,QAAMlc,IAAWC,EAAYV,CAAE,GAEzBmH,IAAQwV,IACVhC,GAAqB3a,EAAG,KAAKA,EAAG,SAAS,IACzCA,EAAG;AAEP,MAAIoa,IAAQjT,EAAM,OACdkT,IAAMlT,EAAM;AAMhB,SAAOkT,EAAI,gBAAgBA,EAAI,OAAO,WAAW,KAAKA,EAAI,QAAQ;AAChE,IAAAA,IAAMra,EAAG,IAAI,QAAQqa,EAAI,MAAM,CAAC;AAIlC,SAAOA,EAAI,iBAAiB,KAAKA,EAAI,QAAQ;AAC3C,IAAAA,IAAMra,EAAG,IAAI,QAAQqa,EAAI,MAAM,CAAC;AAIlC,SAAOD,EAAM,iBAAiB,KAAKA,EAAM,QAAQ;AAC/C,IAAAA,IAAQpa,EAAG,IAAI,QAAQoa,EAAM,MAAM,CAAC;AAItC,SAAOA,EAAM,gBAAgBA,EAAM,OAAO,WAAW,KAAKA,EAAM,QAAQ;AACtE,IAAAA,IAAQpa,EAAG,IAAI,QAAQoa,EAAM,MAAM,CAAC;AAGtC,QAAMwC,IAAgBC;AAAA,IACpB7c,EAAG,IAAI,MAAMoa,EAAM,KAAKC,EAAI,KAAK,EAAI;AAAA,IACrC5Z;AAAA,EAAA;AAGF,SAAO;AAAA,IACL,OAAO;AAAA,MACL,UAAU2Z,EAAM;AAAA,MAChB,QAAQC,EAAI;AAAA,IAAA;AAAA,IAEd,GAAGuC;AAAA,EAAA;AAEP;ACvPO,SAASE,GAId9c,GAAoD;AACpD,QAAM,EAAE,SAAA+c,EAAA,IAAYjV,EAA4B9H,CAAE,GAC5CS,IAAWC,EAAYV,EAAG,GAAG,GAE7Bgd,IAAchd,EAAG,IAAI,QAAQ+c,EAAQ,SAAS,GAE9CE,IAAWD,EAAY,YAGvBE,IAAWld,EAAG,IAAI,QAAQ+c,EAAQ,QAAQ,EAAE;AAGlD,MAAIvU;AACJ,SAAIwU,EAAY,QAAQ,MAEtBxU,IAAawU,EAAY,KAAA,GACpBxU,EAAW,KAAK,UAAU,SAAS,MAEtCA,IAAawU,EAAY,KAAKA,EAAY,QAAQ,CAAC,KAIhD;AAAA,IACL,OAAO7b,EAAY4b,EAAQ,MAAMtc,CAAQ;AAAA,IACzC,WAAWwc,MAAa,OAAO,SAAY9b,EAAY8b,GAAUxc,CAAQ;AAAA,IACzE,WAAWyc,MAAa,OAAO,SAAY/b,EAAY+b,GAAUzc,CAAQ;AAAA,IACzE,aACE+H,MAAe,SAAY,SAAYrH,EAAYqH,GAAY/H,CAAQ;AAAA,EAAA;AAE7E;AAEO,SAAS0c,GACdnd,GACAod,GACA7c,IAA6B,SAC7B;AACA,QAAMC,IAAK,OAAO4c,KAAgB,WAAWA,IAAcA,EAAY,IACjE3c,IAAWC,EAAYV,EAAG,GAAG,GAC7BmF,IAASyW,GAAmBnb,CAAQ,GAEpCK,IAAUC,EAAYP,GAAIR,EAAG,GAAG;AACtC,MAAI,CAACc;AACH,UAAM,IAAI,MAAM,iBAAiBN,CAAE,YAAY;AAGjD,QAAM6c,IAAOrB,EAAalb,CAAO,GAE3Bwc,IACJnY,EAAO,YAAYkY,EAAK,aAAa,EAAG;AAE1C,MAAIA,EAAK,kBAAkB;AACzB,UAAM9b,IAAe8b,EAAK;AAC1B,QAAIC,MAAgB,QAAQ;AAC1B,MAAAtd,EAAG,aAAawF,EAAc,OAAOxF,EAAG,KAAKuB,EAAa,SAAS,CAAC;AACpE;AAAA,IACF;AAEA,QAAI+b,MAAgB;AAClB,MAAI/c,MAAc,UAChBP,EAAG;AAAA,QACD+F,EAAc,OAAO/F,EAAG,KAAKuB,EAAa,YAAY,CAAC;AAAA,MAAA,IAGzDvB,EAAG;AAAA,QACD+F,EAAc,OAAO/F,EAAG,KAAKuB,EAAa,WAAW,CAAC;AAAA,MAAA;AAAA,aAGjD+b,MAAgB;AACzB,MAAI/c,MAAc,UAIhBP,EAAG;AAAA,QACD+F,EAAc,OAAO/F,EAAG,KAAKuB,EAAa,YAAY,CAAC;AAAA,MAAA,IAGzDvB,EAAG;AAAA,QACD+F,EAAc,OAAO/F,EAAG,KAAKuB,EAAa,WAAW,CAAC;AAAA,MAAA;AAAA;AAI1D,YAAM,IAAIgC,EAAqB+Z,CAAW;AAAA,EAE9C,OAAO;AACL,UAAM9M,IACJjQ,MAAc,UACV8c,EAAK,eAAe,KAAK,aACzBA,EAAK,eAAe,KAAK;AAE/B,IAAAF,GAAsBnd,GAAIwQ,EAAM,MAAM,IAAIjQ,CAAS;AAAA,EACrD;AACF;AC5FO,MAAMgd,GAIX;AAAA,EACA,YAAoBhe,GAAoD;AAApD,SAAA,SAAAA;AAAA,EAAqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQlE,eAAiE;AACtE,WAAO,KAAK,OAAO,SAAS,CAACS,MAAO+a,GAAa/a,CAAE,CAAC;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,sBAAsB2c,IAAgB,IAAO;AAClD,WAAO,KAAK,OAAO,SAAS,CAAC3c,MAAO0c,GAAsB1c,GAAI2c,CAAa,CAAC;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,aAAanB,GAA6BC,GAA2B;AAC1E,WAAO,KAAK,OAAO,SAAS,CAACzb,MAAOub,GAAavb,GAAIwb,GAAYC,CAAQ,CAAC;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,wBAIL;AACA,WAAO,KAAK,OAAO,SAAS,CAACzb,MAAO8c,GAAsB9c,CAAE,CAAC;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,sBACLod,GACA7c,IAA6B,SAC7B;AACA,WAAO,KAAK,OAAO;AAAA,MAAS,CAACP,MAC3Bmd,GAAsBnd,GAAIod,GAAa7c,CAAS;AAAA,IAAA;AAAA,EAEpD;AAAA;AAAA;AAAA;AAAA,EAKO,0BAA0B;AAC/B,QAAI,CAAC,KAAK,OAAO;AACf;AAGF,UAAM,EAAE,WAAAsF,EAAA,IAAc,KAAK,OAAO,kBAG5B,EAAE,QAAA2X,MAAW3X,GACb4X,IAAO,KAAK,IAAI,GAAGD,EAAO,IAAI,CAACrW,MAAUA,EAAM,MAAM,GAAG,CAAC,GACzDuW,IAAK,KAAK,IAAI,GAAGF,EAAO,IAAI,CAACrW,MAAUA,EAAM,IAAI,GAAG,CAAC;AAE3D,QAAIwW,GAAgB9X,CAAS,GAAG;AAC9B,YAAM/G,IAAO,KAAK,OAAO,gBAAgB,QAAQ2e,CAAI;AACrD,UAAI3e;AACF,eAAOA,EAAK,sBAAA;AAAA,IAEhB;AAEA,WAAO8e;AAAA,MACL,KAAK,OAAO;AAAA,MACZH;AAAA,MACAC;AAAA,IAAA,EACA,OAAA;AAAA,EACJ;AACF;AChHO,MAAMG,GAAa;AAAA,EACxB,YAAoBte,GAAwC;AAKpD;AAAA;AAAA;AAAA,IAAAmZ,EAAA,2BAAwC;AAsBxC;AAAA,IAAAA,EAAA,iBAAU;AA3BE,SAAA,SAAAnZ;AAAA,EAAyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBtD,IAAIgK,GAAmB;AAC5B,QAAI;AACF,kBAAK,UAAU,IACRA,EAAA;AAAA,IACT,UAAA;AACE,WAAK,UAAU;AAAA,IACjB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBO,KAAKuU,GAAkB;AAC5B,QAAI,KAAK;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MAAA;AAGJ,QAAI,KAAK;AACP,aAAO,KAAK,QAAQA,CAAO;AAE7B,UAAM7S,IAAQ,KAAK,kBACbuE,IAAO,KAAK;AAGlB,WAAOsO,EAAQ7S,GAFE,CAACjL,MAAoB,KAAK,gBAAgB,SAASA,CAAE,GAEtCwP,CAAI;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcO,QAAQsO,GAA2B;AACxC,QAAI,KAAK;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MAAA;AAGJ,UAAM7S,IAAQ,KAAK,kBACbuE,IAAO,KAAK;AAElB,WAAOsO,EAAQ7S,GAAO,QAAWuE,CAAI;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBO,SACL5G,GAOG;AACH,QAAI,KAAK;AAEP,aAAOA,EAAS,KAAK,iBAAiB;AAGxC,QAAI;AAEF,WAAK,oBAAoB,KAAK,OAAO,cAAc,MAAM;AAGzD,YAAMwC,IAASxC,EAAS,KAAK,iBAAiB,GAGxCmV,IAAW,KAAK;AAEtB,kBAAK,oBAAoB,MAEvBA;AAAA,OAECA,EAAS,cACRA,EAAS,gBACTA,EAAS,oBACTA,EAAS,kBACT,CAACA,EAAS,cAGZ,KAAK,gBAAgB,SAASA,CAAQ,GAGjC3S;AAAA,IACT,UAAA;AAEE,WAAK,oBAAoB;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,mBAAmB;AAC5B,QAAI,KAAK;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MAAA;AAGJ,WAAO,KAAK,OAAO,cAAc;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,kBAAkB;AAC3B,WAAO,KAAK,OAAO,cAAc;AAAA,EACnC;AAAA,EAEO,YAAY;;AACjB,aAAOhM,IAAA,KAAK,oBAAL,gBAAAA,EAAsB,eAAc;AAAA,EAC7C;AAAA,EAEO,QAAQ;;AACb,KAAAA,IAAA,KAAK,oBAAL,QAAAA,EAAsB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,aAAsB;AAC/B,QAAI,CAAC,KAAK,OAAO,eAAe;AAC9B,UAAI,CAAC,KAAK,OAAO;AACf,cAAM,IAAI,MAAM,mCAAmC;AAErD,aAAO;AAAA,IACT;AACA,WAAO,KAAK,OAAO,cAAc,eAAe,SAC5C,KACA,KAAK,OAAO,cAAc;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,WAAW4e,GAAmB;AACvC,QAAI,CAAC,KAAK,OAAO,eAAe;AAC9B,UAAI,CAAC,KAAK,OAAO;AACf,cAAM,IAAI,MAAM,mCAAmC;AAGrD;AAAA,IACF;AACA,IAAI,KAAK,OAAO,cAAc,QAAQ,aAAaA,KACjD,KAAK,OAAO,cAAc,YAAYA,CAAQ;AAAA,EAElD;AAAA;AAAA;AAAA;AAAA,EAKO,OAAgB;AAErB,UAAMC,IAAa,KAAK,OAAO,aAAoC,OAAO;AAC1E,QAAIA;AACF,aAAO,KAAK,KAAKA,EAAW,WAAW;AAGzC,UAAMC,IACJ,KAAK,OAAO,aAAsC,SAAS;AAC7D,QAAIA;AACF,aAAO,KAAK,KAAKA,EAAc,WAAW;AAG5C,UAAM,IAAI,MAAM,sBAAsB;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,OAAO;AACZ,UAAMD,IAAa,KAAK,OAAO,aAAoC,OAAO;AAC1E,QAAIA;AACF,aAAO,KAAK,KAAKA,EAAW,WAAW;AAGzC,UAAMC,IACJ,KAAK,OAAO,aAAsC,SAAS;AAC7D,QAAIA;AACF,aAAO,KAAK,KAAKA,EAAc,WAAW;AAG5C,UAAM,IAAI,MAAM,sBAAsB;AAAA,EACxC;AACF;ACnPO,SAASC,GACdne,GACAoe,GACA/a,GACAD,IAEI,EAAE,iBAAiB,MACvB;AAMA,MAAI,EAAE,MAAAqa,GAAM,IAAAC,EAAA,IACV,OAAOU,KAAa,WAChB,EAAE,MAAMA,GAAU,IAAIA,EAAA,IACtB,EAAE,MAAMA,EAAS,MAAM,IAAIA,EAAS,GAAA,GAEtCC,IAAoB,IACpBC,IAAqB,IAGrB9R,IAAO;AAoBX,MAlBAnJ,EAAM,QAAQ,CAACvE,MAAS;AAEtB,IAAAA,EAAK,MAAA,GAEDuf,KAAqBvf,EAAK,UAAUA,EAAK,MAAM,WAAW,IAC5D0N,KAAQ1N,EAAK,OAEbuf,IAAoB,IAGtBC,IAAqBA,IAAqBxf,EAAK,UAAU;AAAA,EAC3D,CAAC,GAOG2e,MAASC,KAAMY,GAAoB;AACrC,UAAM,EAAE,QAAAC,EAAA,IAAWve,EAAG,IAAI,QAAQyd,CAAI;AAItC,IAFEc,EAAO,eAAe,CAACA,EAAO,KAAK,KAAK,QAAQ,CAACA,EAAO,eAGxDd,KAAQ,GACRC,KAAM;AAAA,EAEV;AAIA,SAAIW,IAUFre,EAAG,WAAWwM,GAAMiR,GAAMC,CAAE,IAE5B1d,EAAG,YAAYyd,GAAMC,GAAIra,CAAK,GAI5BD,EAAQ,mBACVob,GAAwBxe,GAAIA,EAAG,MAAM,SAAS,GAAG,EAAE,GAG9C;AACT;AChEO,MAAMye,GAIX;AAAA,EACA,YAAoBlf,GAAoD;AAApD,SAAA,SAAAA;AAAA,EAAqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOlE,oBACLM,GACA,EAAE,iBAAA6e,IAAkB,GAAA,IAAyC,CAAA,GAC7D;AACA,UAAMrb,IAAQvD,EAAqBD,GAAS,KAAK,OAAO,QAAQ;AAEhE,SAAK,OAAO,SAAS,CAACG,MAAO;AAC3B,MAAAme;AAAA,QACEne;AAAA,QACA;AAAA,UACE,MAAMA,EAAG,UAAU;AAAA,UACnB,IAAIA,EAAG,UAAU;AAAA,QAAA;AAAA,QAEnBqD;AAAA,QACA;AAAA,UACE,iBAAAqb;AAAA,QAAA;AAAA,MACF;AAAA,IAEJ,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAkB;AACvB,WAAO,KAAK,OAAO,SAAS,CAAC1e,MAAO;AAClC,YAAM2e,IAA0B,CAAA,GAC1BlK,IAAQzU,EAAG,UAAU,IAAI,MAAA;AAE/B,iBAAW2D,KAAQ8Q,GAAO;AACxB,cAAMhW,IAAS,KAAK,OAAO,OAAO,YAAYkF,EAAK,KAAK,IAAI;AAC5D,YAAI,CAAClF,GAAQ;AACX;AAAA,UAEEkF,EAAK,KAAK,SAAS;AAAA,UAEnB,CAACA,EAAK,KAAK,KAAK,mBAGhB,QAAQ,KAAK,iCAAiCA,EAAK,KAAK,IAAI;AAG9D;AAAA,QACF;AACA,QAAIlF,EAAO,eAAe,YACvBkgB,EAAelgB,EAAO,IAAI,IAAI,KAE9BkgB,EAAelgB,EAAO,IAAI,IAAIkF,EAAK,MAAM;AAAA,MAE9C;AAEA,aAAOgb;AAAA,IACT,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAUA,GAAyB;AACxC,eAAW,CAACC,GAAO1T,CAAK,KAAK,OAAO,QAAQyT,CAAM,GAAG;AACnD,YAAMlgB,IAAS,KAAK,OAAO,OAAO,YAAYmgB,CAAK;AACnD,UAAI,CAACngB;AACH,cAAM,IAAI,MAAM,SAASmgB,CAAK,2BAA2B;AAE3D,UAAIngB,EAAO,eAAe;AACxB,aAAK,OAAO,cAAc,SAAS,QAAQmgB,CAAK;AAAA,eACvCngB,EAAO,eAAe;AAC/B,aAAK,OAAO,cAAc,SAAS,QAAQmgB,GAAO;AAAA,UAChD,aAAa1T;AAAA,QAAA,CACd;AAAA;AAED,cAAM,IAAI3H,EAAqB9E,EAAO,UAAU;AAAA,IAEpD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAakgB,GAAyB;AAC3C,eAAWC,KAAS,OAAO,KAAKD,CAAM;AACpC,WAAK,OAAO,cAAc,SAAS,UAAUC,CAAK;AAAA,EAEtD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAaD,GAAyB;AAC3C,eAAW,CAACC,GAAO1T,CAAK,KAAK,OAAO,QAAQyT,CAAM,GAAG;AACnD,YAAMlgB,IAAS,KAAK,OAAO,OAAO,YAAYmgB,CAAK;AACnD,UAAI,CAACngB;AACH,cAAM,IAAI,MAAM,SAASmgB,CAAK,2BAA2B;AAE3D,UAAIngB,EAAO,eAAe;AACxB,aAAK,OAAO,cAAc,SAAS,WAAWmgB,CAAK;AAAA,eAC1CngB,EAAO,eAAe;AAC/B,aAAK,OAAO,cAAc,SAAS,WAAWmgB,GAAO;AAAA,UACnD,aAAa1T;AAAA,QAAA,CACd;AAAA;AAED,cAAM,IAAI3H,EAAqB9E,EAAO,UAAU;AAAA,IAEpD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAkB;AACvB,WAAO,KAAK,OAAO,SAAS,CAACuB,MACpBA,EAAG,IAAI,YAAYA,EAAG,UAAU,MAAMA,EAAG,UAAU,EAAE,CAC7D;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKO,qBAAqB;AAC1B,WAAO,KAAK,OAAO,cAAc,cAAc,MAAM,EAAE;AAAA,EAGzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,WAAWsL,GAAakB,GAAe;AAC5C,QAAIlB,MAAQ;AACV;AAEF,UAAM3H,IAAO,KAAK,OAAO,SAAS,KAAK,QAAQ,EAAE,MAAM2H,GAAK;AAC5D,SAAK,OAAO,SAAS,CAACtL,MAAO;AAC3B,YAAM,EAAE,MAAAyd,GAAM,IAAAC,EAAA,IAAO1d,EAAG;AAExB,MAAIwM,IACFxM,EAAG,WAAWwM,GAAMiR,GAAMC,CAAE,EAAE,QAAQD,GAAMA,IAAOjR,EAAK,QAAQ7I,CAAI,IAEpE3D,EAAG,aAAa+F,GAAc,OAAO/F,EAAG,KAAK0d,CAAE,CAAC,EAAE;AAAA,QAChDD;AAAA,QACAC;AAAA,QACA/Z;AAAA,MAAA;AAAA,IAGN,CAAC;AAAA,EACH;AACF;AC/KA,SAASkb,GAAY/f,GAAgBggB,GAAW;AAC9C,QAAM1a,IAAkB,CAAA;AACxB,SAAAtF,EAAK,QAAQ,CAAC0R,GAAOuO,GAAGxO,MAAM;AAC5B,IAAIA,MAAMuO,KACR1a,EAAS,KAAKoM,CAAK;AAAA,EAEvB,CAAC,GACMtP,EAAS,KAAKkD,CAAQ;AAC/B;AAQO,SAAS4a,GAAcC,GAAa9Z,GAAgB;AACzD,QAAM+Z,IAAkB,CAAA;AACxB,WAAS3O,IAAI,GAAGA,IAAI0O,EAAE,YAAY1O;AAChC,QAAI0O,EAAE,MAAM1O,CAAC,EAAE,KAAK,SAAS;AAC3B,UACE2O,EAAS,SAAS,KAClBA,EAASA,EAAS,SAAS,CAAC,EAAE,KAAK,SAAS,SAC5C;AAEA,cAAMC,IAAYD,EAASA,EAAS,SAAS,CAAC,GACxCE,IAAWD,EAAU,KAAKA,EAAU,QAAQ,SAASF,EAAE,MAAM1O,CAAC,CAAC,CAAC;AACtE,QAAA2O,EAASA,EAAS,SAAS,CAAC,IAAIE;AAAA,MAClC,OAAO;AAEL,cAAMA,IAAWja,EAAO,MAAM,MAAM;AAAA,UAClC;AAAA,UACA8Z,EAAE,MAAM1O,CAAC;AAAA,QAAA;AAEX,QAAA2O,EAAS,KAAKE,CAAQ;AAAA,MACxB;AAAA;AAEA,MAAAF,EAAS,KAAKD,EAAE,MAAM1O,CAAC,CAAC;AAG5B,SAAA0O,IAAI/d,EAAS,KAAKge,CAAQ,GACnBD;AACT;AAeO,SAASI,GAAgB7X,GAAcgI,GAAkB;AAC9D,MAAIyP,IAAI/d,EAAS,KAAKsG,EAAM,OAAO;AAGnC,MAFAyX,IAAID,GAAcC,GAAGzP,EAAK,MAAM,MAAM,GAElC,CAAC8P,GAAeL,GAAGzP,CAAI;AAEzB,WAAO,IAAIvO,GAAMge,GAAGzX,EAAM,WAAWA,EAAM,OAAO;AAGpD,WAAS+I,IAAI,GAAGA,IAAI0O,EAAE,YAAY1O;AAChC,QAAI0O,EAAE,MAAM1O,CAAC,EAAE,KAAK,KAAK,UAAU,gBAAgB;AACjD,YAAM1Q,IAAU,CAACof,EAAE,MAAM1O,CAAC,CAAC;AAI3B,UACEA,IAAI,IAAI0O,EAAE,cACVA,EAAE,MAAM1O,IAAI,CAAC,EAAE,KAAK,SAAS,cAC7B;AACA,cAAMgP,IAAcN,EACjB,MAAM1O,IAAI,CAAC,EACX,MAAM,CAAC,EACP,MAAM,CAAC;AAEV,SACEgP,EAAY,KAAK,SAAS,oBAC1BA,EAAY,KAAK,SAAS,sBAC1BA,EAAY,KAAK,SAAS,qBAE1B1f,EAAQ,KAAKof,EAAE,MAAM1O,IAAI,CAAC,CAAC,GAC3B0O,IAAIJ,GAAYI,GAAG1O,IAAI,CAAC;AAAA,MAE5B;AACA,YAAMiP,IAAYhQ,EAAK,MAAM,OAAO,MAAM,eAAe;AAAA,QACvD;AAAA,QACA3P;AAAA,MAAA;AAEF,MAAAof,IAAIA,EAAE,aAAa1O,GAAGiP,CAAS;AAAA,IACjC;AAEF,SAAO,IAAIve,GAAMge,GAAGzX,EAAM,WAAWA,EAAM,OAAO;AACpD;AAOA,SAAS8X,GAAe9b,GAAoBgM,GAAkB;;AAC5D,QAAMiQ,IAAqBjc,EAAS,eAAe,GAC7Ckc,MACJtgB,IAAAoE,EAAS,eAAT,gBAAApE,EAAqB,KAAK,KAAK,aAAY,WACvCugB,MACJjb,IAAAlB,EAAS,eAAT,gBAAAkB,EAAqB,KAAK,KAAK,aAAY;AAE7C,MAAI+a,GAAoB;AACtB,QAAIC;AAIF,aAAO;AAGT,QAAIC,GAAqB;AAIvB,YAAM5N,IAAYkB,EAA0BzD,EAAK,KAAK;AACtD,UAAIuC,EAAU;AASZ,eAAO,EAPLA,EAAU,aAAa,KAAK,KAAK,KAAK,YAAY;AAAA,IASxD;AAAA,EACF;AAEA,SAAO;AACT;AC4JA,MAAM6N,KAAyB;AAAA,EAC7B,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,sBAAsB;AACxB;AAEO,MAAMC,WAIH1W,GAEP;AAAA,EAkFS,YACW/F,GAGnB;;AACA,UAAA;AAnFc;AAAA;AAAA;AAAA,IAAAsV,EAAA;AAEA,IAAAA,EAAA;AAQT;AAAA;AAAA;AAAA;AAAA,IAAAA,EAAA,yBACL;AAOK;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,EAAA,wCAA6B,QAAA;AAKpB;AAAA;AAAA;AAAA,IAAAA,EAAA;AAKA;AAAA;AAAA;AAAA,IAAAA,EAAA;AAEA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,EAAA;AAIR,IAAAA,EAAA,gCAAyD,CAAA;AACzD,IAAAA,EAAA,8BAAuD,CAAA;AAE/C,IAAAA,EAAA;AAIA;AAAA;AAAA;AAAA,IAAAA,EAAA;AAkNC;AAAA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AA2EV;AAAA;AAAA;AAAA,IAAAA,EAAA,6BAA+D,IACjEoH,MACA,KAAK,kBAAkB,oBAAoB,GAAGA,CAAI;AAKhD;AAAA;AAAA;AAAA,IAAApH,EAAA,2BAA2D,IAC7DoH,MACA,KAAK,kBAAkB,kBAAkB,GAAGA,CAAI;AAK9C;AAAA;AAAA;AAAA,IAAApH,EAAA,sBAAkD,IACpDoH,MACA,KAAK,kBAAkB,aAAa,GAAGA,CAAI;AAOzC;AAAA;AAAA;AAAA;AAAA;AAAA,IAAApH,EAAA,eAAQ,CAAC9Z,MAAyB;AACvC,WAAK,cAAc,MAAM,EAAE,OAAOA,GAAS;AAAA,IAC7C;AAKO;AAAA;AAAA;AAAA,IAAA8Z,EAAA,iBAAU,MAAM;AACrB,WAAK,cAAc,QAAA;AAAA,IACrB;AA1SqB,SAAA,UAAAtV,GAMnB,KAAK,aAAaA,EAAQ,cAAc2c,IACxC,KAAK,WAAW;AAAA,MACd,QAAQ;AAAA,QACN,cAAY3gB,IAAAgE,KAAA,gBAAAA,EAAS,WAAT,gBAAAhE,EAAiB,eAAc;AAAA,QAC3C,uBAAqBsF,IAAAtB,KAAA,gBAAAA,EAAS,WAAT,gBAAAsB,EAAiB,wBAAuB;AAAA,QAC7D,iBAAeD,IAAArB,KAAA,gBAAAA,EAAS,WAAT,gBAAAqB,EAAiB,kBAAiB;AAAA,QACjD,WAASE,IAAAvB,KAAA,gBAAAA,EAAS,WAAT,gBAAAuB,EAAiB,YAAW;AAAA,MAAA;AAAA,IACvC;AAIF,UAAMqb,IAAa;AAAA,MACjB,eAAe;AAAA,MACf,QACE5c,EAAQ,UACP6c,GAAgB,OAAA;AAAA,MAKnB,GAAG7c;AAAA,MACH,cAAc;AAAA,QACZ,GAAG,KAAK,WAAW;AAAA,QACnB,GAAGA,EAAQ;AAAA,MAAA;AAAA,IACb;AAUF,QANA,KAAK,SAAS4c,EAAW,QACzB,KAAK,uBAAuBA,EAAW,OAAO,YAC9C,KAAK,+BAA+BA,EAAW,OAAO,oBACtD,KAAK,uBAAuBA,EAAW,OAAO,YAG1CA,EAAW,YAAY;AACzB,YAAME,IAAaF,EAAW;AAC9B,WAAK,aAAa,OAAOlS,GAAMqS,MAAY;AACzC,aAAK,uBAAuB;AAAA,UAAQ,CAACvX,MACnCA,EAAS,MAAM,MAAM,CAACuX,CAAO,CAAC;AAAA,QAAA;AAEhC,YAAI;AACF,iBAAO,MAAMD,EAAWpS,GAAMqS,CAAO;AAAA,QACvC,UAAA;AACE,eAAK,qBAAqB;AAAA,YAAQ,CAACvX,MACjCA,EAAS,MAAM,MAAM,CAACuX,CAAO,CAAC;AAAA,UAAA;AAAA,QAElC;AAAA,MACF;AAAA,IACF;AAEA,SAAK,iBAAiBH,EAAW,gBAEjC,KAAK,gBAAgB,IAAI9W,GAAa,IAAW,GACjD,KAAK,oBAAoB,IAAIuP,GAAiB,MAAMuH,CAAU;AAE9D,UAAMjJ,IAAmB,KAAK,kBAAkB,oBAAA,GAE1CqJ,IACJ,KAAK,kBAAkB,aAAa,OAAO,KAC3C,KAAK,kBAAkB,aAAa,qBAAqB;AAE3D,IAAIA,KAAwBJ,EAAW,kBAErC,QAAQ;AAAA,MACN;AAAA,IAAA;AAIJ,UAAMK,IAA+B;AAAA,MACnC,GAAGT;AAAA,MACH,GAAGI,EAAW;AAAA,MACd,SAAS;AAAA,MACT,WAAWA,EAAW,aAAa;AAAA,MACnC,YAAYjJ;AAAA,MACZ,aAAa;AAAA,QACX,IAAGnS,IAAAob,EAAW,mBAAX,gBAAApb,EAA2B;AAAA,QAC9B,YAAY;AAAA;AAAA;AAAA;AAAA,UAIV,UAAU;AAAA,UACV,IAAG0b,KAAAC,IAAAP,EAAW,mBAAX,gBAAAO,EAA2B,gBAA3B,gBAAAD,EAAwC;AAAA,UAC3C,IAAGE,IAAAR,EAAW,kBAAX,gBAAAQ,EAA0B;AAAA,UAC7B,OAAOtK;AAAA,YACL;AAAA,YACA8J,EAAW,gBAAgB,sBAAsB;AAAA,cACjDS,KAAAC,IAAAV,EAAW,kBAAX,gBAAAU,EAA0B,WAA1B,gBAAAD,EAAkC,UAAS;AAAA,UAAA;AAAA,QAC7C;AAAA,QAEF,iBAAApB;AAAA,MAAA;AAAA,IACF;AAGF,QAAI;AACF,YAAMsB,IACJX,EAAW,mBACVI,IACG;AAAA,QACE;AAAA,UACE,MAAM;AAAA,UACN,IAAI;AAAA,QAAA;AAAA,MACN,IAEF;AAAA,QACE;AAAA,UACE,MAAM;AAAA,UACN,IAAIlJ,GAAS,QAAQ,WAAA;AAAA,QAAW;AAAA,MAClC;AAGR,UAAI,CAAC,MAAM,QAAQyJ,CAAc,KAAKA,EAAe,WAAW;AAC9D,cAAM,IAAI;AAAA,UACR,mEACEA;AAAA,QAAA;AAGN,YAAMxb,IAASyb,GAAUP,EAAc,UAAW,GAC5CQ,IAAUF,EAAe;AAAA,QAAI,CAACG,OAClCjgB,EAAYigB,IAAG3b,GAAQ,KAAK,OAAO,WAAW,EAAE,OAAA;AAAA,MAAO,GAEnD8C,IAAM8Y;AAAA,QACV;AAAA,UACE,MAAM;AAAA,UACN,SAAS;AAAA,YACP;AAAA,cACE,MAAM;AAAA,cACN,SAASF;AAAA,YAAA;AAAA,UACX;AAAA,QACF;AAAA,QAEF1b;AAAA,QACAkb,EAAc;AAAA,MAAA;AAGhB,WAAK,gBAAgB,IAAIW,GAAa;AAAA,QACpC,GAAGX;AAAA,QACH,SAASpY,EAAI,OAAA;AAAA,MAAO,CACrB,GACD,KAAK,WAAW,KAAK,cAAc;AAAA,IACrC,SAAS0B,GAAG;AACV,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,OAAOA,EAAA;AAAA,MAAE;AAAA,IAEf;AAMA,QAAIsX;AACJ,UAAMC,IAAmB,KAAK,SAAS,MAAM,IAAI;AACjD,SAAK,SAAS,MAAM,IAAI,gBAAgB,IAAIpB,MAAc;AACxD,UAAImB;AACF,eAAOA;AAET,YAAM5c,IAAM6c,EAAiB,MAAM,KAAK,SAAS,MAAM,KAAKpB,CAAI,GAG1DqB,IAAW,KAAK,MAAM,KAAK,UAAU9c,EAAI,OAAA,CAAQ,CAAC;AACxD,aAAA8c,EAAS,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,MAAM,KAAK,kBAE1CF,IAAQ9hB,GAAK,SAAS,KAAK,UAAUgiB,CAAQ,GACtCF;AAAA,IACT,GACA,KAAK,SAAS,OAAO,kBAAkB,MAGvC,KAAK,gBAAgB,IAAIvY,GAAa,IAAW,GAEjD,KAAK,iBAAiB,IAAIyD,GAAc,IAAW,GACnD,KAAK,oBAAoB,IAAIoR,GAAiB,IAAW,GACzD,KAAK,gBAAgB,IAAIM,GAAa,IAAW,GACjD,KAAK,gBAAgB,IAAIY,GAAa,IAAW,GAEjD,KAAK,KAAK,QAAQ;AAAA,EACpB;AAAA,EAvMA,OAAc,OAGZrb,GASI;AACJ,WAAO,IAAIyc,GAAgBzc,KAAW,EAAE;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAuMA,IAAW,aAAa;AACtB,WAAO,KAAK,kBAAkB,cAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcO,KAAK0a,GAAkB;AAC5B,WAAO,KAAK,cAAc,KAAKA,CAAO;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcO,QAAQA,GAA2B;AACxC,WAAO,KAAK,cAAc,QAAQA,CAAO;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBO,SACLlV,GAOG;AACH,WAAO,KAAK,cAAc,SAASA,CAAQ;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4CA,IAAW,mBAAmB;AAC5B,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,kBAAkB;AAC3B,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EAEA,IAAW,aAAa;;AACtB,QAAI,MAAK;AAGT,cAAOxJ,IAAA,KAAK,oBAAL,gBAAAA,EAAsB;AAAA,EAC/B;AAAA,EAEO,YAAY;;AACjB,WAAI,KAAK,WACA,OAEFA,IAAA,KAAK,oBAAL,gBAAAA,EAAsB,eAAc;AAAA,EAC7C;AAAA,EAEA,IAAW,WAAW;AACpB,WAAO,CAAC,KAAK,cAAc;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKO,QAAQ;AACb,IAAI,KAAK,YAGT,KAAK,gBAAgB,MAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKO,OAAO;;AACZ,IAAI,KAAK,aAGTA,IAAA,KAAK,eAAL,QAAAA,EAAiB;AAAA,EACnB;AAAA;AAAA,EAGO,cAAcwJ,GAAsC;AACzD,gBAAK,uBAAuB,KAAKA,CAAQ,GAElC,MAAM;AACX,YAAMoB,IAAQ,KAAK,uBAAuB,QAAQpB,CAAQ;AAC1D,MAAIoB,IAAQ,MACV,KAAK,uBAAuB,OAAOA,GAAO,CAAC;AAAA,IAE/C;AAAA,EACF;AAAA,EAEO,YAAYpB,GAAsC;AACvD,gBAAK,qBAAqB,KAAKA,CAAQ,GAEhC,MAAM;AACX,YAAMoB,IAAQ,KAAK,qBAAqB,QAAQpB,CAAQ;AACxD,MAAIoB,IAAQ,MACV,KAAK,qBAAqB,OAAOA,GAAO,CAAC;AAAA,IAE7C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,iBAAqD;AAC9D,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,WAA+C;AACxD,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,SACL9B,GAC8C;AAC9C,WAAO,KAAK,cAAc,SAASA,CAAe;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,aACLA,GAC8C;AAC9C,WAAO,KAAK,cAAc,aAAaA,CAAe;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,aACLA,GAC8C;AAC9C,WAAO,KAAK,cAAc,aAAaA,CAAe;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,eACLA,GAC8C;AAC9C,WAAO,KAAK,cAAc,eAAeA,CAAe;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,aACLU,GACAC,IAAU,IACJ;AACN,SAAK,cAAc,aAAaD,GAAUC,CAAO;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,sBAAsBD,GAAsB;AACjD,SAAK,cAAc,GAAG,UAAUA,CAAQ;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,wBAAwBA,GAAsB;AACnD,SAAK,cAAc,GAAG,mBAAmBA,CAAQ;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,eACLA,GAIY;AACZ,WAAO,KAAK,kBACT,aAAakP,EAAoB,EACjC,UAAUlP,CAAQ;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,wBAIL;AACA,WAAO,KAAK,kBAAkB,sBAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,sBACLwU,GACA7c,IAA6B,SAC7B;AACA,WAAO,KAAK,kBAAkB,sBAAsB6c,GAAa7c,CAAS;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,eAAiE;AACtE,WAAO,KAAK,kBAAkB,aAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,sBAAsBoc,IAAgB,IAAO;AAClD,WAAO,KAAK,kBAAkB,sBAAsBA,CAAa;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,aAAanB,GAA6BC,GAA2B;AAC1E,WAAO,KAAK,kBAAkB,aAAaD,GAAYC,CAAQ;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,aAAsB;AAC/B,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,WAAWuC,GAAmB;AACvC,SAAK,cAAc,aAAaA;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,aACL3d,GACAC,GACAC,IAAgC,UAChC;AACA,WAAO,KAAK,cAAc;AAAA,MACxBF;AAAA,MACAC;AAAA,MACAC;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,YACLyI,GACApJ,GACA;AACA,WAAO,KAAK,cAAc,YAAYoJ,GAAepJ,CAAM;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAa2C,GAAmC;AACrD,WAAO,KAAK,cAAc,aAAaA,CAAc;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,cACLA,GACAlC,GACA;AACA,WAAO,KAAK,cAAc,cAAckC,GAAgBlC,CAAc;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKO,OAAgB;AACrB,WAAO,KAAK,cAAc,KAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,OAAgB;AACrB,WAAO,KAAK,cAAc,KAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,oBACLR,GACA,EAAE,iBAAA6e,IAAkB,GAAA,IAAyC,CAAA,GAC7D;AACA,SAAK,cAAc,oBAAoB7e,GAAS,EAAE,iBAAA6e,GAAiB;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAmC;AACxC,WAAO,KAAK,cAAc,gBAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAUC,GAAyB;AACxC,SAAK,cAAc,UAAUA,CAAM;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAaA,GAAyB;AAC3C,SAAK,cAAc,aAAaA,CAAM;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAaA,GAAyB;AAC3C,SAAK,cAAc,aAAaA,CAAM;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAkB;AACvB,WAAO,KAAK,cAAc,gBAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,qBAAqB;AAC1B,WAAO,KAAK,cAAc,mBAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,WAAWrT,GAAakB,GAAe;AAC5C,SAAK,cAAc,WAAWlB,GAAKkB,CAAI;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe;AACpB,WAAO,KAAK,cAAc,aAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,YAAY;AACjB,SAAK,cAAc,UAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKO,iBAAiB;AACtB,WAAO,KAAK,cAAc,eAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,cAAc;AACnB,SAAK,cAAc,YAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,eAAe;AACpB,WAAO,KAAK,cAAc,aAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,iBAAiB;AACtB,WAAO,KAAK,cAAc,eAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,kBACL1H,IAAoD,KAAK,UACjD;AACR,WAAO,KAAK,eAAe,kBAAkBA,CAAM;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,iBACLA,IAAoD,KAAK,UACjD;AACR,WAAO,KAAK,eAAe,iBAAiBA,CAAM;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,qBACL+F,GACoC;AACpC,WAAO,KAAK,eAAe,qBAAqBA,CAAI;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,sBACL/F,IAAoD,KAAK,UACjD;AACR,WAAO,KAAK,eAAe,sBAAsBA,CAAM;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,yBACL2G,GACoC;AACpC,WAAO,KAAK,eAAe,yBAAyBA,CAAQ;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,SACL7C,GAaAU,GACA;AACA,WAAO,KAAK,cAAc,SAASV,GAAUU,CAAwB;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,kBACLV,GACAc,GACA;AACA,WAAO,KAAK,cAAc;AAAA,MACxBd;AAAA,MACAc;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,QACLd,GAGA;AACA,SAAK,cAAc,QAAQA,CAAQ;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,UACLA,GAGA;AACA,SAAK,cAAc,UAAUA,CAAQ;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,0BAA0B;AAC/B,WAAO,KAAK,kBAAkB,wBAAA;AAAA,EAChC;AAAA,EAEA,IAAW,UAAU;AACnB,UAAMX,IAAM,KAAK;AAGjB,WACEA,EAAI,WAAW,KACdA,EAAI,WAAW,KACdA,EAAI,CAAC,EAAE,SAAS,eACfA,EAAI,CAAC,EAAE,QAAgB,WAAW;AAAA,EAEzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,UAAU4C,GAAcyB,IAAM,IAAO;AAC1C,SAAK,eAAe,UAAUzB,GAAMyB,CAAG;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAUE,GAAc;AAC7B,WAAO,KAAK,eAAe,UAAUA,CAAI;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,cAAcf,GAAkB;AACrC,WAAO,KAAK,eAAe,cAAcA,CAAQ;AAAA,EACnD;AACF;AC5wCO,MAAe2V,GAQpB;AAAA,EACO,YACLC,GACmBC,GAKHle,GAChB;AANmB,SAAA,WAAAke,GAKH,KAAA,UAAAle;AAAA,EACf;AAAA,EAEH,MAAa,YAAYkI,GAAa;;AACpC,QAAI,GAAClM,IAAA,KAAK,YAAL,QAAAA,EAAc;AACjB,cAAQ,MAAM,MAAMkM,CAAG,GAAG,KAAA;AAE5B,UAAMjH,IAAM,MAAM,KAAK,QAAQ,eAAeiH,CAAG;AACjD,WAAIjH,aAAe,OACVA,KAED,MAAM,MAAMA,CAAG,GAAG,KAAA;AAAA,EAC5B;AAAA,EAEO,UAAUsa,GAAmB;AAKlC,WAJoB,OAAO,QAAQA,CAAM,EAAE,IAAI,CAAC,CAACjE,GAAKxP,CAAK,MACrC,KAAK,SAAS,aAAawP,CAAG,EAAExP,GAAO,IAAI,CAEhE;AAAA,EAEH;AAAA,EAEO,iBAAiBhL,GAAoC;AAC1D,WAAO,KAAK,SAAS,qBAAqBA,EAAc,IAAI;AAAA,MAC1DA;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEO,uBAAuBqhB,GAA2C;AACvE,WAAOA,EAAmB,IAAI,CAACjd,MAAO,KAAK,iBAAiBA,CAAE,CAAC;AAAA,EACjE;AAAA,EAIA,MAAa,SACX1D,GACA4gB,GACAC,GACArd,GACA;AACA,WAAO,KAAK,SAAS,aAAaxD,EAAM,IAAI;AAAA,MAC1CA;AAAA,MACA;AAAA,MACA4gB;AAAA,MACAC;AAAA,MACArd;AAAA,IAAA;AAAA,EAEJ;AACF;ACxCO,SAASsd,GAIdL,GAAmC;AACnC,SAAO;AAAA,IACL,oBAAoB,CAAQM,MAC1BA;AAAA,IACF,4BAA4B,CAC1BA,MACGA;AAAA,IACL,oBAAoB,CAAIA,MAAgCA;AAAA,EAAA;AAE5D;ACvEO,SAASC,GACdlU,MACGmU,GAGH;AACA,QAAMC,IAAgB,CAAC,GAAGpU,CAAK;AAC/B,aAAWqU,KAAmBF;AAC5B,eAAWG,KAAkBD,GAAiB;AAC5C,YAAME,IAAwBH,EAAc;AAAA,QAC1C,CAACI,MAASA,EAAK,UAAUF,EAAe;AAAA,MAAA;AAE1C,MAAIC,MAA0B,KAC5BH,EAAc,KAAKE,CAAmB,IAEtCF,EAAc,OAAOG,IAAwB,GAAG,GAAGD,CAAmB;AAAA,IAE1E;AAEF,SAAOF;AACT;"}