{"version":3,"file":"TrailingNode-DPu6X9ym.cjs","sources":["../src/api/exporters/html/util/serializeBlocksExternalHTML.ts","../src/api/exporters/html/externalHTMLExporter.ts","../src/api/getBlocksChangedByTransaction.ts","../src/extensions/BlockChange/BlockChange.ts","../src/extensions/Collaboration/YCursorPlugin.ts","../src/extensions/Collaboration/YSync.ts","../src/extensions/Collaboration/YUndo.ts","../src/extensions/Collaboration/ForkYDoc.ts","../src/extensions/Collaboration/schemaMigration/migrationRules/moveColorAttributes.ts","../src/extensions/Collaboration/schemaMigration/migrationRules/index.ts","../src/extensions/Collaboration/schemaMigration/SchemaMigration.ts","../src/extensions/DropCursor/DropCursor.ts","../src/extensions/FormattingToolbar/FormattingToolbar.ts","../src/extensions/History/History.ts","../src/extensions/LinkToolbar/LinkToolbar.ts","../src/extensions/LinkToolbar/protocols.ts","../src/extensions/NodeSelectionKeyboard/NodeSelectionKeyboard.ts","../src/extensions/Placeholder/Placeholder.ts","../src/extensions/PreviousBlockType/PreviousBlockType.ts","../src/extensions/getDraggableBlockFromElement.ts","../src/api/exporters/markdown/util/removeUnderlinesRehypePlugin.ts","../src/api/exporters/markdown/util/addSpacesToCheckboxesRehypePlugin.ts","../src/api/exporters/markdown/util/convertVideoToMarkdownRehypePlugin.ts","../src/api/exporters/markdown/markdownExporter.ts","../src/api/nodeConversions/fragmentToBlocks.ts","../src/extensions/SideMenu/MultipleNodeSelection.ts","../src/extensions/SideMenu/dragging.ts","../src/extensions/SideMenu/SideMenu.ts","../src/extensions/TableHandles/TableHandles.ts","../src/extensions/TrailingNode/TrailingNode.ts"],"sourcesContent":["import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockImplementation,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToCustomInlineContent } from \"../../../nodeConversions/nodeToBlock.js\";\n\nfunction addAttributesAndRemoveClasses(element: HTMLElement) {\n  // Removes all BlockNote specific class names.\n  const className =\n    Array.from(element.classList).filter(\n      (className) => !className.startsWith(\"bn-\"),\n    ) || [];\n\n  if (className.length > 0) {\n    element.className = className.join(\" \");\n  } else {\n    element.removeAttribute(\"class\");\n  }\n}\n\nexport function serializeInlineContentExternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n  blockContent: PartialBlock<BSchema, I, S>[\"content\"],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  let nodes: Node[];\n\n  // TODO: reuse function from nodeconversions?\n  if (!blockContent) {\n    throw new Error(\"blockContent is required\");\n  } else if (typeof blockContent === \"string\") {\n    nodes = inlineContentToNodes([blockContent], editor.pmSchema);\n  } else if (Array.isArray(blockContent)) {\n    nodes = inlineContentToNodes(blockContent, editor.pmSchema);\n  } else if (blockContent.type === \"tableContent\") {\n    nodes = tableContentToNodes(blockContent, editor.pmSchema);\n  } else {\n    throw new UnreachableCaseError(blockContent.type);\n  }\n\n  // Check if any of the nodes are custom inline content with toExternalHTML\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const node of nodes) {\n    // Check if this is a custom inline content node with toExternalHTML\n    if (\n      node.type.name !== \"text\" &&\n      editor.schema.inlineContentSchema[node.type.name]\n    ) {\n      const inlineContentImplementation =\n        editor.schema.inlineContentSpecs[node.type.name].implementation;\n\n      if (inlineContentImplementation) {\n        // Convert the node to inline content format\n        const inlineContent = nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        );\n\n        // Use the custom toExternalHTML method or fallback to `render`\n        const output = inlineContentImplementation.toExternalHTML\n          ? inlineContentImplementation.toExternalHTML(\n              inlineContent as any,\n              editor as any,\n            )\n          : inlineContentImplementation.render.call(\n              {\n                renderType: \"dom\",\n                props: undefined,\n              },\n              inlineContent as any,\n              () => {\n                // No-op\n              },\n              editor as any,\n            );\n\n        if (output) {\n          fragment.appendChild(output.dom);\n\n          // If contentDOM exists, render the inline content into it\n          if (output.contentDOM) {\n            const contentFragment = serializer.serializeFragment(\n              node.content,\n              options,\n            );\n            output.contentDOM.dataset.editable = \"\";\n            output.contentDOM.appendChild(contentFragment);\n          }\n          continue;\n        }\n      }\n    } else if (node.type.name === \"text\") {\n      // We serialize text nodes manually as we need to serialize the styles/\n      // marks using `styleSpec.implementation.render`. When left up to\n      // ProseMirror, it'll use `toDOM` which is incorrect.\n      let dom: globalThis.Node | Text = document.createTextNode(\n        node.textContent,\n      );\n      // Reverse the order of marks to maintain the correct priority.\n      for (const mark of node.marks.toReversed()) {\n        if (mark.type.name in editor.schema.styleSpecs) {\n          const newDom = (\n            editor.schema.styleSpecs[mark.type.name].implementation\n              .toExternalHTML ??\n            editor.schema.styleSpecs[mark.type.name].implementation.render\n          )(mark.attrs[\"stringValue\"], editor);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        } else {\n          const domOutputSpec = mark.type.spec.toDOM!(mark, true);\n          const newDom = DOMSerializer.renderSpec(document, domOutputSpec);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        }\n      }\n\n      fragment.appendChild(dom);\n    } else {\n      // Fall back to default serialization for this node\n      const nodeFragment = serializer.serializeFragment(\n        Fragment.from([node]),\n        options,\n      );\n      fragment.appendChild(nodeFragment);\n    }\n  }\n\n  if (\n    fragment.childNodes.length === 1 &&\n    fragment.firstChild?.nodeType === 1 /* Node.ELEMENT_NODE */\n  ) {\n    addAttributesAndRemoveClasses(fragment.firstChild as HTMLElement);\n  }\n\n  return fragment;\n}\n\n/**\n * TODO: there's still quite some logic that handles getting and filtering properties,\n * we should make sure the `toExternalHTML` methods of default blocks actually handle this,\n * instead of the serializer.\n */\nfunction serializeBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  fragment: DocumentFragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) {\n  const doc = options?.document ?? document;\n  const BC_NODE = editor.pmSchema.nodes[\"blockContainer\"];\n\n  // set default props in case we were passed a partial block\n  const props = block.props || {};\n  for (const [name, spec] of Object.entries(\n    editor.schema.blockSchema[block.type as any].propSchema,\n  )) {\n    if (!(name in props) && spec.default !== undefined) {\n      (props as any)[name] = spec.default;\n    }\n  }\n\n  const bc = BC_NODE.spec?.toDOM?.(\n    BC_NODE.create({\n      id: block.id,\n      ...props,\n    }),\n  ) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  // the container node is just used as a workaround to get some block-level attributes.\n  // we should change toExternalHTML so that this is not necessary\n  const attrs = Array.from(bc.dom.attributes);\n\n  const blockImplementation = editor.blockImplementations[block.type as any]\n    .implementation as BlockImplementation;\n  const ret =\n    blockImplementation.toExternalHTML?.call(\n      {},\n      { ...block, props } as any,\n      editor as any,\n    ) ||\n    blockImplementation.render.call(\n      {},\n      { ...block, props } as any,\n      editor as any,\n    );\n\n  const elementFragment = doc.createDocumentFragment();\n\n  if ((ret.dom as HTMLElement).classList.contains(\"bn-block-content\")) {\n    const blockContentDataAttributes = [\n      ...attrs,\n      ...Array.from((ret.dom as HTMLElement).attributes),\n    ].filter(\n      (attr) =>\n        attr.name.startsWith(\"data\") &&\n        attr.name !== \"data-content-type\" &&\n        attr.name !== \"data-file-block\" &&\n        attr.name !== \"data-node-view-wrapper\" &&\n        attr.name !== \"data-node-type\" &&\n        attr.name !== \"data-id\" &&\n        attr.name !== \"data-editable\",\n    );\n\n    // ret.dom = ret.dom.firstChild! as any;\n    for (const attr of blockContentDataAttributes) {\n      (ret.dom.firstChild! as HTMLElement).setAttribute(attr.name, attr.value);\n    }\n\n    addAttributesAndRemoveClasses(ret.dom.firstChild! as HTMLElement);\n    elementFragment.append(...Array.from(ret.dom.childNodes));\n  } else {\n    elementFragment.append(ret.dom);\n  }\n\n  if (ret.contentDOM && block.content) {\n    const ic = serializeInlineContentExternalHTML(\n      editor,\n      block.content as any, // TODO\n      serializer,\n      options,\n    );\n\n    ret.contentDOM.appendChild(ic);\n  }\n\n  let listType = undefined;\n  if (orderedListItemBlockTypes.has(block.type!)) {\n    listType = \"OL\";\n  } else if (unorderedListItemBlockTypes.has(block.type!)) {\n    listType = \"UL\";\n  }\n\n  if (listType) {\n    if (fragment.lastChild?.nodeName !== listType) {\n      const list = doc.createElement(listType);\n\n      if (\n        listType === \"OL\" &&\n        \"start\" in props &&\n        props.start &&\n        props?.start !== 1\n      ) {\n        list.setAttribute(\"start\", props.start + \"\");\n      }\n      fragment.append(list);\n    }\n    fragment.lastChild!.appendChild(elementFragment);\n  } else {\n    fragment.append(elementFragment);\n  }\n\n  if (block.children && block.children.length > 0) {\n    const childFragment = doc.createDocumentFragment();\n    serializeBlocksToFragment(\n      childFragment,\n      editor,\n      block.children,\n      serializer,\n      orderedListItemBlockTypes,\n      unorderedListItemBlockTypes,\n      options,\n    );\n    if (\n      fragment.lastChild?.nodeName === \"UL\" ||\n      fragment.lastChild?.nodeName === \"OL\"\n    ) {\n      // add nested lists to the last list item\n      while (\n        childFragment.firstChild?.nodeName === \"UL\" ||\n        childFragment.firstChild?.nodeName === \"OL\"\n      ) {\n        fragment.lastChild!.lastChild!.appendChild(childFragment.firstChild!);\n      }\n    }\n\n    if (editor.pmSchema.nodes[block.type as any].isInGroup(\"blockContent\")) {\n      // default \"blockContainer\" style blocks are flattened (no \"nested block\" support) for externalHTML, so append the child fragment to the outer fragment\n      fragment.append(childFragment);\n    } else {\n      // for columns / column lists, do use nesting\n      ret.contentDOM?.append(childFragment);\n    }\n  }\n}\n\nconst serializeBlocksToFragment = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  fragment: DocumentFragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) => {\n  for (const block of blocks) {\n    serializeBlock(\n      fragment,\n      editor,\n      block,\n      serializer,\n      orderedListItemBlockTypes,\n      unorderedListItemBlockTypes,\n      options,\n    );\n  }\n};\n\nexport const serializeBlocksExternalHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) => {\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  serializeBlocksToFragment(\n    fragment,\n    editor,\n    blocks,\n    serializer,\n    orderedListItemBlockTypes,\n    unorderedListItemBlockTypes,\n    options,\n  );\n  return fragment;\n};\n","import { DOMSerializer, Schema } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContent,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport {\n  serializeBlocksExternalHTML,\n  serializeInlineContentExternalHTML,\n} from \"./util/serializeBlocksExternalHTML.js\";\n\n// Used to export BlockNote blocks and ProseMirror nodes to HTML for use outside\n// the editor. Blocks are exported using the `toExternalHTML` method in their\n// `blockSpec`, or `toInternalHTML` if `toExternalHTML` is not defined.\n//\n// The HTML created by this serializer is different to what's rendered by the\n// editor to the DOM. This also means that data is likely to be lost when\n// converting back to original blocks. The differences in the output HTML are:\n// 1. It doesn't include the `blockGroup` and `blockContainer` wrappers meaning\n// that nesting is not preserved for non-list-item blocks.\n// 2. `li` items in the output HTML are wrapped in `ul` or `ol` elements.\n// 3. While nesting for list items is preserved, other types of blocks nested\n// inside a list are un-nested and a new list is created after them.\n// 4. The HTML is wrapped in a single `div` element.\n\n// Needs to be sync because it's used in drag handler event (SideMenuPlugin)\nexport const createExternalHTMLExporter = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) => {\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  return {\n    exportBlocks: (\n      blocks: PartialBlock<BSchema, I, S>[],\n      options: { document?: Document },\n    ) => {\n      const html = serializeBlocksExternalHTML(\n        editor,\n        blocks,\n        serializer,\n        new Set<string>([\"numberedListItem\"]),\n        new Set<string>([\"bulletListItem\", \"checkListItem\", \"toggleListItem\"]),\n        options,\n      );\n      const div = document.createElement(\"div\");\n      div.append(html);\n      return div.innerHTML;\n    },\n\n    exportInlineContent: (\n      inlineContent: InlineContent<I, S>[],\n      options: { document?: Document },\n    ) => {\n      const domFragment = serializeInlineContentExternalHTML(\n        editor,\n        inlineContent as any,\n        serializer,\n        options,\n      );\n\n      const parent = document.createElement(\"div\");\n      parent.append(domFragment.cloneNode(true));\n\n      return parent.innerHTML;\n    },\n  };\n};\n","import { combineTransactionSteps } from \"@tiptap/core\";\nimport deepEqual from \"fast-deep-equal\";\nimport type { Node } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../blocks/defaultBlocks.js\";\nimport type { BlockSchema } from \"../schema/index.js\";\nimport type { InlineContentSchema } from \"../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../schema/styles/types.js\";\nimport { nodeToBlock } from \"./nodeConversions/nodeToBlock.js\";\nimport { isNodeBlock } from \"./nodeUtil.js\";\nimport { getPmSchema } from \"./pmUtil.js\";\n\n/**\n * Change detection utilities for BlockNote.\n *\n * High-level algorithm used by getBlocksChangedByTransaction:\n * 1) Merge appended transactions into one document change.\n * 2) Collect a snapshot of blocks before and after (flat map by id, and per-parent child order).\n * 3) Emit inserts and deletes by diffing ids between snapshots.\n * 4) For ids present in both snapshots:\n *    - If parentId changed, emit a move\n *    - Else if block changed (ignoring children), emit an update\n * 5) Finally, detect same-parent sibling reorders by comparing child order per parent.\n *    We use an inlined O(n log n) LIS inside detectReorderedChildren to keep a\n *    longest already-ordered subsequence and mark only the remaining items as moved.\n */\n/**\n * Gets the parent block of a node, if it has one.\n */\nfunction getParentBlockId(doc: Node, pos: number): string | undefined {\n  if (pos === 0) {\n    return undefined;\n  }\n  const resolvedPos = doc.resolve(pos);\n  for (let i = resolvedPos.depth; i > 0; i--) {\n    const parent = resolvedPos.node(i);\n    if (isNodeBlock(parent)) {\n      return parent.attrs.id;\n    }\n  }\n  return undefined;\n}\n\n/**\n * This attributes the changes to a specific source.\n */\nexport type BlockChangeSource =\n  | { type: \"local\" }\n  | { type: \"paste\" }\n  | { type: \"drop\" }\n  | { type: \"undo\" | \"redo\" | \"undo-redo\" }\n  | { type: \"yjs-remote\" };\n\nexport type BlocksChanged<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> = Array<\n  {\n    /**\n     * The affected block.\n     */\n    block: Block<BSchema, ISchema, SSchema>;\n    /**\n     * The source of the change.\n     */\n    source: BlockChangeSource;\n  } & (\n    | {\n        type: \"insert\" | \"delete\";\n        /**\n         * Insert and delete changes don't have a previous block.\n         */\n        prevBlock: undefined;\n      }\n    | {\n        type: \"update\";\n        /**\n         * The previous block.\n         */\n        prevBlock: Block<BSchema, ISchema, SSchema>;\n      }\n    | {\n        type: \"move\";\n        /**\n         * The affected block.\n         */\n        block: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The block before the move.\n         */\n        prevBlock: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The previous parent block (if it existed).\n         */\n        prevParent?: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The current parent block (if it exists).\n         */\n        currentParent?: Block<BSchema, ISchema, SSchema>;\n      }\n  )\n>;\n\nfunction determineChangeSource(transaction: Transaction): BlockChangeSource {\n  if (transaction.getMeta(\"paste\")) {\n    return { type: \"paste\" };\n  }\n  if (transaction.getMeta(\"uiEvent\") === \"drop\") {\n    return { type: \"drop\" };\n  }\n  if (transaction.getMeta(\"history$\")) {\n    return {\n      type: transaction.getMeta(\"history$\").redo ? \"redo\" : \"undo\",\n    };\n  }\n  if (transaction.getMeta(\"y-sync$\")) {\n    if (transaction.getMeta(\"y-sync$\").isUndoRedoOperation) {\n      return { type: \"undo-redo\" };\n    }\n    return { type: \"yjs-remote\" };\n  }\n  return { type: \"local\" };\n}\n\ntype BlockSnapshot<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> = {\n  byId: Record<\n    string,\n    {\n      block: Block<BSchema, ISchema, SSchema>;\n      parentId: string | undefined;\n    }\n  >;\n  childrenByParent: Record<string, string[]>;\n};\n\n/**\n * Collects a snapshot of blocks and per-parent child order in a single traversal.\n * Uses \"__root__\" to represent the root level where parentId is undefined.\n */\nfunction collectSnapshot<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(doc: Node): BlockSnapshot<BSchema, ISchema, SSchema> {\n  const ROOT_KEY = \"__root__\";\n  const byId: Record<\n    string,\n    {\n      block: Block<BSchema, ISchema, SSchema>;\n      parentId: string | undefined;\n    }\n  > = {};\n  const childrenByParent: Record<string, string[]> = {};\n  const pmSchema = getPmSchema(doc);\n  doc.descendants((node, pos) => {\n    if (!isNodeBlock(node)) {\n      return true;\n    }\n    const parentId = getParentBlockId(doc, pos);\n    const key = parentId ?? ROOT_KEY;\n    if (!childrenByParent[key]) {\n      childrenByParent[key] = [];\n    }\n    const block = nodeToBlock(node, pmSchema);\n    byId[node.attrs.id] = { block, parentId };\n    childrenByParent[key].push(node.attrs.id);\n    return true;\n  });\n  return { byId, childrenByParent };\n}\n\n/**\n * Determines which child ids have been reordered (moved) within the same parent.\n * Uses LIS to keep the longest ordered subsequence and marks the rest as moved.\n */\nfunction detectReorderedChildren(\n  prevOrder: string[] | undefined,\n  nextOrder: string[] | undefined,\n): Set<string> {\n  const moved = new Set<string>();\n  if (!prevOrder || !nextOrder) {\n    return moved;\n  }\n  // Consider only ids present in both orders (ignore inserts/deletes handled elsewhere)\n  const prevIds = new Set(prevOrder);\n  const commonNext: string[] = nextOrder.filter((id) => prevIds.has(id));\n  const commonPrev: string[] = prevOrder.filter((id) =>\n    commonNext.includes(id),\n  );\n\n  if (commonPrev.length <= 1 || commonNext.length <= 1) {\n    return moved;\n  }\n\n  // Map ids to their index in previous order\n  const indexInPrev: Record<string, number> = {};\n  for (let i = 0; i < commonPrev.length; i++) {\n    indexInPrev[commonPrev[i]] = i;\n  }\n\n  // Build sequence of indices representing next order in terms of previous indices\n  const sequence: number[] = commonNext.map((id) => indexInPrev[id]);\n\n  // Inline O(n log n) LIS with reconstruction.\n  // Why LIS? We want the smallest set of siblings to label as \"moved\".\n  // Keeping the longest subsequence that is already in order achieves this,\n  // so only items outside the LIS are reported as moves.\n  const n = sequence.length;\n  const tailsValues: number[] = [];\n  const tailsEndsAtIndex: number[] = [];\n  const previousIndexInLis: number[] = new Array(n).fill(-1);\n\n  const lowerBound = (arr: number[], target: number): number => {\n    let lo = 0;\n    let hi = arr.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (arr[mid] < target) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  };\n\n  for (let i = 0; i < n; i++) {\n    const value = sequence[i];\n    const pos = lowerBound(tailsValues, value);\n    if (pos > 0) {\n      previousIndexInLis[i] = tailsEndsAtIndex[pos - 1];\n    }\n    if (pos === tailsValues.length) {\n      tailsValues.push(value);\n      tailsEndsAtIndex.push(i);\n    } else {\n      tailsValues[pos] = value;\n      tailsEndsAtIndex[pos] = i;\n    }\n  }\n\n  const lisIndexSet = new Set<number>();\n  let k = tailsEndsAtIndex[tailsEndsAtIndex.length - 1] ?? -1;\n  while (k !== -1) {\n    lisIndexSet.add(k);\n    k = previousIndexInLis[k];\n  }\n\n  // Items not part of LIS are considered moved\n  for (let i = 0; i < commonNext.length; i++) {\n    if (!lisIndexSet.has(i)) {\n      moved.add(commonNext[i]);\n    }\n  }\n  return moved;\n}\n\n/**\n * Get the blocks that were changed by a transaction.\n */\nexport function getBlocksChangedByTransaction<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n>(\n  transaction: Transaction,\n  appendedTransactions: Transaction[] = [],\n): BlocksChanged<BSchema, ISchema, SSchema> {\n  const source = determineChangeSource(transaction);\n  const combinedTransaction = combineTransactionSteps(transaction.before, [\n    transaction,\n    ...appendedTransactions,\n  ]);\n\n  const prevSnap = collectSnapshot<BSchema, ISchema, SSchema>(\n    combinedTransaction.before,\n  );\n  const nextSnap = collectSnapshot<BSchema, ISchema, SSchema>(\n    combinedTransaction.doc,\n  );\n\n  const changes: BlocksChanged<BSchema, ISchema, SSchema> = [];\n  const changedIds = new Set<string>();\n\n  // Handle inserted blocks\n  Object.keys(nextSnap.byId)\n    .filter((id) => !(id in prevSnap.byId))\n    .forEach((id) => {\n      changes.push({\n        type: \"insert\",\n        block: nextSnap.byId[id].block,\n        source,\n        prevBlock: undefined,\n      });\n      changedIds.add(id);\n    });\n\n  // Handle deleted blocks\n  Object.keys(prevSnap.byId)\n    .filter((id) => !(id in nextSnap.byId))\n    .forEach((id) => {\n      changes.push({\n        type: \"delete\",\n        block: prevSnap.byId[id].block,\n        source,\n        prevBlock: undefined,\n      });\n      changedIds.add(id);\n    });\n\n  // Handle updated, moved to different parent, indented, outdented blocks\n  Object.keys(nextSnap.byId)\n    .filter((id) => id in prevSnap.byId)\n    .forEach((id) => {\n      const prev = prevSnap.byId[id];\n      const next = nextSnap.byId[id];\n      const isParentDifferent = prev.parentId !== next.parentId;\n\n      if (isParentDifferent) {\n        changes.push({\n          type: \"move\",\n          block: next.block,\n          prevBlock: prev.block,\n          source,\n          prevParent: prev.parentId\n            ? prevSnap.byId[prev.parentId]?.block\n            : undefined,\n          currentParent: next.parentId\n            ? nextSnap.byId[next.parentId]?.block\n            : undefined,\n        });\n        changedIds.add(id);\n      } else if (\n        // Compare blocks while ignoring children to avoid reporting a parent\n        // update when only descendants changed.\n        !deepEqual(\n          { ...prev.block, children: undefined } as any,\n          { ...next.block, children: undefined } as any,\n        )\n      ) {\n        changes.push({\n          type: \"update\",\n          block: next.block,\n          prevBlock: prev.block,\n          source,\n        });\n        changedIds.add(id);\n      }\n    });\n\n  // Handle sibling reorders (parent unchanged but relative order changed)\n  const prevOrderByParent = prevSnap.childrenByParent;\n  const nextOrderByParent = nextSnap.childrenByParent;\n\n  // Use a special key for root-level siblings\n  const ROOT_KEY = \"__root__\";\n  const parents = new Set<string>([\n    ...Object.keys(prevOrderByParent),\n    ...Object.keys(nextOrderByParent),\n  ]);\n\n  const addedMoveForId = new Set<string>();\n\n  parents.forEach((parentKey) => {\n    const movedWithinParent = detectReorderedChildren(\n      prevOrderByParent[parentKey],\n      nextOrderByParent[parentKey],\n    );\n    if (movedWithinParent.size === 0) {\n      return;\n    }\n    movedWithinParent.forEach((id) => {\n      // Only consider ids that exist in both snapshots and whose parent truly did not change\n      const prev = prevSnap.byId[id];\n      const next = nextSnap.byId[id];\n      if (!prev || !next) {\n        return;\n      }\n      if (prev.parentId !== next.parentId) {\n        return;\n      }\n      // Skip if already accounted for by insert/delete/update/parent move\n      if (changedIds.has(id)) {\n        return;\n      }\n      // Verify we're addressing the right parent bucket\n      const bucketKey = prev.parentId ?? ROOT_KEY;\n      if (bucketKey !== parentKey) {\n        return;\n      }\n      if (addedMoveForId.has(id)) {\n        return;\n      }\n      addedMoveForId.add(id);\n      changes.push({\n        type: \"move\",\n        block: next.block,\n        prevBlock: prev.block,\n        source,\n        prevParent: prev.parentId\n          ? prevSnap.byId[prev.parentId]?.block\n          : undefined,\n        currentParent: next.parentId\n          ? nextSnap.byId[next.parentId]?.block\n          : undefined,\n      });\n      changedIds.add(id);\n    });\n  });\n\n  return changes;\n}\n","import { Plugin, PluginKey, Transaction } from \"prosemirror-state\";\nimport {\n  BlocksChanged,\n  getBlocksChangedByTransaction,\n} from \"../../api/getBlocksChangedByTransaction.js\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\n/**\n * This plugin can filter transactions before they are applied to the editor, but with a higher-level API than `filterTransaction` from prosemirror.\n */\nexport const BlockChangeExtension = createExtension(() => {\n  const beforeChangeCallbacks: ((context: {\n    getChanges: () => BlocksChanged<any, any, any>;\n    tr: Transaction;\n  }) => boolean | void)[] = [];\n  return {\n    key: \"blockChange\",\n    prosemirrorPlugins: [\n      new Plugin({\n        key: new PluginKey(\"blockChange\"),\n        filterTransaction: (tr) => {\n          let changes:\n            | ReturnType<typeof getBlocksChangedByTransaction<any, any, any>>\n            | undefined = undefined;\n\n          return beforeChangeCallbacks.reduce((acc, cb) => {\n            if (acc === false) {\n              // We only care that we hit a `false` result, so we can stop iterating.\n              return acc;\n            }\n            return (\n              cb({\n                getChanges() {\n                  if (changes) {\n                    return changes;\n                  }\n                  changes = getBlocksChangedByTransaction<any, any, any>(tr);\n                  return changes;\n                },\n                tr,\n              }) !== false\n            );\n          }, true);\n        },\n      }),\n    ],\n\n    /**\n     * Subscribe to the block change events.\n     */\n    subscribe(\n      callback: (context: {\n        getChanges: () => BlocksChanged<any, any, any>;\n        tr: Transaction;\n      }) => boolean | void,\n    ) {\n      beforeChangeCallbacks.push(callback);\n\n      return () => {\n        beforeChangeCallbacks.splice(\n          beforeChangeCallbacks.indexOf(callback),\n          1,\n        );\n      };\n    },\n  } as const;\n});\n","import { defaultSelectionBuilder, yCursorPlugin } from \"y-prosemirror\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { CollaborationOptions } from \"./Collaboration.js\";\n\nexport type CollaborationUser = {\n  name: string;\n  color: string;\n  [key: string]: string;\n};\n\n/**\n * Determine whether the foreground color should be white or black based on a provided background color\n * Inspired by: https://stackoverflow.com/a/3943023\n */\nfunction isDarkColor(bgColor: string): boolean {\n  const color = bgColor.charAt(0) === \"#\" ? bgColor.substring(1, 7) : bgColor;\n  const r = parseInt(color.substring(0, 2), 16); // hexToR\n  const g = parseInt(color.substring(2, 4), 16); // hexToG\n  const b = parseInt(color.substring(4, 6), 16); // hexToB\n  const uicolors = [r / 255, g / 255, b / 255];\n  const c = uicolors.map((col) => {\n    if (col <= 0.03928) {\n      return col / 12.92;\n    }\n    return Math.pow((col + 0.055) / 1.055, 2.4);\n  });\n  const L = 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];\n  return L <= 0.179;\n}\n\nfunction defaultCursorRender(user: CollaborationUser) {\n  const cursorElement = document.createElement(\"span\");\n\n  cursorElement.classList.add(\"bn-collaboration-cursor__base\");\n\n  const caretElement = document.createElement(\"span\");\n  caretElement.setAttribute(\"contentedEditable\", \"false\");\n  caretElement.classList.add(\"bn-collaboration-cursor__caret\");\n  caretElement.setAttribute(\n    \"style\",\n    `background-color: ${user.color}; color: ${\n      isDarkColor(user.color) ? \"white\" : \"black\"\n    }`,\n  );\n\n  const labelElement = document.createElement(\"span\");\n\n  labelElement.classList.add(\"bn-collaboration-cursor__label\");\n  labelElement.setAttribute(\n    \"style\",\n    `background-color: ${user.color}; color: ${\n      isDarkColor(user.color) ? \"white\" : \"black\"\n    }`,\n  );\n  labelElement.insertBefore(document.createTextNode(user.name), null);\n\n  caretElement.insertBefore(labelElement, null);\n\n  cursorElement.insertBefore(document.createTextNode(\"\\u2060\"), null); // Non-breaking space\n  cursorElement.insertBefore(caretElement, null);\n  cursorElement.insertBefore(document.createTextNode(\"\\u2060\"), null); // Non-breaking space\n\n  return cursorElement;\n}\n\nexport const YCursorExtension = createExtension(\n  ({ options }: ExtensionOptions<CollaborationOptions>) => {\n    const recentlyUpdatedCursors = new Map();\n    const awareness =\n      options.provider &&\n      \"awareness\" in options.provider &&\n      typeof options.provider.awareness === \"object\"\n        ? options.provider.awareness\n        : undefined;\n    if (awareness) {\n      if (\n        \"setLocalStateField\" in awareness &&\n        typeof awareness.setLocalStateField === \"function\"\n      ) {\n        awareness.setLocalStateField(\"user\", options.user);\n      }\n      if (\"on\" in awareness && typeof awareness.on === \"function\") {\n        if (options.showCursorLabels !== \"always\") {\n          awareness.on(\n            \"change\",\n            ({\n              updated,\n            }: {\n              added: Array<number>;\n              updated: Array<number>;\n              removed: Array<number>;\n            }) => {\n              for (const clientID of updated) {\n                const cursor = recentlyUpdatedCursors.get(clientID);\n\n                if (cursor) {\n                  cursor.element.setAttribute(\"data-active\", \"\");\n\n                  if (cursor.hideTimeout) {\n                    clearTimeout(cursor.hideTimeout);\n                  }\n\n                  recentlyUpdatedCursors.set(clientID, {\n                    element: cursor.element,\n                    hideTimeout: setTimeout(() => {\n                      cursor.element.removeAttribute(\"data-active\");\n                    }, 2000),\n                  });\n                }\n              }\n            },\n          );\n        }\n      }\n    }\n\n    return {\n      key: \"yCursor\",\n      prosemirrorPlugins: [\n        awareness\n          ? yCursorPlugin(awareness, {\n              selectionBuilder: defaultSelectionBuilder,\n              cursorBuilder(user: CollaborationUser, clientID: number) {\n                let cursorData = recentlyUpdatedCursors.get(clientID);\n\n                if (!cursorData) {\n                  const cursorElement = (\n                    options.renderCursor ?? defaultCursorRender\n                  )(user);\n\n                  if (options.showCursorLabels !== \"always\") {\n                    cursorElement.addEventListener(\"mouseenter\", () => {\n                      const cursor = recentlyUpdatedCursors.get(clientID)!;\n                      cursor.element.setAttribute(\"data-active\", \"\");\n\n                      if (cursor.hideTimeout) {\n                        clearTimeout(cursor.hideTimeout);\n                        recentlyUpdatedCursors.set(clientID, {\n                          element: cursor.element,\n                          hideTimeout: undefined,\n                        });\n                      }\n                    });\n\n                    cursorElement.addEventListener(\"mouseleave\", () => {\n                      const cursor = recentlyUpdatedCursors.get(clientID)!;\n\n                      recentlyUpdatedCursors.set(clientID, {\n                        element: cursor.element,\n                        hideTimeout: setTimeout(() => {\n                          cursor.element.removeAttribute(\"data-active\");\n                        }, 2000),\n                      });\n                    });\n                  }\n\n                  cursorData = {\n                    element: cursorElement,\n                    hideTimeout: undefined,\n                  };\n\n                  recentlyUpdatedCursors.set(clientID, cursorData);\n                }\n\n                return cursorData.element;\n              },\n            })\n          : undefined,\n      ].filter(Boolean),\n      dependsOn: [\"ySync\"],\n      updateUser(user: { name: string; color: string; [key: string]: string }) {\n        awareness?.setLocalStateField(\"user\", user);\n      },\n    } as const;\n  },\n);\n","import { ySyncPlugin } from \"y-prosemirror\";\nimport {\n  ExtensionOptions,\n  createExtension,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { CollaborationOptions } from \"./Collaboration.js\";\n\nexport const YSyncExtension = createExtension(\n  ({ options }: ExtensionOptions<Pick<CollaborationOptions, \"fragment\">>) => {\n    return {\n      key: \"ySync\",\n      prosemirrorPlugins: [ySyncPlugin(options.fragment)],\n      runsBefore: [\"default\"],\n    } as const;\n  },\n);\n","import { redoCommand, undoCommand, yUndoPlugin } from \"y-prosemirror\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport const YUndoExtension = createExtension(() => {\n  return {\n    key: \"yUndo\",\n    prosemirrorPlugins: [yUndoPlugin()],\n    dependsOn: [\"yCursor\", \"ySync\"],\n    undoCommand: undoCommand,\n    redoCommand: redoCommand,\n  } as const;\n});\n","import { yUndoPluginKey } from \"y-prosemirror\";\nimport * as Y from \"yjs\";\nimport {\n  createExtension,\n  createStore,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { CollaborationOptions } from \"./Collaboration.js\";\nimport { YCursorExtension } from \"./YCursorPlugin.js\";\nimport { YSyncExtension } from \"./YSync.js\";\nimport { YUndoExtension } from \"./YUndo.js\";\n\n/**\n * To find a fragment in another ydoc, we need to search for it.\n */\nfunction findTypeInOtherYdoc<T extends Y.AbstractType<any>>(\n  ytype: T,\n  otherYdoc: Y.Doc,\n): T {\n  const ydoc = ytype.doc!;\n  if (ytype._item === null) {\n    /**\n     * If is a root type, we need to find the root key in the original ydoc\n     * and use it to get the type in the other ydoc.\n     */\n    const rootKey = Array.from(ydoc.share.keys()).find(\n      (key) => ydoc.share.get(key) === ytype,\n    );\n    if (rootKey == null) {\n      throw new Error(\"type does not exist in other ydoc\");\n    }\n    return otherYdoc.get(rootKey, ytype.constructor as new () => T) as T;\n  } else {\n    /**\n     * If it is a sub type, we use the item id to find the history type.\n     */\n    const ytypeItem = ytype._item;\n    const otherStructs = otherYdoc.store.clients.get(ytypeItem.id.client) ?? [];\n    const itemIndex = Y.findIndexSS(otherStructs, ytypeItem.id.clock);\n    const otherItem = otherStructs[itemIndex] as Y.Item;\n    const otherContent = otherItem.content as Y.ContentType;\n    return otherContent.type as T;\n  }\n}\n\nexport const ForkYDocExtension = createExtension(\n  ({ editor, options }: ExtensionOptions<CollaborationOptions>) => {\n    let forkedState:\n      | {\n          originalFragment: Y.XmlFragment;\n          undoStack: Y.UndoManager[\"undoStack\"];\n          forkedFragment: Y.XmlFragment;\n        }\n      | undefined = undefined;\n\n    const store = createStore({ isForked: false });\n\n    return {\n      key: \"yForkDoc\",\n      store,\n      /**\n       * Fork the Y.js document from syncing to the remote,\n       * allowing modifications to the document without affecting the remote.\n       * These changes can later be rolled back or applied to the remote.\n       */\n      fork() {\n        if (forkedState) {\n          return;\n        }\n\n        const originalFragment = options.fragment;\n\n        if (!originalFragment) {\n          throw new Error(\"No fragment to fork from\");\n        }\n\n        const doc = new Y.Doc();\n        // Copy the original document to a new Yjs document\n        Y.applyUpdate(doc, Y.encodeStateAsUpdate(originalFragment.doc!));\n\n        // Find the forked fragment in the new Yjs document\n        const forkedFragment = findTypeInOtherYdoc(originalFragment, doc);\n\n        forkedState = {\n          undoStack: yUndoPluginKey.getState(editor.prosemirrorState)!\n            .undoManager.undoStack,\n          originalFragment,\n          forkedFragment,\n        };\n\n        // Need to reset all the yjs plugins\n        editor.unregisterExtension([\n          YUndoExtension,\n          YCursorExtension,\n          YSyncExtension,\n        ]);\n        const newOptions = {\n          ...options,\n          fragment: forkedFragment,\n        };\n        // Register them again, based on the new forked fragment\n        editor.registerExtension([\n          YSyncExtension(newOptions),\n          // No need to register the cursor plugin again, it's a local fork\n          YUndoExtension(),\n        ]);\n\n        // Tell the store that the editor is now forked\n        store.setState({ isForked: true });\n      },\n\n      /**\n       * Resume syncing the Y.js document to the remote\n       * If `keepChanges` is true, any changes that have been made to the forked document will be applied to the original document.\n       * Otherwise, the original document will be restored and the changes will be discarded.\n       */\n      merge({ keepChanges }: { keepChanges: boolean }) {\n        if (!forkedState) {\n          return;\n        }\n        // Remove the forked fragment's plugins\n        editor.unregisterExtension([\"ySync\", \"yCursor\", \"yUndo\"]);\n\n        const { originalFragment, forkedFragment, undoStack } = forkedState;\n        // Register the plugins again, based on the original fragment (which is still in the original options)\n        editor.registerExtension([\n          YSyncExtension(options),\n          YCursorExtension(options),\n          YUndoExtension(),\n        ]);\n\n        // Reset the undo stack to the original undo stack\n        yUndoPluginKey.getState(\n          editor.prosemirrorState,\n        )!.undoManager.undoStack = undoStack;\n\n        if (keepChanges) {\n          // Apply any changes that have been made to the fork, onto the original doc\n          const update = Y.encodeStateAsUpdate(\n            forkedFragment.doc!,\n            Y.encodeStateVector(originalFragment.doc!),\n          );\n          // Applying this change will add to the undo stack, allowing it to be undone normally\n          Y.applyUpdate(originalFragment.doc!, update, editor);\n        }\n        // Reset the forked state\n        forkedState = undefined;\n        // Tell the store that the editor is no longer forked\n        store.setState({ isForked: false });\n      },\n    } as const;\n  },\n);\n","import * as Y from \"yjs\";\n\nimport { MigrationRule } from \"./migrationRule.js\";\nimport { defaultProps } from \"../../../../blocks/defaultProps.js\";\n\n// Helper function to recursively traverse a `Y.XMLElement` and its descendant\n// elements.\nconst traverseElement = (\n  rootElement: Y.XmlElement,\n  cb: (element: Y.XmlElement) => void,\n) => {\n  cb(rootElement);\n  rootElement.forEach((element) => {\n    if (element instanceof Y.XmlElement) {\n      traverseElement(element, cb);\n    }\n  });\n};\n\n// Moves `textColor` and `backgroundColor` attributes from `blockContainer`\n// nodes to their child `blockContent` nodes. This is due to a schema change\n// introduced in PR #TODO.\nexport const moveColorAttributes: MigrationRule = (fragment, tr) => {\n  // Stores necessary info for all `blockContainer` nodes which still have\n  // `textColor` or `backgroundColor` attributes that need to be moved.\n  const targetBlockContainers: Map<\n    string,\n    {\n      textColor: string | undefined;\n      backgroundColor: string | undefined;\n    }\n  > = new Map();\n  // Finds all elements which still have `textColor` or `backgroundColor`\n  // attributes in the current Yjs fragment.\n  fragment.forEach((element) => {\n    if (element instanceof Y.XmlElement) {\n      traverseElement(element, (element) => {\n        if (\n          element.nodeName === \"blockContainer\" &&\n          element.hasAttribute(\"id\")\n        ) {\n          const textColor = element.getAttribute(\"textColor\");\n          const backgroundColor = element.getAttribute(\"backgroundColor\");\n\n          const colors = {\n            textColor:\n              textColor === defaultProps.textColor.default\n                ? undefined\n                : textColor,\n            backgroundColor:\n              backgroundColor === defaultProps.backgroundColor.default\n                ? undefined\n                : backgroundColor,\n          };\n\n          if (colors.textColor || colors.backgroundColor) {\n            targetBlockContainers.set(element.getAttribute(\"id\")!, colors);\n          }\n        }\n      });\n    }\n  });\n\n  if (targetBlockContainers.size === 0) {\n    return false;\n  }\n\n  // Appends transactions to add the `textColor` and `backgroundColor`\n  // attributes found on each `blockContainer` node to move them to the child\n  // `blockContent` node.\n  tr.doc.descendants((node, pos) => {\n    if (\n      node.type.name === \"blockContainer\" &&\n      targetBlockContainers.has(node.attrs.id)\n    ) {\n      const el = tr.doc.nodeAt(pos + 1);\n      if (!el) {\n        throw new Error(\"No element found\");\n      }\n\n      tr.setNodeMarkup(pos + 1, undefined, {\n        // preserve existing attributes\n        ...el.attrs,\n        // add the textColor and backgroundColor attributes\n        ...targetBlockContainers.get(node.attrs.id),\n      });\n    }\n  });\n\n  return true;\n};\n","import { MigrationRule } from \"./migrationRule.js\";\nimport { moveColorAttributes } from \"./moveColorAttributes.js\";\n\nexport default [moveColorAttributes] as MigrationRule[];\n","import { Plugin, PluginKey } from \"@tiptap/pm/state\";\nimport * as Y from \"yjs\";\n\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../../editor/BlockNoteExtension.js\";\nimport migrationRules from \"./migrationRules/index.js\";\n\n// This plugin allows us to update collaboration YDocs whenever BlockNote's\n// underlying ProseMirror schema changes. The plugin reads the current Yjs\n// fragment and dispatches additional transactions to the ProseMirror state, in\n// case things are found in the fragment that don't adhere to the editor schema\n// and need to be fixed. These fixes are defined as `MigrationRule`s within the\n// `migrationRules` directory.\nexport const SchemaMigration = createExtension(\n  ({ options }: ExtensionOptions<{ fragment: Y.XmlFragment }>) => {\n    let migrationDone = false;\n    const pluginKey = new PluginKey(\"schemaMigration\");\n\n    return {\n      key: \"schemaMigration\",\n      prosemirrorPlugins: [\n        new Plugin({\n          key: pluginKey,\n          appendTransaction: (transactions, _oldState, newState) => {\n            if (migrationDone) {\n              return undefined;\n            }\n\n            if (\n              // If any of the transactions are not due to a yjs sync, we don't need to run the migration\n              !transactions.some((tr) => tr.getMeta(\"y-sync$\")) ||\n              // If none of the transactions result in a document change, we don't need to run the migration\n              transactions.every((tr) => !tr.docChanged) ||\n              // If the fragment is still empty, we can't run the migration (since it has not yet been applied to the Y.Doc)\n              !options.fragment.firstChild\n            ) {\n              return undefined;\n            }\n\n            const tr = newState.tr;\n            for (const migrationRule of migrationRules) {\n              migrationRule(options.fragment, tr);\n            }\n\n            migrationDone = true;\n\n            if (!tr.docChanged) {\n              return undefined;\n            }\n\n            return tr;\n          },\n        }),\n      ],\n    } as const;\n  },\n);\n","import { dropCursor } from \"prosemirror-dropcursor\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { BlockNoteEditorOptions } from \"../../editor/BlockNoteEditor.js\";\n\nexport const DropCursorExtension = createExtension(\n  ({\n    editor,\n    options,\n  }: ExtensionOptions<\n    Pick<BlockNoteEditorOptions<any, any, any>, \"dropCursor\">\n  >) => {\n    return {\n      key: \"dropCursor\",\n      prosemirrorPlugins: [\n        (options.dropCursor ?? dropCursor)({\n          width: 5,\n          color: \"#ddeeff\",\n          editor: editor,\n        }),\n      ],\n    } as const;\n  },\n);\n","import { NodeSelection, TextSelection } from \"prosemirror-state\";\n\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\n\nexport const FormattingToolbarExtension = createExtension(({ editor }) => {\n  const store = createStore(false);\n\n  const shouldShow = () => {\n    return editor.transact((tr) => {\n      // Don't show if the selection is empty, or is a text selection with no\n      // text.\n      if (tr.selection.empty) {\n        return false;\n      }\n\n      // Don't show if a block with inline content is selected.\n      if (\n        tr.selection instanceof NodeSelection &&\n        (tr.selection.node.type.spec.content === \"inline*\" ||\n          tr.selection.node.firstChild?.type.spec.content === \"inline*\")\n      ) {\n        return false;\n      }\n\n      // Don't show if the selection is a text selection but contains no text.\n      if (\n        tr.selection instanceof TextSelection &&\n        tr.doc.textBetween(tr.selection.from, tr.selection.to).length === 0\n      ) {\n        return false;\n      }\n\n      // Searches the content of the selection to see if it spans a node with a\n      // code spec.\n      let spansCode = false;\n      tr.selection.content().content.descendants((node) => {\n        if (node.type.spec.code) {\n          spansCode = true;\n        }\n        return !spansCode; // keep descending if we haven't found a code block\n      });\n\n      // Don't show if the selection spans a code block.\n      if (spansCode) {\n        return false;\n      }\n\n      // Show toolbar otherwise.\n      return true;\n    });\n  };\n\n  return {\n    key: \"formattingToolbar\",\n    store,\n    mount({ dom, signal }) {\n      /**\n       * We want to mimic the Notion behavior of not showing the toolbar while the user is holding down the mouse button (to create a selection)\n       */\n      let preventShowWhileMouseDown = false;\n\n      const unsubscribeOnChange = editor.onChange(() => {\n        if (preventShowWhileMouseDown) {\n          return;\n        }\n        // re-evaluate whether the toolbar should be shown\n        store.setState(shouldShow());\n      });\n      const unsubscribeOnSelectionChange = editor.onSelectionChange(() => {\n        if (preventShowWhileMouseDown) {\n          return;\n        }\n        // re-evaluate whether the toolbar should be shown\n        store.setState(shouldShow());\n      });\n\n      // To mimic Notion's behavior, we listen to the mouse down event to set the `preventShowWhileMouseDown` flag\n      dom.addEventListener(\n        \"pointerdown\",\n        () => {\n          preventShowWhileMouseDown = true;\n          store.setState(false);\n        },\n        { signal },\n      );\n      // To mimic Notion's behavior, we listen to the mouse up event to reset the `preventShowWhileMouseDown` flag and show the toolbar (if it should)\n      editor.prosemirrorView.root.addEventListener(\n        \"pointerup\",\n        () => {\n          preventShowWhileMouseDown = false;\n          // We only want to re-show the toolbar if the mouse made the selection\n          if (editor.isFocused()) {\n            store.setState(shouldShow());\n          }\n        },\n        { signal, capture: true },\n      );\n      // If the pointer gets cancelled, we don't want to be stuck in the `preventShowWhileMouseDown` state\n      dom.addEventListener(\n        \"pointercancel\",\n        () => {\n          preventShowWhileMouseDown = false;\n        },\n        {\n          signal,\n          capture: true,\n        },\n      );\n\n      signal.addEventListener(\"abort\", () => {\n        unsubscribeOnChange();\n        unsubscribeOnSelectionChange();\n      });\n    },\n  } as const;\n});\n","import { history, redo, undo } from \"@tiptap/pm/history\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport const HistoryExtension = createExtension(() => {\n  return {\n    key: \"history\",\n    prosemirrorPlugins: [history()],\n    undoCommand: undo,\n    redoCommand: redo,\n  } as const;\n});\n","import { getMarkRange, posToDOMRect } from \"@tiptap/core\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { getPmSchema } from \"../../api/pmUtil.js\";\n\nexport const LinkToolbarExtension = createExtension(({ editor }) => {\n  function getLinkElementAtPos(pos: number) {\n    let currentNode = editor.prosemirrorView.nodeDOM(pos);\n    while (currentNode && currentNode.parentElement) {\n      if (currentNode.nodeName === \"A\") {\n        return currentNode as HTMLAnchorElement;\n      }\n      currentNode = currentNode.parentElement;\n    }\n    return null;\n  }\n\n  function getMarkAtPos(pos: number, markType: string) {\n    return editor.transact((tr) => {\n      const resolvedPos = tr.doc.resolve(pos);\n      const mark = resolvedPos\n        .marks()\n        .find((mark) => mark.type.name === markType);\n\n      if (!mark) {\n        return;\n      }\n\n      const markRange = getMarkRange(resolvedPos, mark.type);\n      if (!markRange) {\n        return;\n      }\n\n      return {\n        range: markRange,\n        mark,\n        get text() {\n          return tr.doc.textBetween(markRange.from, markRange.to);\n        },\n        get position() {\n          // to minimize re-renders, we convert to JSON, which is the same shape anyway\n          return posToDOMRect(\n            editor.prosemirrorView,\n            markRange.from,\n            markRange.to,\n          ).toJSON() as DOMRect;\n        },\n      };\n    });\n  }\n\n  function getLinkAtSelection() {\n    return editor.transact((tr) => {\n      const selection = tr.selection;\n      if (!selection.empty) {\n        return undefined;\n      }\n      return getMarkAtPos(selection.anchor, \"link\");\n    });\n  }\n\n  return {\n    key: \"linkToolbar\",\n\n    getLinkAtSelection,\n    getLinkElementAtPos,\n    getMarkAtPos,\n\n    getLinkAtElement(element: HTMLElement) {\n      return editor.transact(() => {\n        const posAtElement = editor.prosemirrorView.posAtDOM(element, 0) + 1;\n        return getMarkAtPos(posAtElement, \"link\");\n      });\n    },\n\n    editLink(\n      url: string,\n      text: string,\n      position = editor.transact((tr) => tr.selection.anchor),\n    ) {\n      editor.transact((tr) => {\n        const pmSchema = getPmSchema(tr);\n        const { range } = getMarkAtPos(position + 1, \"link\") || {\n          range: {\n            from: tr.selection.from,\n            to: tr.selection.to,\n          },\n        };\n        if (!range) {\n          return;\n        }\n        tr.insertText(text, range.from, range.to);\n        tr.addMark(\n          range.from,\n          range.from + text.length,\n          pmSchema.mark(\"link\", { href: url }),\n        );\n      });\n      editor.prosemirrorView.focus();\n    },\n    deleteLink(position = editor.transact((tr) => tr.selection.anchor)) {\n      editor.transact((tr) => {\n        const pmSchema = getPmSchema(tr);\n        const { range } = getMarkAtPos(position + 1, \"link\") || {\n          range: {\n            from: tr.selection.from,\n            to: tr.selection.to,\n          },\n        };\n        if (!range) {\n          return;\n        }\n\n        tr.removeMark(range.from, range.to, pmSchema.marks[\"link\"]).setMeta(\n          \"preventAutolink\",\n          true,\n        );\n      });\n      editor.prosemirrorView.focus();\n    },\n  } as const;\n});\n","export const VALID_LINK_PROTOCOLS = [\n  \"http\",\n  \"https\",\n  \"ftp\",\n  \"ftps\",\n  \"mailto\",\n  \"tel\",\n  \"callto\",\n  \"sms\",\n  \"cid\",\n  \"xmpp\",\n];\nexport const DEFAULT_LINK_PROTOCOL = \"https\";\n","import { Plugin, PluginKey, TextSelection } from \"prosemirror-state\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(\"node-selection-keyboard\");\n// By default, typing with a node selection active will cause ProseMirror to\n// replace the node with one that contains editable content. This plugin blocks\n// this behaviour without also blocking things like keyboard shortcuts:\n//\n// - Lets through key presses that do not include alphanumeric characters. This\n// includes things like backspace/delete/home/end/etc.\n// - Lets through any key presses that include ctrl/meta keys. These will be\n// shortcuts of some kind like ctrl+C/mod+C.\n// - Special case for Enter key which creates a new paragraph block below and\n// sets the selection to it. This is just to bring the UX closer to Notion\n//\n// While a more elegant solution would probably process transactions instead of\n// keystrokes, this brings us most of the way to Notion's UX without much added\n// complexity.\nexport const NodeSelectionKeyboardExtension = createExtension(\n  () =>\n    ({\n      key: \"nodeSelectionKeyboard\",\n      prosemirrorPlugins: [\n        new Plugin({\n          key: PLUGIN_KEY,\n          props: {\n            handleKeyDown: (view, event) => {\n              // Checks for node selection\n              if (\"node\" in view.state.selection) {\n                // Checks if key press uses ctrl/meta modifier\n                if (event.ctrlKey || event.metaKey) {\n                  return false;\n                }\n                // Checks if key press is alphanumeric\n                if (event.key.length === 1) {\n                  event.preventDefault();\n\n                  return true;\n                }\n                // Checks if key press is Enter\n                if (\n                  event.key === \"Enter\" &&\n                  !event.shiftKey &&\n                  !event.altKey &&\n                  !event.ctrlKey &&\n                  !event.metaKey\n                ) {\n                  const tr = view.state.tr;\n                  view.dispatch(\n                    tr\n                      .insert(\n                        view.state.tr.selection.$to.after(),\n                        view.state.schema.nodes[\"paragraph\"].createChecked(),\n                      )\n                      .setSelection(\n                        new TextSelection(\n                          tr.doc.resolve(\n                            view.state.tr.selection.$to.after() + 1,\n                          ),\n                        ),\n                      ),\n                  );\n\n                  return true;\n                }\n              }\n\n              return false;\n            },\n          },\n        }),\n      ],\n    }) as const,\n);\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { v4 } from \"uuid\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { BlockNoteEditorOptions } from \"../../editor/BlockNoteEditor.js\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-placeholder`);\n\nexport const PlaceholderExtension = createExtension(\n  ({\n    editor,\n    options,\n  }: ExtensionOptions<\n    Pick<BlockNoteEditorOptions<any, any, any>, \"placeholders\">\n  >) => {\n    const placeholders = options.placeholders;\n    return {\n      key: \"placeholder\",\n      prosemirrorPlugins: [\n        new Plugin({\n          key: PLUGIN_KEY,\n          view: (view) => {\n            const uniqueEditorSelector = `placeholder-selector-${v4()}`;\n            view.dom.classList.add(uniqueEditorSelector);\n            const styleEl = document.createElement(\"style\");\n\n            const nonce = editor._tiptapEditor.options.injectNonce;\n            if (nonce) {\n              styleEl.setAttribute(\"nonce\", nonce);\n            }\n\n            if (view.root instanceof window.ShadowRoot) {\n              view.root.append(styleEl);\n            } else {\n              view.root.head.appendChild(styleEl);\n            }\n\n            const styleSheet = styleEl.sheet!;\n\n            const getSelector = (additionalSelectors = \"\") =>\n              `.${uniqueEditorSelector} .bn-block-content${additionalSelectors} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;\n\n            try {\n              // FIXME: the names \"default\" and \"emptyDocument\" are hardcoded\n              const {\n                default: defaultPlaceholder,\n                emptyDocument: emptyPlaceholder,\n                ...rest\n              } = placeholders || {};\n\n              // add block specific placeholders\n              for (const [blockType, placeholder] of Object.entries(rest)) {\n                const blockTypeSelector = `[data-content-type=\"${blockType}\"]`;\n\n                styleSheet.insertRule(\n                  `${getSelector(blockTypeSelector)} { content: ${JSON.stringify(\n                    placeholder,\n                  )}; }`,\n                );\n              }\n\n              const onlyBlockSelector = `[data-is-only-empty-block]`;\n              const mustBeFocusedSelector = `[data-is-empty-and-focused]`;\n\n              // placeholder for when there's only one empty block\n              styleSheet.insertRule(\n                `${getSelector(onlyBlockSelector)} { content: ${JSON.stringify(\n                  emptyPlaceholder,\n                )}; }`,\n              );\n\n              // placeholder for default blocks, only when the cursor is in the block (mustBeFocused)\n              styleSheet.insertRule(\n                `${getSelector(mustBeFocusedSelector)} { content: ${JSON.stringify(\n                  defaultPlaceholder,\n                )}; }`,\n              );\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.warn(\n                `Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)`,\n                e,\n              );\n            }\n\n            return {\n              destroy: () => {\n                if (view.root instanceof window.ShadowRoot) {\n                  view.root.removeChild(styleEl);\n                } else {\n                  view.root.head.removeChild(styleEl);\n                }\n              },\n            };\n          },\n          props: {\n            decorations: (state) => {\n              const { doc, selection } = state;\n\n              if (!editor.isEditable) {\n                return;\n              }\n\n              if (!selection.empty) {\n                return;\n              }\n\n              // Don't show placeholder when the cursor is inside a code block\n              if (selection.$from.parent.type.spec.code) {\n                return;\n              }\n\n              const decs = [];\n\n              // decoration for when there's only one empty block\n              // positions are hardcoded for now\n              if (state.doc.content.size === 6) {\n                decs.push(\n                  Decoration.node(2, 4, {\n                    \"data-is-only-empty-block\": \"true\",\n                  }),\n                );\n              }\n\n              const $pos = selection.$anchor;\n              const node = $pos.parent;\n\n              if (node.content.size === 0) {\n                const before = $pos.before();\n\n                decs.push(\n                  Decoration.node(before, before + node.nodeSize, {\n                    \"data-is-empty-and-focused\": \"true\",\n                  }),\n                );\n              }\n\n              return DecorationSet.create(doc, decs);\n            },\n          },\n        }),\n      ],\n    } as const;\n  },\n);\n","import { findChildren } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(`previous-blocks`);\n\nconst nodeAttributes: Record<string, string> = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\",\n};\n\n/**\n * This plugin tracks transformation of Block node attributes, so we can support CSS transitions.\n *\n * Problem it solves: ProseMirror recreates the DOM when transactions happen. So when a transaction changes a Node attribute,\n * it results in a completely new DOM element. This means CSS transitions don't work.\n *\n * Solution: When attributes change on a node, this plugin sets a data-* attribute with the \"previous\" value. This way we can still use CSS transitions. (See block.module.css)\n */\nexport const PreviousBlockTypeExtension = createExtension(() => {\n  let timeout: ReturnType<typeof setTimeout>;\n  return {\n    key: \"previousBlockType\",\n    prosemirrorPlugins: [\n      new Plugin({\n        key: PLUGIN_KEY,\n        view(_editorView) {\n          return {\n            update: async (view, _prevState) => {\n              if (this.key?.getState(view.state).updatedBlocks.size > 0) {\n                // use setTimeout 0 to clear the decorations so that at least\n                // for one DOM-render the decorations have been applied\n                timeout = setTimeout(() => {\n                  view.dispatch(\n                    view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true }),\n                  );\n                }, 0);\n              }\n            },\n            destroy: () => {\n              if (timeout) {\n                clearTimeout(timeout);\n              }\n            },\n          };\n        },\n        state: {\n          init() {\n            return {\n              // Block attributes, by block ID, from just before the previous transaction.\n              prevTransactionOldBlockAttrs: {} as any,\n              // Block attributes, by block ID, from just before the current transaction.\n              currentTransactionOldBlockAttrs: {} as any,\n              // Set of IDs of blocks whose attributes changed from the current transaction.\n              updatedBlocks: new Set<string>(),\n            };\n          },\n\n          apply(transaction, prev, oldState, newState) {\n            prev.currentTransactionOldBlockAttrs = {};\n            prev.updatedBlocks.clear();\n\n            if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {\n              return prev;\n            }\n\n            // TODO: Instead of iterating through the entire document, only check nodes affected by the transactions. Will\n            //  also probably require checking nodes affected by the previous transaction too.\n            // We didn't get this to work yet:\n            // const transform = combineTransactionSteps(oldState.doc, [transaction]);\n            // // const { mapping } = transform;\n            // const changes = getChangedRanges(transform);\n            //\n            // changes.forEach(({ oldRange, newRange }) => {\n            // const oldNodes = findChildrenInRange(\n            //   oldState.doc,\n            //   oldRange,\n            //   (node) => node.attrs.id\n            // );\n            //\n            // const newNodes = findChildrenInRange(\n            //   newState.doc,\n            //   newRange,\n            //   (node) => node.attrs.id\n            // );\n\n            const currentTransactionOriginalOldBlockAttrs = {} as any;\n\n            const oldNodes = findChildren(\n              oldState.doc,\n              (node) => node.attrs.id,\n            );\n            const oldNodesById = new Map(\n              oldNodes.map((node) => [node.node.attrs.id, node]),\n            );\n            const newNodes = findChildren(\n              newState.doc,\n              (node) => node.attrs.id,\n            );\n\n            // Traverses all block containers in the new editor state.\n            for (const node of newNodes) {\n              const oldNode = oldNodesById.get(node.node.attrs.id);\n\n              const oldContentNode = oldNode?.node.firstChild;\n              const newContentNode = node.node.firstChild;\n\n              if (oldNode && oldContentNode && newContentNode) {\n                const newAttrs = {\n                  index: newContentNode.attrs.index,\n                  level: newContentNode.attrs.level,\n                  type: newContentNode.type.name,\n                  depth: newState.doc.resolve(node.pos).depth,\n                };\n\n                const oldAttrs = {\n                  index: oldContentNode.attrs.index,\n                  level: oldContentNode.attrs.level,\n                  type: oldContentNode.type.name,\n                  depth: oldState.doc.resolve(oldNode.pos).depth,\n                };\n\n                currentTransactionOriginalOldBlockAttrs[node.node.attrs.id] =\n                  oldAttrs;\n\n                prev.currentTransactionOldBlockAttrs[node.node.attrs.id] =\n                  oldAttrs;\n\n                // TODO: faster deep equal?\n                if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {\n                  (oldAttrs as any)[\"depth-change\"] =\n                    oldAttrs.depth - newAttrs.depth;\n\n                  // for debugging:\n                  // console.log(\n                  //   \"id:\",\n                  //   node.node.attrs.id,\n                  //   \"previousBlockTypePlugin changes detected, oldAttrs\",\n                  //   oldAttrs,\n                  //   \"new\",\n                  //   newAttrs\n                  // );\n\n                  prev.updatedBlocks.add(node.node.attrs.id);\n                }\n              }\n            }\n\n            prev.prevTransactionOldBlockAttrs =\n              currentTransactionOriginalOldBlockAttrs;\n\n            return prev;\n          },\n        },\n        props: {\n          decorations(state) {\n            const pluginState = (this as Plugin).getState(state);\n            if (pluginState.updatedBlocks.size === 0) {\n              return undefined;\n            }\n\n            const decorations: Decoration[] = [];\n\n            state.doc.descendants((node, pos) => {\n              if (!node.attrs.id) {\n                return;\n              }\n\n              if (!pluginState.updatedBlocks.has(node.attrs.id)) {\n                return;\n              }\n\n              const prevAttrs =\n                pluginState.currentTransactionOldBlockAttrs[node.attrs.id];\n              const decorationAttrs: any = {};\n\n              for (const [nodeAttr, val] of Object.entries(prevAttrs)) {\n                decorationAttrs[\"data-prev-\" + nodeAttributes[nodeAttr]] =\n                  val || \"none\";\n              }\n\n              // for debugging:\n              // console.log(\n              //   \"previousBlockTypePlugin committing decorations\",\n              //   decorationAttrs\n              // );\n\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                ...decorationAttrs,\n              });\n\n              decorations.push(decoration);\n            });\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    ],\n  } as const;\n});\n","import { EditorView } from \"prosemirror-view\";\n\nexport function getDraggableBlockFromElement(\n  element: Element,\n  view: EditorView,\n) {\n  while (\n    element &&\n    element.parentElement &&\n    element.parentElement !== view.dom &&\n    element.getAttribute?.(\"data-node-type\") !== \"blockContainer\"\n  ) {\n    element = element.parentElement;\n  }\n  if (element.getAttribute?.(\"data-node-type\") !== \"blockContainer\") {\n    return undefined;\n  }\n  return { node: element as HTMLElement, id: element.getAttribute(\"data-id\")! };\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\n\n/**\n * Rehype plugin which removes <u> tags. Used to remove underlines before converting HTML to markdown, as Markdown\n * doesn't support underlines.\n */\nexport function removeUnderlines() {\n  const removeUnderlinesHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const node = tree.children[i];\n\n      if (node.type === \"element\") {\n        // Recursively removes underlines from child elements.\n        removeUnderlinesHelper(node);\n\n        if ((node as HASTElement).tagName === \"u\") {\n          // Lifts child nodes outside underline element, deletes the underline element, and updates current index &\n          // the number of child elements.\n          if (node.children.length > 0) {\n            tree.children.splice(i, 1, ...node.children);\n\n            const numElementsAdded = node.children.length - 1;\n            numChildElements += numElementsAdded;\n            i += numElementsAdded;\n          } else {\n            tree.children.splice(i, 1);\n\n            numChildElements--;\n            i--;\n          }\n        }\n      }\n    }\n  };\n\n  return removeUnderlinesHelper;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\nimport { fromDom } from \"hast-util-from-dom\";\n\n/**\n * Rehype plugin which adds a space after each checkbox input element. This is\n * because remark doesn't add any spaces between the checkbox input and the text\n * itself, but these are needed for correct Markdown syntax.\n */\nexport function addSpacesToCheckboxes() {\n  const helper = (tree: HASTParent) => {\n    if (tree.children && \"length\" in tree.children && tree.children.length) {\n      for (let i = tree.children.length - 1; i >= 0; i--) {\n        const child = tree.children[i];\n        const nextChild =\n          i + 1 < tree.children.length ? tree.children[i + 1] : undefined;\n\n        // Checks for paragraph element after checkbox input element.\n        if (\n          child.type === \"element\" &&\n          child.tagName === \"input\" &&\n          child.properties?.type === \"checkbox\" &&\n          nextChild?.type === \"element\" &&\n          nextChild.tagName === \"p\"\n        ) {\n          // Converts paragraph to span, otherwise remark will think it needs to\n          // be on a new line.\n          nextChild.tagName = \"span\";\n          // Adds a space after the checkbox input element.\n          nextChild.children.splice(\n            0,\n            0,\n            fromDom(document.createTextNode(\" \")) as HASTElement,\n          );\n        } else {\n          helper(child as HASTParent);\n        }\n      }\n    }\n  };\n\n  return helper;\n}\n","import { Parent as HASTParent } from \"hast\";\nimport { visit } from \"unist-util-visit\";\n\n// Originally, rehypeParse parses videos as links, which is incorrect.\nexport function convertVideoToMarkdown() {\n  return (tree: HASTParent) => {\n    visit(tree, \"element\", (node, index, parent) => {\n      if (parent && node.tagName === \"video\") {\n        const src = node.properties?.src || node.properties?.[\"data-url\"] || \"\";\n        const name =\n          node.properties?.title || node.properties?.[\"data-name\"] || \"\";\n        parent.children[index!] = {\n          type: \"text\",\n          value: `![${name}](${src})`,\n        };\n      }\n    });\n  };\n}\n","import { Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeRemark from \"rehype-remark\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkStringify from \"remark-stringify\";\nimport { unified } from \"unified\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { createExternalHTMLExporter } from \"../html/externalHTMLExporter.js\";\nimport { removeUnderlines } from \"./util/removeUnderlinesRehypePlugin.js\";\nimport { addSpacesToCheckboxes } from \"./util/addSpacesToCheckboxesRehypePlugin.js\";\nimport { convertVideoToMarkdown } from \"./util/convertVideoToMarkdownRehypePlugin.js\";\n\n// Needs to be sync because it's used in drag handler event (SideMenuPlugin)\nexport function cleanHTMLToMarkdown(cleanHTMLString: string) {\n  const markdownString = unified()\n    .use(rehypeParse, { fragment: true })\n    .use(convertVideoToMarkdown)\n    .use(removeUnderlines)\n    .use(addSpacesToCheckboxes)\n    .use(rehypeRemark)\n    .use(remarkGfm)\n    .use(remarkStringify, {\n      handlers: { text: (node) => node.value },\n    })\n    .processSync(cleanHTMLString);\n\n  return markdownString.value as string;\n}\n\nexport function blocksToMarkdown<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  blocks: PartialBlock<BSchema, I, S>[],\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  options: { document?: Document },\n): string {\n  const exporter = createExternalHTMLExporter(schema, editor);\n  const externalHTML = exporter.exportBlocks(blocks, options);\n\n  return cleanHTMLToMarkdown(externalHTML);\n}\n","import { Fragment } from \"@tiptap/pm/model\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getPmSchema } from \"../pmUtil.js\";\nimport { nodeToBlock } from \"./nodeToBlock.js\";\n\n/**\n * Converts all Blocks within a fragment to BlockNote blocks.\n */\nexport function fragmentToBlocks<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(fragment: Fragment) {\n  // first convert selection to blocknote-style blocks, and then\n  // pass these to the exporter\n  const blocks: BlockNoDefaults<B, I, S>[] = [];\n  fragment.descendants((node) => {\n    const pmSchema = getPmSchema(node);\n    if (node.type.name === \"blockContainer\") {\n      if (node.firstChild?.type.name === \"blockGroup\") {\n        // selection started within a block group\n        // in this case the fragment starts with:\n        // <blockContainer>\n        //   <blockGroup>\n        //     <blockContainer ... />\n        //     <blockContainer ... />\n        //   </blockGroup>\n        // </blockContainer>\n        //\n        // instead of:\n        // <blockContainer>\n        //   <blockContent ... />\n        //   <blockGroup>\n        //     <blockContainer ... />\n        //     <blockContainer ... />\n        //   </blockGroup>\n        // </blockContainer>\n        //\n        // so we don't need to serialize this block, just descend into the children of the blockGroup\n        return true;\n      }\n    }\n\n    if (node.type.name === \"columnList\" && node.childCount === 1) {\n      // column lists with a single column should be flattened (not the entire column list has been selected)\n      node.firstChild?.forEach((child) => {\n        blocks.push(nodeToBlock(child, pmSchema));\n      });\n      return false;\n    }\n\n    if (node.type.isInGroup(\"bnBlock\")) {\n      blocks.push(nodeToBlock(node, pmSchema));\n      // don't descend into children, as they're already included in the block returned by nodeToBlock\n      return false;\n    }\n    return true;\n  });\n  return blocks;\n}\n","import { Fragment, Node, ResolvedPos, Slice } from \"prosemirror-model\";\nimport { Selection } from \"prosemirror-state\";\nimport { Mappable } from \"prosemirror-transform\";\n\n/**\n * This class represents an editor selection which spans multiple nodes/blocks. It's currently only used to allow users\n * to drag multiple blocks at the same time. Expects the selection anchor and head to be between nodes, i.e. just before\n * the first target node and just after the last, and that anchor and head are at the same nesting level.\n *\n * Partially based on ProseMirror's NodeSelection implementation:\n * (https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.ts)\n * MultipleNodeSelection differs from NodeSelection in the following ways:\n * 1. Stores which nodes are included in the selection instead of just a single node.\n * 2. Already expects the selection to start just before the first target node and ends just after the last, while a\n * NodeSelection automatically sets both anchor and head to just before the single target node.\n */\nexport class MultipleNodeSelection extends Selection {\n  nodes: Array<Node>;\n\n  constructor($anchor: ResolvedPos, $head: ResolvedPos) {\n    super($anchor, $head);\n\n    // Parent is at the same nesting level as anchor/head since they are just before/ just after target nodes.\n    const parentNode = $anchor.node();\n\n    this.nodes = [];\n    $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node, _pos, parent) => {\n      if (parent !== null && parent.eq(parentNode)) {\n        this.nodes.push(node);\n        return false;\n      }\n      return;\n    });\n  }\n\n  static create(doc: Node, from: number, to = from): MultipleNodeSelection {\n    return new MultipleNodeSelection(doc.resolve(from), doc.resolve(to));\n  }\n\n  content(): Slice {\n    return new Slice(Fragment.from(this.nodes), 0, 0);\n  }\n\n  eq(selection: Selection): boolean {\n    if (!(selection instanceof MultipleNodeSelection)) {\n      return false;\n    }\n\n    if (this.nodes.length !== selection.nodes.length) {\n      return false;\n    }\n\n    if (this.from !== selection.from || this.to !== selection.to) {\n      return false;\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (!this.nodes[i].eq(selection.nodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  map(doc: Node, mapping: Mappable): Selection {\n    const fromResult = mapping.mapResult(this.from);\n    const toResult = mapping.mapResult(this.to);\n\n    if (toResult.deleted) {\n      return Selection.near(doc.resolve(fromResult.pos));\n    }\n\n    if (fromResult.deleted) {\n      return Selection.near(doc.resolve(toResult.pos));\n    }\n\n    return new MultipleNodeSelection(\n      doc.resolve(fromResult.pos),\n      doc.resolve(toResult.pos),\n    );\n  }\n\n  toJSON(): any {\n    return { type: \"multiple-node\", anchor: this.anchor, head: this.head };\n  }\n}\n\nSelection.jsonID(\"multiple-node\", MultipleNodeSelection);\n","import { Node } from \"prosemirror-model\";\nimport { NodeSelection, Selection } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter.js\";\nimport { cleanHTMLToMarkdown } from \"../../api/exporters/markdown/markdownExporter.js\";\nimport { fragmentToBlocks } from \"../../api/nodeConversions/fragmentToBlocks.js\";\nimport { getNodeById } from \"../../api/nodeUtil.js\";\nimport { Block } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { MultipleNodeSelection } from \"./MultipleNodeSelection.js\";\n\nlet dragImageElement: Element | undefined;\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nfunction blockPositionsFromSelection(selection: Selection, doc: Node) {\n  // Absolute positions just before the first block spanned by the selection, and just after the last block. Having the\n  // selection start and end just before and just after the target blocks ensures no whitespace/line breaks are left\n  // behind after dragging & dropping them.\n  let beforeFirstBlockPos: number;\n  let afterLastBlockPos: number;\n\n  // Even the user starts dragging blocks but drops them in the same place, the selection will still be moved just\n  // before & just after the blocks spanned by the selection, and therefore doesn't need to change if they try to drag\n  // the same blocks again. If this happens, the anchor & head move out of the block content node they were originally\n  // in. If the anchor should update but the head shouldn't and vice versa, it means the user selection is outside a\n  // block content node, which should never happen.\n  const selectionStartInBlockContent =\n    doc.resolve(selection.from).node().type.spec.group === \"blockContent\";\n  const selectionEndInBlockContent =\n    doc.resolve(selection.to).node().type.spec.group === \"blockContent\";\n\n  // Ensures that entire outermost nodes are selected if the selection spans multiple nesting levels.\n  const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);\n\n  if (selectionStartInBlockContent && selectionEndInBlockContent) {\n    // Absolute positions at the start of the first block in the selection and at the end of the last block. User\n    // selections will always start and end in block content nodes, but we want the start and end positions of their\n    // parent block nodes, which is why minDepth - 1 is used.\n    const startFirstBlockPos = selection.$from.start(minDepth - 1);\n    const endLastBlockPos = selection.$to.end(minDepth - 1);\n\n    // Shifting start and end positions by one moves them just outside the first and last selected blocks.\n    beforeFirstBlockPos = doc.resolve(startFirstBlockPos - 1).pos;\n    afterLastBlockPos = doc.resolve(endLastBlockPos + 1).pos;\n  } else {\n    beforeFirstBlockPos = selection.from;\n    afterLastBlockPos = selection.to;\n  }\n\n  return { from: beforeFirstBlockPos, to: afterLastBlockPos };\n}\n\nfunction setDragImage(view: EditorView, from: number, to = from) {\n  if (from === to) {\n    // Moves to position to be just after the first (and only) selected block.\n    to += view.state.doc.resolve(from + 1).node().nodeSize;\n  }\n\n  // Parent element is cloned to remove all unselected children without affecting the editor content.\n  const parentClone = view.domAtPos(from).node.cloneNode(true) as Element;\n  const parent = view.domAtPos(from).node as Element;\n\n  const getElementIndex = (parentElement: Element, targetElement: Element) =>\n    Array.prototype.indexOf.call(parentElement.children, targetElement);\n\n  const firstSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects from position to be just before the first selected block.\n    view.domAtPos(from + 1).node.parentElement!,\n  );\n  const lastSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects to position to be just after the last selected block.\n    view.domAtPos(to - 1).node.parentElement!,\n  );\n\n  for (let i = parent.childElementCount - 1; i >= 0; i--) {\n    if (i > lastSelectedBlockIndex || i < firstSelectedBlockIndex) {\n      parentClone.removeChild(parentClone.children[i]);\n    }\n  }\n\n  // dataTransfer.setDragImage(element) only works if element is attached to the DOM.\n  unsetDragImage(view.root);\n  dragImageElement = parentClone;\n\n  // Browsers may have CORS policies which prevents iframes from being\n  // manipulated, so better to stay on the safe side and remove them from the\n  // drag preview. The drag preview doesn't work with iframes anyway.\n  const iframes = dragImageElement.getElementsByTagName(\"iframe\");\n  for (let i = 0; i < iframes.length; i++) {\n    const iframe = iframes[i];\n    const parent = iframe.parentElement;\n\n    if (parent) {\n      parent.removeChild(iframe);\n    }\n  }\n\n  // TODO: This is hacky, need a better way of assigning classes to the editor so that they can also be applied to the\n  //  drag preview.\n  const classes = view.dom.className.split(\" \");\n  const inheritedClasses = classes\n    .filter(\n      (className) =>\n        className !== \"ProseMirror\" &&\n        className !== \"bn-root\" &&\n        className !== \"bn-editor\",\n    )\n    .join(\" \");\n\n  dragImageElement.className =\n    dragImageElement.className + \" bn-drag-preview \" + inheritedClasses;\n\n  if (view.root instanceof ShadowRoot) {\n    view.root.appendChild(dragImageElement);\n  } else {\n    view.root.body.appendChild(dragImageElement);\n  }\n}\n\nexport function unsetDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement !== undefined) {\n    if (rootEl instanceof ShadowRoot) {\n      rootEl.removeChild(dragImageElement);\n    } else {\n      rootEl.body.removeChild(dragImageElement);\n    }\n\n    dragImageElement = undefined;\n  }\n}\n\nexport function dragStart<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  e: { dataTransfer: DataTransfer | null; clientY: number },\n  block: Block<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) {\n  if (!e.dataTransfer) {\n    return;\n  }\n\n  if (editor.headless) {\n    return;\n  }\n  const view = editor.prosemirrorView;\n\n  const posInfo = getNodeById(block.id, view.state.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${block.id} not found`);\n  }\n  const pos = posInfo.posBeforeNode;\n\n  if (pos != null) {\n    const selection = view.state.selection;\n    const doc = view.state.doc;\n\n    const { from, to } = blockPositionsFromSelection(selection, doc);\n\n    const draggedBlockInSelection = from <= pos && pos < to;\n    const multipleBlocksSelected =\n      selection.$anchor.node() !== selection.$head.node() ||\n      selection instanceof MultipleNodeSelection;\n\n    if (draggedBlockInSelection && multipleBlocksSelected) {\n      view.dispatch(\n        view.state.tr.setSelection(MultipleNodeSelection.create(doc, from, to)),\n      );\n      setDragImage(view, from, to);\n    } else {\n      view.dispatch(\n        view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos)),\n      );\n      setDragImage(view, pos);\n    }\n\n    const selectedSlice = view.state.selection.content();\n    const schema = editor.pmSchema;\n\n    const clipboardHTML =\n      view.serializeForClipboard(selectedSlice).dom.innerHTML;\n\n    const externalHTMLExporter = createExternalHTMLExporter(schema, editor);\n\n    const blocks = fragmentToBlocks(selectedSlice.content);\n    const externalHTML = externalHTMLExporter.exportBlocks(blocks, {});\n\n    const plainText = cleanHTMLToMarkdown(externalHTML);\n\n    e.dataTransfer.clearData();\n    e.dataTransfer.setData(\"blocknote/html\", clipboardHTML);\n    e.dataTransfer.setData(\"text/html\", externalHTML);\n    e.dataTransfer.setData(\"text/plain\", plainText);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setDragImage(dragImageElement!, 0, 0);\n  }\n}\n","import { DOMParser, Slice } from \"@tiptap/pm/model\";\nimport {\n  EditorState,\n  Plugin,\n  PluginKey,\n  PluginView,\n  TextSelection,\n} from \"@tiptap/pm/state\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\nimport { Block } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getDraggableBlockFromElement } from \"../getDraggableBlockFromElement.js\";\nimport { dragStart, unsetDragImage } from \"./dragging.js\";\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nconst DISTANCE_TO_CONSIDER_EDITOR_BOUNDS = 250;\n\nfunction getBlockFromCoords(\n  view: EditorView,\n  coords: { left: number; top: number },\n  adjustForColumns = true,\n) {\n  const elements = view.root.elementsFromPoint(coords.left, coords.top);\n\n  for (const element of elements) {\n    if (!view.dom.contains(element)) {\n      // probably a ui overlay like formatting toolbar etc\n      continue;\n    }\n    if (adjustForColumns) {\n      const column = element.closest(\"[data-node-type=columnList]\");\n      if (column) {\n        return getBlockFromCoords(\n          view,\n          {\n            // TODO can we do better than this?\n            left: coords.left + 50, // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself\n            top: coords.top,\n          },\n          false,\n        );\n      }\n    }\n    return getDraggableBlockFromElement(element, view);\n  }\n  return undefined;\n}\n\nfunction getBlockFromMousePos(\n  mousePos: {\n    x: number;\n    y: number;\n  },\n  view: EditorView,\n): { node: HTMLElement; id: string } | undefined {\n  // Editor itself may have padding or other styling which affects\n  // size/position, so we get the boundingRect of the first child (i.e. the\n  // blockGroup that wraps all blocks in the editor) for more accurate side\n  // menu placement.\n  if (!view.dom.firstChild) {\n    return;\n  }\n\n  const editorBoundingBox = (\n    view.dom.firstChild as HTMLElement\n  ).getBoundingClientRect();\n\n  // Gets block at mouse cursor's position.\n  const coords = {\n    // Clamps the x position to the editor's bounding box.\n    left: Math.min(\n      Math.max(editorBoundingBox.left + 10, mousePos.x),\n      editorBoundingBox.right - 10,\n    ),\n    top: mousePos.y,\n  };\n\n  const referenceBlock = getBlockFromCoords(view, coords);\n\n  if (!referenceBlock) {\n    // could not find the reference block\n    return undefined;\n  }\n\n  /**\n   * Because blocks may be nested, we need to check the right edge of the parent block:\n   * ```\n   * | BlockA        |\n   * x | BlockB     y|\n   * ```\n   * Hovering at position x (left edge of BlockB) would return BlockA.\n   * Instead, we check at position y (right edge of BlockA) to correctly identify BlockB.\n   */\n  const referenceBlocksBoundingBox =\n    referenceBlock.node.getBoundingClientRect();\n  return getBlockFromCoords(\n    view,\n    {\n      left: referenceBlocksBoundingBox.right - 10,\n      top: mousePos.y,\n    },\n    false,\n  );\n}\n\n/**\n * With the sidemenu plugin we can position a menu next to a hovered block.\n */\nexport class SideMenuView<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> implements PluginView\n{\n  public state?: SideMenuState<BSchema, I, S>;\n  public readonly emitUpdate: (state: SideMenuState<BSchema, I, S>) => void;\n\n  private mousePos: { x: number; y: number } | undefined;\n\n  private hoveredBlock: HTMLElement | undefined;\n\n  public menuFrozen = false;\n\n  public isDragOrigin = false;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<BSchema, I, S>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: SideMenuState<BSchema, I, S>) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized side menu\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    this.pmView.root.addEventListener(\n      \"dragstart\",\n      this.onDragStart as EventListener,\n    );\n    this.pmView.root.addEventListener(\n      \"dragover\",\n      this.onDragOver as EventListener,\n    );\n    this.pmView.root.addEventListener(\n      \"drop\",\n      this.onDrop as EventListener,\n      true,\n    );\n    this.pmView.root.addEventListener(\n      \"dragend\",\n      this.onDragEnd as EventListener,\n      true,\n    );\n\n    // Shows or updates menu position whenever the cursor moves, if the menu isn't frozen.\n    this.pmView.root.addEventListener(\n      \"mousemove\",\n      this.onMouseMove as EventListener,\n      true,\n    );\n\n    // Hides and unfreezes the menu whenever the user presses a key.\n    this.pmView.root.addEventListener(\n      \"keydown\",\n      this.onKeyDown as EventListener,\n      true,\n    );\n  }\n\n  updateState = (state: SideMenuState<BSchema, I, S>) => {\n    this.state = state;\n    this.emitUpdate(this.state);\n  };\n\n  updateStateFromMousePos = () => {\n    if (this.menuFrozen || !this.mousePos) {\n      return;\n    }\n\n    const closestEditor = this.findClosestEditorElement({\n      clientX: this.mousePos.x,\n      clientY: this.mousePos.y,\n    });\n\n    if (\n      closestEditor?.element !== this.pmView.dom ||\n      closestEditor.distance > DISTANCE_TO_CONSIDER_EDITOR_BOUNDS\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.updateState(this.state);\n      }\n      return;\n    }\n\n    const block = getBlockFromMousePos(this.mousePos, this.pmView);\n\n    // Closes the menu if the mouse cursor is beyond the editor vertically.\n    if (!block || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.updateState(this.state);\n      }\n\n      return;\n    }\n\n    // Doesn't update if the menu is already open and the mouse cursor is still hovering the same block.\n    if (\n      this.state?.show &&\n      this.hoveredBlock?.hasAttribute(\"data-id\") &&\n      this.hoveredBlock?.getAttribute(\"data-id\") === block.id\n    ) {\n      return;\n    }\n\n    this.hoveredBlock = block.node;\n\n    // Shows or updates elements.\n    if (this.editor.isEditable) {\n      const blockContentBoundingBox = block.node.getBoundingClientRect();\n      const column = block.node.closest(\"[data-node-type=column]\");\n      this.state = {\n        show: true,\n        referencePos: new DOMRect(\n          column\n            ? // We take the first child as column elements have some default\n              // padding. This is a little weird since this child element will\n              // be the first block, but since it's always non-nested and we\n              // only take the x coordinate, it's ok.\n              column.firstElementChild!.getBoundingClientRect().x\n            : (\n                this.pmView.dom.firstChild as HTMLElement\n              ).getBoundingClientRect().x,\n          blockContentBoundingBox.y,\n          blockContentBoundingBox.width,\n          blockContentBoundingBox.height,\n        ),\n        block: this.editor.getBlock(\n          this.hoveredBlock!.getAttribute(\"data-id\")!,\n        )!,\n      };\n      this.updateState(this.state);\n    }\n  };\n\n  /**\n   * If a block is being dragged, ProseMirror usually gets the context of what's\n   * being dragged from `view.dragging`, which is automatically set when a\n   * `dragstart` event fires in the editor. However, if the user tries to drag\n   * and drop blocks between multiple editors, only the one in which the drag\n   * began has that context, so we need to set it on the others manually. This\n   * ensures that PM always drops the blocks in between other blocks, and not\n   * inside them.\n   *\n   * After the `dragstart` event fires on the drag handle, it sets\n   * `blocknote/html` data on the clipboard. This handler fires right after,\n   * parsing the `blocknote/html` data into nodes and setting them on\n   * `view.dragging`.\n   *\n   * Note: Setting `view.dragging` on `dragover` would be better as the user\n   * could then drag between editors in different windows, but you can only\n   * access `dataTransfer` contents on `dragstart` and `drop` events.\n   */\n  onDragStart = (event: DragEvent) => {\n    const html = event.dataTransfer?.getData(\"blocknote/html\");\n    if (!html) {\n      return;\n    }\n\n    if (this.pmView.dragging) {\n      // already dragging, so no-op\n      return;\n    }\n\n    const element = document.createElement(\"div\");\n    element.innerHTML = html;\n\n    const parser = DOMParser.fromSchema(this.pmView.state.schema);\n    const node = parser.parse(element, {\n      topNode: this.pmView.state.schema.nodes[\"blockGroup\"].create(),\n    });\n\n    this.pmView.dragging = {\n      slice: new Slice(node.content, 0, 0),\n      move: true,\n    };\n  };\n\n  /**\n   * Finds the closest editor visually to the given coordinates\n   */\n  private findClosestEditorElement = (coords: {\n    clientX: number;\n    clientY: number;\n  }) => {\n    // Get all editor elements in the document\n    const editors = Array.from(this.pmView.root.querySelectorAll(\".bn-editor\"));\n\n    if (editors.length === 0) {\n      return null;\n    }\n\n    // Find the editor with the smallest distance to the coordinates\n    let closestEditor = editors[0];\n    let minDistance = Number.MAX_VALUE;\n\n    editors.forEach((editor) => {\n      const rect = editor\n        .querySelector(\".bn-block-group\")!\n        .getBoundingClientRect();\n\n      const distanceX =\n        coords.clientX < rect.left\n          ? rect.left - coords.clientX\n          : coords.clientX > rect.right\n            ? coords.clientX - rect.right\n            : 0;\n\n      const distanceY =\n        coords.clientY < rect.top\n          ? rect.top - coords.clientY\n          : coords.clientY > rect.bottom\n            ? coords.clientY - rect.bottom\n            : 0;\n\n      const distance = Math.sqrt(\n        Math.pow(distanceX, 2) + Math.pow(distanceY, 2),\n      );\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestEditor = editor;\n      }\n    });\n\n    return {\n      element: closestEditor,\n      distance: minDistance,\n    };\n  };\n\n  /**\n   * This dragover event handler listens at the document level,\n   * and is trying to handle dragover events for all editors.\n   *\n   * It specifically is trying to handle the following cases:\n   *  - If the dragover event is within the bounds of any editor, then it does nothing\n   *  - If the dragover event is outside the bounds of any editor, but close enough (within DISTANCE_TO_CONSIDER_EDITOR_BOUNDS) to the closest editor,\n   *    then it dispatches a synthetic dragover event to the closest editor (which will trigger the drop-cursor to be shown on that editor)\n   *  - If the dragover event is outside the bounds of the current editor, then it will dispatch a synthetic dragleave event to the current editor\n   *    (which will trigger the drop-cursor to be removed from the current editor)\n   *\n   * The synthetic event is a necessary evil because we do not control prosemirror-dropcursor to be able to show the drop-cursor within the range we want\n   */\n  onDragOver = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n\n    const dragEventContext = this.getDragEventContext(event);\n\n    if (!dragEventContext || !dragEventContext.isDropPoint) {\n      // This is not a drag event that we are interested in\n      // so, we close the drop-cursor\n      this.closeDropCursor();\n      return;\n    }\n\n    if (\n      dragEventContext.isDropPoint &&\n      !dragEventContext.isDropWithinEditorBounds\n    ) {\n      // we are the drop point, but the drag over event is not within the bounds of this editor instance\n      // so, we need to dispatch an event that is in the bounds of this editor instance\n      this.dispatchSyntheticEvent(event);\n    }\n  };\n\n  /**\n   * Closes the drop-cursor for the current editor\n   */\n  private closeDropCursor = () => {\n    const evt = new Event(\"dragleave\", { bubbles: false });\n    // It needs to be synthetic, so we don't accidentally think it is a real dragend event\n    (evt as any).synthetic = true;\n    // We dispatch the event to the current editor, so that the drop-cursor is removed for it\n    this.pmView.dom.dispatchEvent(evt);\n  };\n\n  /**\n   * It is surprisingly difficult to determine the information we need to know about a drag event\n   *\n   * This function is trying to determine the following:\n   *  - Whether the current editor instance is the drop point\n   *  - Whether the current editor instance is the drag origin\n   *  - Whether the drop event is within the bounds of the current editor instance\n   */\n  getDragEventContext = (event: DragEvent) => {\n    // We need to check if there is text content that is being dragged (select some text & just drag it)\n    const textContentIsBeingDragged =\n      !event.dataTransfer?.types.includes(\"blocknote/html\") &&\n      !!this.pmView.dragging;\n    // This is the side menu drag from this plugin\n    const sideMenuIsBeingDragged = !!this.isDragOrigin;\n    // Tells us that the current editor instance has a drag ongoing (either text or side menu)\n    const isDragOrigin = textContentIsBeingDragged || sideMenuIsBeingDragged;\n\n    // Tells us which editor instance is the closest to the drag event (whether or not it is actually reasonably close)\n    const closestEditor = this.findClosestEditorElement(event);\n\n    // We arbitrarily decide how far is \"too far\" from the closest editor to be considered a drop point\n    if (\n      !closestEditor ||\n      closestEditor.distance > DISTANCE_TO_CONSIDER_EDITOR_BOUNDS\n    ) {\n      // we are too far from the closest editor, or no editor was found\n      return undefined;\n    }\n\n    // We check if the closest editor is the same as the current editor instance (which is the drop point)\n    const isDropPoint = closestEditor.element === this.pmView.dom;\n    // We check if the current editor instance is the same as the editor instance that the drag event is happening within\n    const isDropWithinEditorBounds =\n      isDropPoint && closestEditor.distance === 0;\n\n    // We never want to handle drop events that are not related to us\n    if (!isDropPoint && !isDragOrigin) {\n      // we are not the drop point or drag origin, so not relevant to us\n      return undefined;\n    }\n\n    return {\n      isDropPoint,\n      isDropWithinEditorBounds,\n      isDragOrigin,\n    };\n  };\n\n  /**\n   * The drop event handler listens at the document level,\n   * and handles drop events for all editors.\n   *\n   * It specifically handles the following cases:\n   *  - If we are both the drag origin and drop point:\n   *    - Let normal drop handling take over\n   *  - If we are the drop point but not the drag origin:\n   *    - Collapse selection to prevent PM from deleting unrelated content\n   *    - If drop event is outside our editor bounds, dispatch synthetic drop event to our editor\n   *  - If we are the drag origin but not the drop point:\n   *    - Delete the dragged content from our editor after a delay\n   */\n  onDrop = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n\n    const context = this.getDragEventContext(event);\n    if (!context) {\n      this.closeDropCursor();\n      // This is not a drag event that we are interested in\n      return;\n    }\n    const { isDropPoint, isDropWithinEditorBounds, isDragOrigin } = context;\n\n    if (!isDropWithinEditorBounds && isDropPoint) {\n      // Any time that the drop event is outside of the editor bounds (but still close to an editor instance)\n      // We dispatch a synthetic event that is in the bounds of the editor instance, to have the correct drop point\n      this.dispatchSyntheticEvent(event);\n    }\n\n    if (isDropPoint) {\n      // The current instance is the drop point\n\n      if (this.pmView.dragging) {\n        // Do not collapse selection when text content is being dragged\n        return;\n      }\n      // Because the editor selection is unrelated to the dragged content, we\n      // don't want PM to delete its content. Therefore, we collapse the\n      // selection.\n      this.pmView.dispatch(\n        this.pmView.state.tr.setSelection(\n          TextSelection.create(\n            this.pmView.state.tr.doc,\n            this.pmView.state.tr.selection.anchor,\n          ),\n        ),\n      );\n      return;\n    } else if (isDragOrigin) {\n      // The current instance is the drag origin, but not the drop point\n      // our content got dropped somewhere else\n\n      // Because the editor from which the block originates doesn't get a drop\n      // event on it, PM doesn't delete its selected content. Therefore, we\n      // need to do so manually.\n      //\n      // Note: Deleting the selected content from the editor from which the\n      // block originates, may change its height. This can cause the position of\n      // the editor in which the block is being dropping to shift, before it\n      // can handle the drop event. That in turn can cause the drop to happen\n      // somewhere other than the user intended. To get around this, we delay\n      // deleting the selected content until all editors have had the chance to\n      // handle the event.\n      setTimeout(\n        () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),\n        0,\n      );\n      return;\n    }\n  };\n\n  onDragEnd = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n    // When the user starts dragging a block, `view.dragging` is set on all\n    // BlockNote editors. However, when the drag ends, only the editor that the\n    // drag originated in automatically clears `view.dragging`. Therefore, we\n    // have to manually clear it on all editors.\n    this.pmView.dragging = null;\n  };\n\n  onKeyDown = (_event: KeyboardEvent) => {\n    if (this.state?.show && this.editor.isFocused()) {\n      // Typing in editor should hide side menu\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    this.mousePos = { x: event.clientX, y: event.clientY };\n\n    // We want the full area of the editor to check if the cursor is hovering\n    // above it though.\n    const editorOuterBoundingBox = this.pmView.dom.getBoundingClientRect();\n    const cursorWithinEditor =\n      this.mousePos.x > editorOuterBoundingBox.left &&\n      this.mousePos.x < editorOuterBoundingBox.right &&\n      this.mousePos.y > editorOuterBoundingBox.top &&\n      this.mousePos.y < editorOuterBoundingBox.bottom;\n\n    // TODO: remove parentElement, but then we need to remove padding from boundingbox or find a different solution\n    const editorWrapper = this.pmView.dom!.parentElement!;\n\n    // Doesn't update if the mouse hovers an element that's over the editor but\n    // isn't a part of it or the side menu.\n    if (\n      // Cursor is within the editor area\n      cursorWithinEditor &&\n      // An element is hovered\n      event &&\n      event.target &&\n      // Element is outside the editor\n      !(\n        editorWrapper === event.target ||\n        editorWrapper.contains(event.target as HTMLElement)\n      )\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate(this.state);\n      }\n\n      return;\n    }\n\n    this.updateStateFromMousePos();\n  };\n\n  private dispatchSyntheticEvent(event: DragEvent) {\n    const evt = new Event(event.type as \"dragover\", event) as any;\n    const dropPointBoundingBox = (\n      this.pmView.dom.firstChild as HTMLElement\n    ).getBoundingClientRect();\n    evt.clientX = event.clientX;\n    evt.clientY = event.clientY;\n\n    evt.clientX = Math.min(\n      Math.max(event.clientX, dropPointBoundingBox.left),\n      dropPointBoundingBox.left + dropPointBoundingBox.width,\n    );\n    evt.clientY = Math.min(\n      Math.max(event.clientY, dropPointBoundingBox.top),\n      dropPointBoundingBox.top + dropPointBoundingBox.height,\n    );\n\n    evt.dataTransfer = event.dataTransfer;\n    evt.preventDefault = () => event.preventDefault();\n    evt.synthetic = true; // prevent recursion\n    this.pmView.dom.dispatchEvent(evt);\n  }\n\n  // Needed in cases where the editor state updates without the mouse cursor\n  // moving, as some state updates can require a side menu update. For example,\n  // adding a button to the side menu which removes the block can cause the\n  // block below to jump up into the place of the removed block when clicked,\n  // allowing the user to click the button again without moving the cursor. This\n  // would otherwise not update the side menu, and so clicking the button again\n  // would attempt to remove the same block again, causing an error.\n  update(_view: EditorView, prevState: EditorState) {\n    const docChanged = !prevState.doc.eq(this.pmView.state.doc);\n    if (docChanged && this.state?.show) {\n      this.updateStateFromMousePos();\n    }\n  }\n\n  destroy() {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n    this.pmView.root.removeEventListener(\n      \"mousemove\",\n      this.onMouseMove as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragstart\",\n      this.onDragStart as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.onDragOver as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"drop\",\n      this.onDrop as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragend\",\n      this.onDragEnd as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"keydown\",\n      this.onKeyDown as EventListener,\n      true,\n    );\n  }\n}\n\nexport const sideMenuPluginKey = new PluginKey(\"SideMenuPlugin\");\n\nexport const SideMenuExtension = createExtension(({ editor }) => {\n  let view: SideMenuView<any, any, any> | undefined;\n  const store = createStore<SideMenuState<any, any, any> | undefined>(\n    undefined,\n  );\n\n  return {\n    key: \"sideMenu\",\n    store,\n    prosemirrorPlugins: [\n      new Plugin({\n        key: sideMenuPluginKey,\n        view: (editorView) => {\n          view = new SideMenuView(editor, editorView, (state) => {\n            // TODO: Without spreading the state, in some cases like toggling\n            // `show`, this doesn't trigger an update.\n            store.setState({ ...state });\n          });\n          return view;\n        },\n      }),\n    ],\n\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    blockDragStart(\n      event: { dataTransfer: DataTransfer | null; clientY: number },\n      block: Block<any, any, any>,\n    ) {\n      if (view) {\n        view.isDragOrigin = true;\n      }\n      dragStart(event, block, editor);\n    },\n\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    blockDragEnd() {\n      unsetDragImage(editor.prosemirrorView.root);\n      if (view) {\n        view.isDragOrigin = false;\n      }\n\n      editor.blur();\n    },\n\n    /**\n     * Freezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    freezeMenu() {\n      view!.menuFrozen = true;\n      view!.state!.show = true;\n      view!.emitUpdate(view!.state!);\n    },\n\n    /**\n     * Unfreezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    unfreezeMenu() {\n      view!.menuFrozen = false;\n      view!.state!.show = false;\n      view!.emitUpdate(view!.state!);\n    },\n  } as const;\n});\n","import { EditorState, Plugin, PluginKey, PluginView } from \"prosemirror-state\";\nimport {\n  CellSelection,\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  deleteColumn,\n  deleteRow,\n  mergeCells,\n  splitCell,\n} from \"prosemirror-tables\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport {\n  RelativeCellIndices,\n  addRowsOrColumns,\n  areInSameColumn,\n  canColumnBeDraggedInto,\n  canRowBeDraggedInto,\n  cropEmptyRowsOrColumns,\n  getCellsAtColumnHandle,\n  getCellsAtRowHandle,\n  getDimensionsOfTable,\n  moveColumn,\n  moveRow,\n} from \"../../api/blockManipulation/tables/tables.js\";\nimport { nodeToBlock } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../api/nodeUtil.js\";\nimport {\n  editorHasBlockWithType,\n  isTableCellSelection,\n} from \"../../blocks/defaultBlockTypeGuards.js\";\nimport { DefaultBlockSchema } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchemaWithBlock,\n} from \"../../schema/index.js\";\nimport { getDraggableBlockFromElement } from \"../getDraggableBlockFromElement.js\";\n\nlet dragImageElement: HTMLElement | undefined;\n\n// TODO consider switching this to jotai, it is a bit messy and noisy\nexport type TableHandlesState = {\n  show: boolean;\n  showAddOrRemoveRowsButton: boolean;\n  showAddOrRemoveColumnsButton: boolean;\n  referencePosCell: DOMRect | undefined;\n  referencePosTable: DOMRect;\n\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>;\n  colIndex: number | undefined;\n  rowIndex: number | undefined;\n\n  draggingState:\n    | {\n        draggedCellOrientation: \"row\" | \"col\";\n        originalIndex: number;\n        mousePos: number;\n      }\n    | undefined;\n\n  widgetContainer: HTMLElement | undefined;\n};\n\nfunction setHiddenDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement) {\n    return;\n  }\n\n  dragImageElement = document.createElement(\"div\");\n  dragImageElement.innerHTML = \"_\";\n  dragImageElement.style.opacity = \"0\";\n  dragImageElement.style.height = \"1px\";\n  dragImageElement.style.width = \"1px\";\n  if (rootEl instanceof Document) {\n    rootEl.body.appendChild(dragImageElement);\n  } else {\n    rootEl.appendChild(dragImageElement);\n  }\n}\n\nfunction unsetHiddenDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement) {\n    if (rootEl instanceof Document) {\n      rootEl.body.removeChild(dragImageElement);\n    } else {\n      rootEl.removeChild(dragImageElement);\n    }\n    dragImageElement = undefined;\n  }\n}\n\nfunction getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\n// Finds the DOM element corresponding to the table cell that the target element\n// is currently in. If the target element is not in a table cell, returns null.\nfunction domCellAround(target: Element) {\n  let currentTarget: Element | undefined = target;\n  while (\n    currentTarget &&\n    currentTarget.nodeName !== \"TD\" &&\n    currentTarget.nodeName !== \"TH\" &&\n    !currentTarget.classList.contains(\"tableWrapper\")\n  ) {\n    if (currentTarget.classList.contains(\"ProseMirror\")) {\n      return undefined;\n    }\n    const parent: ParentNode | null = currentTarget.parentNode;\n\n    if (!parent || !(parent instanceof Element)) {\n      return undefined;\n    }\n    currentTarget = parent;\n  }\n\n  return currentTarget.nodeName === \"TD\" || currentTarget.nodeName === \"TH\"\n    ? {\n        type: \"cell\",\n        domNode: currentTarget,\n        tbodyNode: currentTarget.closest(\"tbody\"),\n      }\n    : {\n        type: \"wrapper\",\n        domNode: currentTarget,\n        tbodyNode: currentTarget.querySelector(\"tbody\"),\n      };\n}\n\n// Hides elements in the DOMwith the provided class names.\nfunction hideElements(selector: string, rootEl: Document | ShadowRoot) {\n  const elementsToHide = rootEl.querySelectorAll(selector);\n\n  for (let i = 0; i < elementsToHide.length; i++) {\n    (elementsToHide[i] as HTMLElement).style.visibility = \"hidden\";\n  }\n}\n\nexport class TableHandlesView implements PluginView {\n  public state?: TableHandlesState;\n  public emitUpdate: () => void;\n\n  public tableId: string | undefined;\n  public tablePos: number | undefined;\n  public tableElement: HTMLElement | undefined;\n\n  public menuFrozen = false;\n\n  public mouseState: \"up\" | \"down\" | \"selecting\" = \"up\";\n\n  public prevWasEditable: boolean | null = null;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n      any,\n      any\n    >,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: TableHandlesState) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousemove\", this.mouseMoveHandler);\n    pmView.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    window.addEventListener(\"mouseup\", this.mouseUpHandler);\n\n    pmView.root.addEventListener(\n      \"dragover\",\n      this.dragOverHandler as EventListener,\n    );\n    pmView.root.addEventListener(\n      \"drop\",\n      this.dropHandler as unknown as EventListener,\n    );\n  }\n\n  viewMousedownHandler = () => {\n    this.mouseState = \"down\";\n  };\n\n  mouseUpHandler = (event: MouseEvent) => {\n    this.mouseState = \"up\";\n    this.mouseMoveHandler(event);\n  };\n\n  mouseMoveHandler = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    if (this.mouseState === \"selecting\") {\n      return;\n    }\n\n    if (\n      !(event.target instanceof Element) ||\n      !this.pmView.dom.contains(event.target)\n    ) {\n      return;\n    }\n\n    const target = domCellAround(event.target);\n\n    if (\n      target?.type === \"cell\" &&\n      this.mouseState === \"down\" &&\n      !this.state?.draggingState\n    ) {\n      // hide draghandles when selecting text as they could be in the way of the user\n      this.mouseState = \"selecting\";\n\n      if (this.state?.show) {\n        this.state.show = false;\n        this.state.showAddOrRemoveRowsButton = false;\n        this.state.showAddOrRemoveColumnsButton = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    if (!target || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.state.showAddOrRemoveRowsButton = false;\n        this.state.showAddOrRemoveColumnsButton = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    if (!target.tbodyNode) {\n      return;\n    }\n\n    const tableRect = target.tbodyNode.getBoundingClientRect();\n\n    const blockEl = getDraggableBlockFromElement(target.domNode, this.pmView);\n    if (!blockEl) {\n      return;\n    }\n    this.tableElement = blockEl.node;\n\n    let tableBlock:\n      | BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>\n      | undefined;\n\n    const pmNodeInfo = this.editor.transact((tr) =>\n      getNodeById(blockEl.id, tr.doc),\n    );\n    if (!pmNodeInfo) {\n      throw new Error(`Block with ID ${blockEl.id} not found`);\n    }\n\n    const block = nodeToBlock(\n      pmNodeInfo.node,\n      this.editor.pmSchema,\n      this.editor.schema.blockSchema,\n      this.editor.schema.inlineContentSchema,\n      this.editor.schema.styleSchema,\n    );\n\n    if (editorHasBlockWithType(this.editor, \"table\")) {\n      this.tablePos = pmNodeInfo.posBeforeNode + 1;\n      tableBlock = block;\n    }\n\n    if (!tableBlock) {\n      return;\n    }\n\n    this.tableId = blockEl.id;\n    const widgetContainer = target.domNode\n      .closest(\".tableWrapper\")\n      ?.querySelector(\".table-widgets-container\") as HTMLElement;\n\n    if (target?.type === \"wrapper\") {\n      // if we're just to the right or below the table, show the extend buttons\n      // (this is a bit hacky. It would probably be cleaner to render the extend buttons in the Table NodeView instead)\n      const belowTable =\n        event.clientY >= tableRect.bottom - 1 && // -1 to account for fractions of pixels in \"bottom\"\n        event.clientY < tableRect.bottom + 20;\n      const toRightOfTable =\n        event.clientX >= tableRect.right - 1 &&\n        event.clientX < tableRect.right + 20;\n\n      // without this check, we'd also hide draghandles when hovering over them\n      const hideHandles =\n        event.clientX > tableRect.right || event.clientY > tableRect.bottom;\n\n      this.state = {\n        ...this.state!,\n        show: true,\n        showAddOrRemoveRowsButton: belowTable,\n        showAddOrRemoveColumnsButton: toRightOfTable,\n        referencePosTable: tableRect,\n        block: tableBlock,\n        widgetContainer,\n        colIndex: hideHandles ? undefined : this.state?.colIndex,\n        rowIndex: hideHandles ? undefined : this.state?.rowIndex,\n        referencePosCell: hideHandles\n          ? undefined\n          : this.state?.referencePosCell,\n      };\n    } else {\n      const colIndex = getChildIndex(target.domNode);\n      const rowIndex = getChildIndex(target.domNode.parentElement!);\n      const cellRect = target.domNode.getBoundingClientRect();\n\n      if (\n        this.state !== undefined &&\n        this.state.show &&\n        this.tableId === blockEl.id &&\n        this.state.rowIndex === rowIndex &&\n        this.state.colIndex === colIndex\n      ) {\n        // no update needed\n        return;\n      }\n\n      this.state = {\n        show: true,\n        showAddOrRemoveColumnsButton:\n          colIndex === tableBlock.content.rows[0].cells.length - 1,\n        showAddOrRemoveRowsButton:\n          rowIndex === tableBlock.content.rows.length - 1,\n        referencePosTable: tableRect,\n\n        block: tableBlock,\n        draggingState: undefined,\n        referencePosCell: cellRect,\n        colIndex: colIndex,\n        rowIndex: rowIndex,\n\n        widgetContainer,\n      };\n    }\n    this.emitUpdate();\n\n    return false;\n  };\n\n  dragOverHandler = (event: DragEvent) => {\n    if (this.state?.draggingState === undefined) {\n      return;\n    }\n\n    event.preventDefault();\n    event.dataTransfer!.dropEffect = \"move\";\n\n    hideElements(\n      \".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline\",\n      this.pmView.root,\n    );\n\n    // The mouse cursor coordinates, bounded to the table's bounding box. The\n    // bounding box is shrunk by 1px on each side to ensure that the bounded\n    // coordinates are always inside a table cell.\n    const boundedMouseCoords = {\n      left: Math.min(\n        Math.max(event.clientX, this.state.referencePosTable.left + 1),\n        this.state.referencePosTable.right - 1,\n      ),\n      top: Math.min(\n        Math.max(event.clientY, this.state.referencePosTable.top + 1),\n        this.state.referencePosTable.bottom - 1,\n      ),\n    };\n\n    // Gets the table cell element that the bounded mouse cursor coordinates lie\n    // in.\n    const tableCellElements = this.pmView.root\n      .elementsFromPoint(boundedMouseCoords.left, boundedMouseCoords.top)\n      .filter(\n        (element) => element.tagName === \"TD\" || element.tagName === \"TH\",\n      );\n    if (tableCellElements.length === 0) {\n      return;\n    }\n    const tableCellElement = tableCellElements[0];\n\n    let emitStateUpdate = false;\n\n    // Gets current row and column index.\n    const rowIndex = getChildIndex(tableCellElement.parentElement!);\n    const colIndex = getChildIndex(tableCellElement);\n\n    // Checks if the drop cursor needs to be updated. This affects decorations\n    // only so it doesn't trigger a state update.\n    const oldIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? this.state.rowIndex\n        : this.state.colIndex;\n    const newIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? rowIndex\n        : colIndex;\n    const dispatchDecorationsTransaction = newIndex !== oldIndex;\n\n    // Checks if either the hovered cell has changed and updates the row and\n    // column index. Also updates the reference DOMRect.\n    if (this.state.rowIndex !== rowIndex || this.state.colIndex !== colIndex) {\n      this.state.rowIndex = rowIndex;\n      this.state.colIndex = colIndex;\n\n      this.state.referencePosCell = tableCellElement.getBoundingClientRect();\n\n      emitStateUpdate = true;\n    }\n\n    // Checks if the mouse cursor position along the axis that the user is\n    // dragging on has changed and updates it.\n    const mousePos =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? boundedMouseCoords.top\n        : boundedMouseCoords.left;\n    if (this.state.draggingState.mousePos !== mousePos) {\n      this.state.draggingState.mousePos = mousePos;\n\n      emitStateUpdate = true;\n    }\n\n    // Emits a state update if any of the fields have changed.\n    if (emitStateUpdate) {\n      this.emitUpdate();\n    }\n\n    // Dispatches a dummy transaction to force a decorations update if\n    // necessary.\n    if (dispatchDecorationsTransaction) {\n      this.editor.transact((tr) => tr.setMeta(tableHandlesPluginKey, true));\n    }\n  };\n\n  dropHandler = (event: DragEvent) => {\n    this.mouseState = \"up\";\n    if (this.state === undefined || this.state.draggingState === undefined) {\n      return false;\n    }\n\n    if (\n      this.state.rowIndex === undefined ||\n      this.state.colIndex === undefined\n    ) {\n      throw new Error(\n        \"Attempted to drop table row or column, but no table block was hovered prior.\",\n      );\n    }\n\n    event.preventDefault();\n\n    const { draggingState, colIndex, rowIndex } = this.state;\n\n    const columnWidths = this.state.block.content.columnWidths;\n\n    if (draggingState.draggedCellOrientation === \"row\") {\n      if (\n        !canRowBeDraggedInto(\n          this.state.block,\n          draggingState.originalIndex,\n          rowIndex,\n        )\n      ) {\n        // If the target row is invalid, don't move the row\n        return false;\n      }\n      const newTable = moveRow(\n        this.state.block,\n        draggingState.originalIndex,\n        rowIndex,\n      );\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          ...this.state.block.content,\n          rows: newTable as any,\n        },\n      });\n    } else {\n      if (\n        !canColumnBeDraggedInto(\n          this.state.block,\n          draggingState.originalIndex,\n          colIndex,\n        )\n      ) {\n        // If the target column is invalid, don't move the column\n        return false;\n      }\n      const newTable = moveColumn(\n        this.state.block,\n        draggingState.originalIndex,\n        colIndex,\n      );\n      const [columnWidth] = columnWidths.splice(draggingState.originalIndex, 1);\n      columnWidths.splice(colIndex, 0, columnWidth);\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          ...this.state.block.content,\n          columnWidths,\n          rows: newTable as any,\n        },\n      });\n    }\n\n    // Have to reset text cursor position to the block as `updateBlock` moves\n    // the existing selection out of the block.\n    this.editor.setTextCursorPosition(this.state.block.id);\n\n    return true;\n  };\n  // Updates drag handles when the table is modified or removed.\n  update() {\n    if (!this.state || !this.state.show) {\n      return;\n    }\n\n    // Hide handles if the table block has been removed.\n    this.state.block = this.editor.getBlock(this.state.block.id)!;\n    if (\n      !this.state.block ||\n      this.state.block.type !== \"table\" ||\n      // when collaborating, the table element might be replaced and out of date\n      // because yjs replaces the element when for example you change the color via the side menu\n      !this.tableElement?.isConnected\n    ) {\n      this.state.show = false;\n      this.state.showAddOrRemoveRowsButton = false;\n      this.state.showAddOrRemoveColumnsButton = false;\n      this.emitUpdate();\n\n      return;\n    }\n\n    const { height: rowCount, width: colCount } = getDimensionsOfTable(\n      this.state.block,\n    );\n\n    if (\n      this.state.rowIndex !== undefined &&\n      this.state.colIndex !== undefined\n    ) {\n      // If rows or columns are deleted in the update, the hovered indices for\n      // those may now be out of bounds. If this is the case, they are moved to\n      // the new last row or column.\n      if (this.state.rowIndex >= rowCount) {\n        this.state.rowIndex = rowCount - 1;\n      }\n      if (this.state.colIndex >= colCount) {\n        this.state.colIndex = colCount - 1;\n      }\n    }\n\n    // Update bounding boxes.\n    const tableBody = this.tableElement!.querySelector(\"tbody\");\n\n    if (!tableBody) {\n      throw new Error(\n        \"Table block does not contain a 'tbody' HTML element. This should never happen.\",\n      );\n    }\n\n    if (\n      this.state.rowIndex !== undefined &&\n      this.state.colIndex !== undefined\n    ) {\n      const row = tableBody.children[this.state.rowIndex];\n      const cell = row.children[this.state.colIndex];\n      if (cell) {\n        this.state.referencePosCell = cell.getBoundingClientRect();\n      } else {\n        this.state.rowIndex = undefined;\n        this.state.colIndex = undefined;\n      }\n    }\n    this.state.referencePosTable = tableBody.getBoundingClientRect();\n\n    this.emitUpdate();\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.removeEventListener(\"mouseup\", this.mouseUpHandler);\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.dragOverHandler as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"drop\",\n      this.dropHandler as unknown as EventListener,\n    );\n  }\n}\n\nexport const tableHandlesPluginKey = new PluginKey(\"TableHandlesPlugin\");\n\nexport const TableHandlesExtension = createExtension(({ editor }) => {\n  let view: TableHandlesView | undefined = undefined;\n\n  const store = createStore<TableHandlesState | undefined>(undefined);\n\n  return {\n    key: \"tableHandles\",\n    store,\n    prosemirrorPlugins: [\n      new Plugin({\n        key: tableHandlesPluginKey,\n        view: (editorView) => {\n          view = new TableHandlesView(editor as any, editorView, (state) => {\n            store.setState(\n              state.block\n                ? {\n                    ...state,\n                    draggingState: state.draggingState\n                      ? { ...state.draggingState }\n                      : undefined,\n                  }\n                : undefined,\n            );\n          });\n          return view;\n        },\n        // We use decorations to render the drop cursor when dragging a table row\n        // or column. The decorations are updated in the `dragOverHandler` method.\n        props: {\n          decorations: (state) => {\n            if (\n              view === undefined ||\n              view.state === undefined ||\n              view.state.draggingState === undefined ||\n              view.tablePos === undefined\n            ) {\n              return;\n            }\n\n            const newIndex =\n              view.state.draggingState.draggedCellOrientation === \"row\"\n                ? view.state.rowIndex\n                : view.state.colIndex;\n\n            if (newIndex === undefined) {\n              return;\n            }\n\n            const decorations: Decoration[] = [];\n            const { block, draggingState } = view.state;\n            const { originalIndex, draggedCellOrientation } = draggingState;\n\n            // Return empty decorations if:\n            // - Dragging to same position\n            // - No block exists\n            // - Row drag not allowed\n            // - Column drag not allowed\n            if (\n              newIndex === originalIndex ||\n              !block ||\n              (draggedCellOrientation === \"row\" &&\n                !canRowBeDraggedInto(block, originalIndex, newIndex)) ||\n              (draggedCellOrientation === \"col\" &&\n                !canColumnBeDraggedInto(block, originalIndex, newIndex))\n            ) {\n              return DecorationSet.create(state.doc, decorations);\n            }\n\n            // Gets the table to show the drop cursor in.\n            const tableResolvedPos = state.doc.resolve(view.tablePos + 1);\n\n            if (view.state.draggingState.draggedCellOrientation === \"row\") {\n              const cellsInRow = getCellsAtRowHandle(\n                view.state.block,\n                newIndex,\n              );\n\n              cellsInRow.forEach(({ row, col }) => {\n                // Gets each row in the table.\n                const rowResolvedPos = state.doc.resolve(\n                  tableResolvedPos.posAtIndex(row) + 1,\n                );\n\n                // Gets the cell within the row.\n                const cellResolvedPos = state.doc.resolve(\n                  rowResolvedPos.posAtIndex(col) + 1,\n                );\n                const cellNode = cellResolvedPos.node();\n                // Creates a decoration at the start or end of each cell,\n                // depending on whether the new index is before or after the\n                // original index.\n                const decorationPos =\n                  cellResolvedPos.pos +\n                  (newIndex > originalIndex ? cellNode.nodeSize - 2 : 0);\n                decorations.push(\n                  // The widget is a small bar which spans the width of the cell.\n                  Decoration.widget(decorationPos, () => {\n                    const widget = document.createElement(\"div\");\n                    widget.className = \"bn-table-drop-cursor\";\n                    widget.style.left = \"0\";\n                    widget.style.right = \"0\";\n                    // This is only necessary because the drop indicator's height\n                    // is an even number of pixels, whereas the border between\n                    // table cells is an odd number of pixels. So this makes the\n                    // positioning slightly more consistent regardless of where\n                    // the row is being dropped.\n                    if (newIndex > originalIndex) {\n                      widget.style.bottom = \"-2px\";\n                    } else {\n                      widget.style.top = \"-3px\";\n                    }\n                    widget.style.height = \"4px\";\n\n                    return widget;\n                  }),\n                );\n              });\n            } else {\n              const cellsInColumn = getCellsAtColumnHandle(\n                view.state.block,\n                newIndex,\n              );\n\n              cellsInColumn.forEach(({ row, col }) => {\n                // Gets each row in the table.\n                const rowResolvedPos = state.doc.resolve(\n                  tableResolvedPos.posAtIndex(row) + 1,\n                );\n\n                // Gets the cell within the row.\n                const cellResolvedPos = state.doc.resolve(\n                  rowResolvedPos.posAtIndex(col) + 1,\n                );\n                const cellNode = cellResolvedPos.node();\n\n                // Creates a decoration at the start or end of each cell,\n                // depending on whether the new index is before or after the\n                // original index.\n                const decorationPos =\n                  cellResolvedPos.pos +\n                  (newIndex > originalIndex ? cellNode.nodeSize - 2 : 0);\n\n                decorations.push(\n                  // The widget is a small bar which spans the height of the cell.\n                  Decoration.widget(decorationPos, () => {\n                    const widget = document.createElement(\"div\");\n                    widget.className = \"bn-table-drop-cursor\";\n                    widget.style.top = \"0\";\n                    widget.style.bottom = \"0\";\n                    // This is only necessary because the drop indicator's width\n                    // is an even number of pixels, whereas the border between\n                    // table cells is an odd number of pixels. So this makes the\n                    // positioning slightly more consistent regardless of where\n                    // the column is being dropped.\n                    if (newIndex > originalIndex) {\n                      widget.style.right = \"-2px\";\n                    } else {\n                      widget.style.left = \"-3px\";\n                    }\n                    widget.style.width = \"4px\";\n\n                    return widget;\n                  }),\n                );\n              });\n            }\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    ],\n\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the column drag handle.\n     */\n    colDragStart(event: {\n      dataTransfer: DataTransfer | null;\n      clientX: number;\n    }) {\n      if (\n        view === undefined ||\n        view.state === undefined ||\n        view.state.colIndex === undefined\n      ) {\n        throw new Error(\n          \"Attempted to drag table column, but no table block was hovered prior.\",\n        );\n      }\n\n      view.state.draggingState = {\n        draggedCellOrientation: \"col\",\n        originalIndex: view.state.colIndex,\n        mousePos: event.clientX,\n      };\n      view.emitUpdate();\n\n      editor.transact((tr) =>\n        tr.setMeta(tableHandlesPluginKey, {\n          draggedCellOrientation:\n            view!.state!.draggingState!.draggedCellOrientation,\n          originalIndex: view!.state!.colIndex,\n          newIndex: view!.state!.colIndex,\n          tablePos: view!.tablePos,\n        }),\n      );\n\n      if (editor.headless) {\n        return;\n      }\n\n      setHiddenDragImage(editor.prosemirrorView.root);\n      event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n      event.dataTransfer!.effectAllowed = \"move\";\n    },\n\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the row drag handle.\n     */\n    rowDragStart(event: {\n      dataTransfer: DataTransfer | null;\n      clientY: number;\n    }) {\n      if (view!.state === undefined || view!.state.rowIndex === undefined) {\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\",\n        );\n      }\n\n      view!.state.draggingState = {\n        draggedCellOrientation: \"row\",\n        originalIndex: view!.state.rowIndex,\n        mousePos: event.clientY,\n      };\n      view!.emitUpdate();\n\n      editor.transact((tr) =>\n        tr.setMeta(tableHandlesPluginKey, {\n          draggedCellOrientation:\n            view!.state!.draggingState!.draggedCellOrientation,\n          originalIndex: view!.state!.rowIndex,\n          newIndex: view!.state!.rowIndex,\n          tablePos: view!.tablePos,\n        }),\n      );\n\n      if (editor.headless) {\n        return;\n      }\n\n      setHiddenDragImage(editor.prosemirrorView.root);\n      event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n      event.dataTransfer!.effectAllowed = \"copyMove\";\n    },\n\n    /**\n     * Callback that should be set on the `dragEnd` event for both the element\n     * used as the row drag handle, and the one used as the column drag handle.\n     */\n    dragEnd() {\n      if (view!.state === undefined) {\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\",\n        );\n      }\n\n      view!.state.draggingState = undefined;\n      view!.emitUpdate();\n\n      editor.transact((tr) => tr.setMeta(tableHandlesPluginKey, null));\n\n      if (editor.headless) {\n        return;\n      }\n\n      unsetHiddenDragImage(editor.prosemirrorView.root);\n    },\n\n    /**\n     * Freezes the drag handles. When frozen, they will stay attached to the same\n     * cell regardless of which cell is hovered by the mouse cursor.\n     */\n    freezeHandles() {\n      view!.menuFrozen = true;\n    },\n\n    /**\n     * Unfreezes the drag handles. When frozen, they will stay attached to the\n     * same cell regardless of which cell is hovered by the mouse cursor.\n     */\n    unfreezeHandles() {\n      view!.menuFrozen = false;\n    },\n\n    getCellsAtRowHandle(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      relativeRowIndex: RelativeCellIndices[\"row\"],\n    ) {\n      return getCellsAtRowHandle(block, relativeRowIndex);\n    },\n\n    /**\n     * Get all the cells in a column of the table block.\n     */\n    getCellsAtColumnHandle(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      relativeColumnIndex: RelativeCellIndices[\"col\"],\n    ) {\n      return getCellsAtColumnHandle(block, relativeColumnIndex);\n    },\n\n    /**\n     * Sets the selection to the given cell or a range of cells.\n     * @returns The new state after the selection has been set.\n     */\n    setCellSelection(\n      state: EditorState,\n      relativeStartCell: RelativeCellIndices,\n      relativeEndCell: RelativeCellIndices = relativeStartCell,\n    ) {\n      if (!view) {\n        throw new Error(\"Table handles view not initialized\");\n      }\n\n      const tableResolvedPos = state.doc.resolve(view.tablePos! + 1);\n      const startRowResolvedPos = state.doc.resolve(\n        tableResolvedPos.posAtIndex(relativeStartCell.row) + 1,\n      );\n      const startCellResolvedPos = state.doc.resolve(\n        // No need for +1, since CellSelection expects the position before the cell\n        startRowResolvedPos.posAtIndex(relativeStartCell.col),\n      );\n      const endRowResolvedPos = state.doc.resolve(\n        tableResolvedPos.posAtIndex(relativeEndCell.row) + 1,\n      );\n      const endCellResolvedPos = state.doc.resolve(\n        // No need for +1, since CellSelection expects the position before the cell\n        endRowResolvedPos.posAtIndex(relativeEndCell.col),\n      );\n\n      // Begin a new transaction to set the selection\n      const tr = state.tr;\n\n      // Set the selection to the given cell or a range of cells\n      tr.setSelection(\n        new CellSelection(startCellResolvedPos, endCellResolvedPos),\n      );\n\n      // Quickly apply the transaction to get the new state to update the selection before splitting the cell\n      return state.apply(tr);\n    },\n\n    /**\n     * Adds a row or column to the table using prosemirror-table commands\n     */\n    addRowOrColumn(\n      index: RelativeCellIndices[\"row\"] | RelativeCellIndices[\"col\"],\n      direction:\n        | { orientation: \"row\"; side: \"above\" | \"below\" }\n        | { orientation: \"column\"; side: \"left\" | \"right\" },\n    ) {\n      editor.exec((beforeState, dispatch) => {\n        const state = this.setCellSelection(\n          beforeState,\n          direction.orientation === \"row\"\n            ? { row: index, col: 0 }\n            : { row: 0, col: index },\n        );\n\n        if (direction.orientation === \"row\") {\n          if (direction.side === \"above\") {\n            return addRowBefore(state, dispatch);\n          } else {\n            return addRowAfter(state, dispatch);\n          }\n        } else {\n          if (direction.side === \"left\") {\n            return addColumnBefore(state, dispatch);\n          } else {\n            return addColumnAfter(state, dispatch);\n          }\n        }\n      });\n    },\n\n    /**\n     * Removes a row or column from the table using prosemirror-table commands\n     */\n    removeRowOrColumn(\n      index: RelativeCellIndices[\"row\"] | RelativeCellIndices[\"col\"],\n      direction: \"row\" | \"column\",\n    ) {\n      if (direction === \"row\") {\n        return editor.exec((beforeState, dispatch) => {\n          const state = this.setCellSelection(beforeState, {\n            row: index,\n            col: 0,\n          });\n          return deleteRow(state, dispatch);\n        });\n      } else {\n        return editor.exec((beforeState, dispatch) => {\n          const state = this.setCellSelection(beforeState, {\n            row: 0,\n            col: index,\n          });\n          return deleteColumn(state, dispatch);\n        });\n      }\n    },\n\n    /**\n     * Merges the cells in the table block.\n     */\n    mergeCells(cellsToMerge?: {\n      relativeStartCell: RelativeCellIndices;\n      relativeEndCell: RelativeCellIndices;\n    }) {\n      return editor.exec((beforeState, dispatch) => {\n        const state = cellsToMerge\n          ? this.setCellSelection(\n              beforeState,\n              cellsToMerge.relativeStartCell,\n              cellsToMerge.relativeEndCell,\n            )\n          : beforeState;\n\n        return mergeCells(state, dispatch);\n      });\n    },\n\n    /**\n     * Splits the cell in the table block.\n     * If no cell is provided, the current cell selected will be split.\n     */\n    splitCell(relativeCellToSplit?: RelativeCellIndices) {\n      return editor.exec((beforeState, dispatch) => {\n        const state = relativeCellToSplit\n          ? this.setCellSelection(beforeState, relativeCellToSplit)\n          : beforeState;\n\n        return splitCell(state, dispatch);\n      });\n    },\n\n    /**\n     * Gets the start and end cells of the current cell selection.\n     * @returns The start and end cells of the current cell selection.\n     */\n    getCellSelection():\n      | undefined\n      | {\n          from: RelativeCellIndices;\n          to: RelativeCellIndices;\n          /**\n           * All of the cells that are within the selected range.\n           */\n          cells: RelativeCellIndices[];\n        } {\n      // Based on the current selection, find the table cells that are within the selected range\n\n      return editor.transact((tr) => {\n        const selection = tr.selection;\n\n        let $fromCell = selection.$from;\n        let $toCell = selection.$to;\n        if (isTableCellSelection(selection)) {\n          // When the selection is a table cell selection, we can find the\n          // from and to cells by iterating over the ranges in the selection\n          const { ranges } = selection;\n          ranges.forEach((range) => {\n            $fromCell = range.$from.min($fromCell ?? range.$from);\n            $toCell = range.$to.max($toCell ?? range.$to);\n          });\n        } else {\n          // When the selection is a normal text selection\n          // Assumes we are within a tableParagraph\n          // And find the from and to cells by resolving the positions\n          $fromCell = tr.doc.resolve(\n            selection.$from.pos - selection.$from.parentOffset - 1,\n          );\n          $toCell = tr.doc.resolve(\n            selection.$to.pos - selection.$to.parentOffset - 1,\n          );\n\n          // Opt-out when the selection is not pointing into cells\n          if ($fromCell.pos === 0 || $toCell.pos === 0) {\n            return undefined;\n          }\n        }\n\n        // Find the row and table that the from and to cells are in\n        const $fromRow = tr.doc.resolve(\n          $fromCell.pos - $fromCell.parentOffset - 1,\n        );\n        const $toRow = tr.doc.resolve($toCell.pos - $toCell.parentOffset - 1);\n\n        // Find the table\n        const $table = tr.doc.resolve($fromRow.pos - $fromRow.parentOffset - 1);\n\n        // Find the column and row indices of the from and to cells\n        const fromColIndex = $fromCell.index($fromRow.depth);\n        const fromRowIndex = $fromRow.index($table.depth);\n        const toColIndex = $toCell.index($toRow.depth);\n        const toRowIndex = $toRow.index($table.depth);\n\n        const cells: RelativeCellIndices[] = [];\n        for (let row = fromRowIndex; row <= toRowIndex; row++) {\n          for (let col = fromColIndex; col <= toColIndex; col++) {\n            cells.push({ row, col });\n          }\n        }\n\n        return {\n          from: {\n            row: fromRowIndex,\n            col: fromColIndex,\n          },\n          to: {\n            row: toRowIndex,\n            col: toColIndex,\n          },\n          cells,\n        };\n      });\n    },\n\n    /**\n     * Gets the direction of the merge based on the current cell selection.\n     *\n     * Returns undefined when there is no cell selection, or the selection is not within a table.\n     */\n    getMergeDirection(\n      block:\n        | BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>\n        | undefined,\n    ) {\n      return editor.transact((tr) => {\n        const isSelectingTableCells = isTableCellSelection(tr.selection)\n          ? tr.selection\n          : undefined;\n\n        if (\n          !isSelectingTableCells ||\n          !block ||\n          // Only offer the merge button if there is more than one cell selected.\n          isSelectingTableCells.ranges.length <= 1\n        ) {\n          return undefined;\n        }\n\n        const cellSelection = this.getCellSelection();\n\n        if (!cellSelection) {\n          return undefined;\n        }\n\n        if (areInSameColumn(cellSelection.from, cellSelection.to, block)) {\n          return \"vertical\";\n        }\n\n        return \"horizontal\";\n      });\n    },\n\n    cropEmptyRowsOrColumns(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      removeEmpty: \"columns\" | \"rows\",\n    ) {\n      return cropEmptyRowsOrColumns(block, removeEmpty);\n    },\n\n    addRowsOrColumns(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      addType: \"columns\" | \"rows\",\n      numToAdd: number,\n    ) {\n      return addRowsOrColumns(block, addType, numToAdd);\n    },\n  } as const;\n});\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\n// based on https://github.com/ueberdosis/tiptap/blob/40a9404c94c7fef7900610c195536384781ae101/demos/src/Experiments/TrailingNode/Vue/trailing-node.ts\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\nconst plugin = new PluginKey(\"trailingNode\");\n\n/**\n * Add a trailing node to the document so the user can always click at the bottom of the document and start typing\n */\nexport const TrailingNodeExtension = createExtension(() => {\n  return {\n    key: \"trailingNode\",\n    prosemirrorPlugins: [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size - 2;\n          const type = schema.nodes[\"blockContainer\"];\n          const contentType = schema.nodes[\"paragraph\"];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n\n          return tr.insert(\n            endPosition,\n            type.create(undefined, contentType.create()),\n          );\n        },\n        state: {\n          init: (_, _state) => {\n            // (maybe fix): use same logic as apply() here\n            // so it works when initializing\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            let lastNode = tr.doc.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockGroup\") {\n              throw new Error(\"Expected blockGroup\");\n            }\n\n            lastNode = lastNode.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockContainer\") {\n              return true; // not a blockContainer, but for example Columns. Insert trailing node\n            }\n\n            const lastContentNode = lastNode.firstChild;\n\n            if (!lastContentNode) {\n              throw new Error(\"Expected blockContent\");\n            }\n\n            // If last node is not empty (size > 4) or it doesn't contain\n            // inline content, we need to add a trailing node.\n            return (\n              lastNode.nodeSize > 4 ||\n              lastContentNode.type.spec.content !== \"inline*\"\n            );\n          },\n        },\n      }),\n    ],\n  } as const;\n});\n"],"names":["addAttributesAndRemoveClasses","element","className","serializeInlineContentExternalHTML","editor","blockContent","serializer","options","nodes","inlineContentToNodes","tableContentToNodes","UnreachableCaseError","fragment","node","inlineContentImplementation","inlineContent","nodeToCustomInlineContent","output","contentFragment","dom","mark","newDom","domOutputSpec","DOMSerializer","nodeFragment","Fragment","_a","serializeBlock","block","orderedListItemBlockTypes","unorderedListItemBlockTypes","doc","BC_NODE","props","name","spec","bc","_b","attrs","blockImplementation","ret","_c","elementFragment","blockContentDataAttributes","attr","ic","listType","_d","list","childFragment","serializeBlocksToFragment","_e","_f","_g","_h","_i","blocks","serializeBlocksExternalHTML","createExternalHTMLExporter","schema","html","div","domFragment","parent","getParentBlockId","pos","resolvedPos","i","isNodeBlock","determineChangeSource","transaction","collectSnapshot","ROOT_KEY","byId","childrenByParent","pmSchema","getPmSchema","parentId","key","nodeToBlock","detectReorderedChildren","prevOrder","nextOrder","moved","prevIds","commonNext","id","commonPrev","indexInPrev","sequence","n","tailsValues","tailsEndsAtIndex","previousIndexInLis","lowerBound","arr","target","lo","hi","mid","value","lisIndexSet","k","getBlocksChangedByTransaction","appendedTransactions","source","combinedTransaction","combineTransactionSteps","prevSnap","nextSnap","changes","changedIds","prev","next","deepEqual","prevOrderByParent","nextOrderByParent","parents","addedMoveForId","parentKey","movedWithinParent","BlockChangeExtension","createExtension","beforeChangeCallbacks","Plugin","PluginKey","tr","acc","cb","callback","isDarkColor","bgColor","color","r","g","b","c","col","defaultCursorRender","user","cursorElement","caretElement","labelElement","YCursorExtension","recentlyUpdatedCursors","awareness","updated","clientID","cursor","yCursorPlugin","defaultSelectionBuilder","cursorData","YSyncExtension","ySyncPlugin","YUndoExtension","yUndoPlugin","undoCommand","redoCommand","findTypeInOtherYdoc","ytype","otherYdoc","ydoc","rootKey","ytypeItem","otherStructs","itemIndex","Y","ForkYDocExtension","forkedState","store","createStore","originalFragment","forkedFragment","yUndoPluginKey","newOptions","keepChanges","undoStack","update","traverseElement","rootElement","moveColorAttributes","targetBlockContainers","textColor","backgroundColor","colors","defaultProps","el","migrationRules","SchemaMigration","migrationDone","pluginKey","transactions","_oldState","newState","migrationRule","DropCursorExtension","dropCursor","FormattingToolbarExtension","shouldShow","NodeSelection","TextSelection","spansCode","signal","preventShowWhileMouseDown","unsubscribeOnChange","unsubscribeOnSelectionChange","HistoryExtension","history","undo","redo","LinkToolbarExtension","getLinkElementAtPos","currentNode","getMarkAtPos","markType","markRange","getMarkRange","posToDOMRect","getLinkAtSelection","selection","posAtElement","url","text","position","range","VALID_LINK_PROTOCOLS","DEFAULT_LINK_PROTOCOL","PLUGIN_KEY","NodeSelectionKeyboardExtension","view","event","PlaceholderExtension","placeholders","uniqueEditorSelector","v4","styleEl","nonce","styleSheet","getSelector","additionalSelectors","defaultPlaceholder","emptyPlaceholder","rest","blockType","placeholder","blockTypeSelector","onlyBlockSelector","mustBeFocusedSelector","e","state","decs","Decoration","$pos","before","DecorationSet","nodeAttributes","PreviousBlockTypeExtension","timeout","_editorView","_prevState","oldState","currentTransactionOriginalOldBlockAttrs","oldNodes","findChildren","oldNodesById","newNodes","oldNode","oldContentNode","newContentNode","newAttrs","oldAttrs","pluginState","decorations","prevAttrs","decorationAttrs","nodeAttr","val","decoration","getDraggableBlockFromElement","removeUnderlines","removeUnderlinesHelper","tree","numChildElements","numElementsAdded","addSpacesToCheckboxes","helper","child","nextChild","fromDom","convertVideoToMarkdown","visit","index","src","cleanHTMLToMarkdown","cleanHTMLString","unified","rehypeParse","rehypeRemark","remarkGfm","remarkStringify","blocksToMarkdown","externalHTML","fragmentToBlocks","MultipleNodeSelection","Selection","$anchor","$head","__publicField","parentNode","_pos","from","to","Slice","mapping","fromResult","toResult","dragImageElement","blockPositionsFromSelection","beforeFirstBlockPos","afterLastBlockPos","selectionStartInBlockContent","selectionEndInBlockContent","minDepth","startFirstBlockPos","endLastBlockPos","setDragImage","parentClone","getElementIndex","parentElement","targetElement","firstSelectedBlockIndex","lastSelectedBlockIndex","unsetDragImage","iframes","iframe","inheritedClasses","rootEl","dragStart","posInfo","getNodeById","draggedBlockInSelection","multipleBlocksSelected","selectedSlice","clipboardHTML","externalHTMLExporter","plainText","DISTANCE_TO_CONSIDER_EDITOR_BOUNDS","getBlockFromCoords","coords","adjustForColumns","elements","getBlockFromMousePos","mousePos","editorBoundingBox","referenceBlock","referenceBlocksBoundingBox","SideMenuView","pmView","emitUpdate","closestEditor","blockContentBoundingBox","column","DOMParser","editors","minDistance","rect","distanceX","distanceY","distance","dragEventContext","evt","textContentIsBeingDragged","sideMenuIsBeingDragged","isDragOrigin","isDropPoint","isDropWithinEditorBounds","context","_event","editorOuterBoundingBox","cursorWithinEditor","editorWrapper","dropPointBoundingBox","_view","prevState","sideMenuPluginKey","SideMenuExtension","editorView","setHiddenDragImage","unsetHiddenDragImage","getChildIndex","domCellAround","currentTarget","hideElements","selector","elementsToHide","TableHandlesView","tableRect","blockEl","tableBlock","pmNodeInfo","editorHasBlockWithType","widgetContainer","belowTable","toRightOfTable","hideHandles","colIndex","rowIndex","cellRect","boundedMouseCoords","tableCellElements","tableCellElement","emitStateUpdate","oldIndex","dispatchDecorationsTransaction","tableHandlesPluginKey","draggingState","columnWidths","canRowBeDraggedInto","newTable","moveRow","canColumnBeDraggedInto","moveColumn","columnWidth","rowCount","colCount","getDimensionsOfTable","tableBody","cell","TableHandlesExtension","newIndex","originalIndex","draggedCellOrientation","tableResolvedPos","getCellsAtRowHandle","row","rowResolvedPos","cellResolvedPos","cellNode","decorationPos","widget","getCellsAtColumnHandle","relativeRowIndex","relativeColumnIndex","relativeStartCell","relativeEndCell","startRowResolvedPos","startCellResolvedPos","endRowResolvedPos","endCellResolvedPos","CellSelection","direction","beforeState","dispatch","addRowBefore","addRowAfter","addColumnBefore","addColumnAfter","deleteRow","deleteColumn","cellsToMerge","mergeCells","relativeCellToSplit","splitCell","$fromCell","$toCell","isTableCellSelection","ranges","$fromRow","$toRow","$table","fromColIndex","fromRowIndex","toColIndex","toRowIndex","cells","isSelectingTableCells","cellSelection","areInSameColumn","removeEmpty","cropEmptyRowsOrColumns","addType","numToAdd","addRowsOrColumns","plugin","TrailingNodeExtension","_","__","shouldInsertNodeAtEnd","endPosition","type","contentType","_state","lastNode","lastContentNode"],"mappings":"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"}