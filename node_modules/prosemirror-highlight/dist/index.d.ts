import { Node } from 'prosemirror-model';
import { Transaction, Plugin } from 'prosemirror-state';
import { Decoration, DecorationSet } from 'prosemirror-view';
import { P as Parser, L as LanguageExtractor } from './types-BIUZQh-P.js';

/**
 * Represents a cache of doc positions to the node and decorations at that position
 */
declare class DecorationCache {
    private cache;
    constructor(cache?: Map<number, [node: Node, decorations: Decoration[]]>);
    /**
     * Gets the cache entry at the given doc position, or null if it doesn't exist
     * @param pos The doc position of the node you want the cache for
     */
    get(pos: number): [node: Node, decorations: Decoration[]] | undefined;
    /**
     * Sets the cache entry at the given position with the give node/decoration
     * values
     * @param pos The doc position of the node to set the cache for
     * @param node The node to place in cache
     * @param decorations The decorations to place in cache
     */
    set(pos: number, node: Node, decorations: Decoration[]): void;
    /**
     * Removes the value at the oldPos (if it exists) and sets the new position to
     * the given values
     * @param oldPos The old node position to overwrite
     * @param newPos The new node position to set the cache for
     * @param node The new node to place in cache
     * @param decorations The new decorations to place in cache
     */
    private replace;
    /**
     * Removes the cache entry at the given position
     * @param pos The doc position to remove from cache
     */
    remove(pos: number): void;
    /**
     * Invalidates the cache by removing all decoration entries on nodes that have
     * changed, updating the positions of the nodes that haven't and removing all
     * the entries that have been deleted; NOTE: this does not affect the current
     * cache, but returns an entirely new one
     * @param tr A transaction to map the current cache to
     */
    invalidate(tr: Transaction): DecorationCache;
}

/**
 * Describes the current state of the highlightPlugin
 */
interface HighlightPluginState {
    cache: DecorationCache;
    decorations: DecorationSet;
    promises: Promise<void>[];
}
/**
 * Creates a plugin that highlights the contents of all nodes (via Decorations)
 * with a type passed in blockTypes
 */
declare function createHighlightPlugin({ parser, nodeTypes, languageExtractor, }: {
    /**
     * A function that returns an array of decorations for the given node text
     * content, language, and position.
     */
    parser: Parser;
    /**
     * An array containing all the node type name to target for highlighting.
     *
     * @default ['code_block', 'codeBlock']
     */
    nodeTypes?: string[];
    /**
     * A function that returns the language string to use when highlighting that
     * node. By default, it returns `node.attrs.language`.
     */
    languageExtractor?: LanguageExtractor;
}): Plugin<HighlightPluginState>;

export { DecorationCache, type HighlightPluginState, LanguageExtractor, Parser, createHighlightPlugin };
